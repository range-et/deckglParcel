import * as $7jljs$process from "process";

var $parcel$global =
typeof globalThis !== 'undefined'
  ? globalThis
  : typeof self !== 'undefined'
  ? self
  : typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
  ? global
  : {};
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequireb081"];
if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequireb081"] = parcelRequire;
}
parcelRequire.register("9aLFZ", function(module, exports) {
"use strict";

});

function $037483d1fb5deac8$export$2e2bcd8739ae039(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}



function $97fc0da493e153d5$export$2e2bcd8739ae039(mockUserAgent) {
    if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") return true;
    if (typeof $7jljs$process !== "undefined" && typeof $7jljs$process.versions === "object" && Boolean($7jljs$process.versions.electron)) return true;
    const realUserAgent = typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
    const userAgent = mockUserAgent || realUserAgent;
    if (userAgent && userAgent.indexOf("Electron") >= 0) return true;
    return false;
}



function $58cc8c917413a7dc$export$2e2bcd8739ae039() {
    const isNode = typeof $7jljs$process === "object" && String($7jljs$process) === "[object process]" && false;
    return !isNode || (0, $97fc0da493e153d5$export$2e2bcd8739ae039)();
}
function $58cc8c917413a7dc$export$fb09d24fafba666a() {
    return $58cc8c917413a7dc$export$2e2bcd8739ae039() && typeof document !== "undefined";
}



const $3b0c2dd0bdd7037d$export$a4ad2735b021c132 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "untranspiled source";
const $3b0c2dd0bdd7037d$export$4e09c449d6c407f7 = (0, $58cc8c917413a7dc$export$2e2bcd8739ae039)();


const $72a0e31c3f6d6aed$var$globals = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof $parcel$global !== "undefined" && $parcel$global,
    document: typeof document !== "undefined" && document,
    process: typeof $7jljs$process === "object" && $7jljs$process
};
const $72a0e31c3f6d6aed$export$90b4d2ff6acb88af = globalThis;
const $72a0e31c3f6d6aed$export$82c2e460fb230c2a = $72a0e31c3f6d6aed$var$globals.self || $72a0e31c3f6d6aed$var$globals.window || $72a0e31c3f6d6aed$var$globals.global;
const $72a0e31c3f6d6aed$export$8291e5b88f90ce4 = $72a0e31c3f6d6aed$var$globals.window || $72a0e31c3f6d6aed$var$globals.self || $72a0e31c3f6d6aed$var$globals.global;
const $72a0e31c3f6d6aed$export$5a7bfc01df82fcd1 = $72a0e31c3f6d6aed$var$globals.document || {};
const $72a0e31c3f6d6aed$export$e54fe5b0f43758f7 = $72a0e31c3f6d6aed$var$globals.process || {};
const $72a0e31c3f6d6aed$export$e896d9a1b4631fa1 = console;



const $ef7c7b0387e72f27$var$window = globalThis;
function $ef7c7b0387e72f27$export$d0a8044dce8ff2fc() {
    return typeof $ef7c7b0387e72f27$var$window.orientation !== "undefined";
}
function $ef7c7b0387e72f27$export$2e2bcd8739ae039(mockUserAgent) {
    if (!mockUserAgent && !(0, $58cc8c917413a7dc$export$2e2bcd8739ae039)()) return "Node";
    if ((0, $97fc0da493e153d5$export$2e2bcd8739ae039)(mockUserAgent)) return "Electron";
    const navigator_ = typeof navigator !== "undefined" ? navigator : {};
    const userAgent = mockUserAgent || navigator_.userAgent || "";
    if (userAgent.indexOf("Edge") > -1) return "Edge";
    const isMSIE = userAgent.indexOf("MSIE ") !== -1;
    const isTrident = userAgent.indexOf("Trident/") !== -1;
    if (isMSIE || isTrident) return "IE";
    if ($ef7c7b0387e72f27$var$window.chrome) return "Chrome";
    if ($ef7c7b0387e72f27$var$window.safari) return "Safari";
    if ($ef7c7b0387e72f27$var$window.mozInnerScreenX) return "Firefox";
    return "Unknown";
}




function $c1f669f220866fe9$var$getStorage(type) {
    try {
        const storage = window[type];
        const x = "__storage_test__";
        storage.setItem(x, x);
        storage.removeItem(x);
        return storage;
    } catch (e) {
        return null;
    }
}
class $c1f669f220866fe9$export$2e2bcd8739ae039 {
    constructor(id){
        let defaultSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "sessionStorage";
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "storage", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "config", {});
        this.storage = $c1f669f220866fe9$var$getStorage(type);
        this.id = id;
        this.config = {};
        Object.assign(this.config, defaultSettings);
        this._loadConfiguration();
    }
    getConfiguration() {
        return this.config;
    }
    setConfiguration(configuration) {
        this.config = {};
        return this.updateConfiguration(configuration);
    }
    updateConfiguration(configuration) {
        Object.assign(this.config, configuration);
        if (this.storage) {
            const serialized = JSON.stringify(this.config);
            this.storage.setItem(this.id, serialized);
        }
        return this;
    }
    _loadConfiguration() {
        let configuration = {};
        if (this.storage) {
            const serializedConfiguration = this.storage.getItem(this.id);
            configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
        }
        Object.assign(this.config, configuration);
        return this;
    }
}


function $3857e0fef6b33c0d$export$3203edd9e5edd663(ms) {
    let formatted;
    if (ms < 10) formatted = "".concat(ms.toFixed(2), "ms");
    else if (ms < 100) formatted = "".concat(ms.toFixed(1), "ms");
    else if (ms < 1000) formatted = "".concat(ms.toFixed(0), "ms");
    else formatted = "".concat((ms / 1000).toFixed(2), "s");
    return formatted;
}
function $3857e0fef6b33c0d$export$cbb503201166aab7(string) {
    let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
    const padLength = Math.max(length - string.length, 0);
    return "".concat(" ".repeat(padLength)).concat(string);
}
function $3857e0fef6b33c0d$export$390245bab32fb60f(string) {
    let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
    const padLength = Math.max(length - string.length, 0);
    return "".concat(string).concat(" ".repeat(padLength));
}
function $3857e0fef6b33c0d$export$7c4d25c0c3217d8c(v) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const EPSILON = 1e-16;
    const { isInteger: isInteger = false  } = opts;
    if (Array.isArray(v) || ArrayBuffer.isView(v)) return $3857e0fef6b33c0d$var$formatArrayValue(v, opts);
    if (!Number.isFinite(v)) return String(v);
    if (Math.abs(v) < EPSILON) return isInteger ? "0" : "0.";
    if (isInteger) return v.toFixed(0);
    if (Math.abs(v) > 100 && Math.abs(v) < 10000) return v.toFixed(0);
    const string = v.toPrecision(2);
    const decimal = string.indexOf(".0");
    return decimal === string.length - 2 ? string.slice(0, -1) : string;
}
function $3857e0fef6b33c0d$var$formatArrayValue(v, opts) {
    const { maxElts: maxElts = 16 , size: size = 1  } = opts;
    let string = "[";
    for(let i = 0; i < v.length && i < maxElts; ++i){
        if (i > 0) string += ",".concat(i % size === 0 ? " " : "");
        string += $3857e0fef6b33c0d$export$7c4d25c0c3217d8c(v[i], opts);
    }
    const terminator = v.length > maxElts ? "..." : "]";
    return "".concat(string).concat(terminator);
}
function $3857e0fef6b33c0d$export$9171d83acafa047c(image, message, scale) {
    let maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 600;
    const imageUrl = image.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
    if (image.width > maxWidth) scale = Math.min(scale, maxWidth / image.width);
    const width = image.width * scale;
    const height = image.height * scale;
    const style = [
        "font-size:1px;",
        "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"),
        "line-height:".concat(height, "px;"),
        "background:url(".concat(imageUrl, ");"),
        "background-size:".concat(width, "px ").concat(height, "px;"),
        "color:transparent;"
    ].join("");
    return [
        "".concat(message, " %c+"),
        style
    ];
}



let $d107ad8121232cc1$export$9b982809044276a6;
(function(COLOR1) {
    COLOR1[COLOR1["BLACK"] = 30] = "BLACK";
    COLOR1[COLOR1["RED"] = 31] = "RED";
    COLOR1[COLOR1["GREEN"] = 32] = "GREEN";
    COLOR1[COLOR1["YELLOW"] = 33] = "YELLOW";
    COLOR1[COLOR1["BLUE"] = 34] = "BLUE";
    COLOR1[COLOR1["MAGENTA"] = 35] = "MAGENTA";
    COLOR1[COLOR1["CYAN"] = 36] = "CYAN";
    COLOR1[COLOR1["WHITE"] = 37] = "WHITE";
    COLOR1[COLOR1["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR1[COLOR1["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR1[COLOR1["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR1[COLOR1["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR1[COLOR1["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR1[COLOR1["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR1[COLOR1["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR1[COLOR1["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})($d107ad8121232cc1$export$9b982809044276a6 || ($d107ad8121232cc1$export$9b982809044276a6 = {}));
function $d107ad8121232cc1$var$getColor(color) {
    return typeof color === "string" ? $d107ad8121232cc1$export$9b982809044276a6[color.toUpperCase()] || $d107ad8121232cc1$export$9b982809044276a6.WHITE : color;
}
function $d107ad8121232cc1$export$4c4d9288a45f1fb3(string, color, background) {
    if (!(0, $58cc8c917413a7dc$export$2e2bcd8739ae039) && typeof string === "string") {
        if (color) {
            color = $d107ad8121232cc1$var$getColor(color);
            string = "\x1b[".concat(color, "m").concat(string, "\x1b[39m");
        }
        if (background) {
            color = $d107ad8121232cc1$var$getColor(background);
            string = "\x1b[".concat(background + 10, "m").concat(string, "\x1b[49m");
        }
    }
    return string;
}


function $3d686a00c9f13fdf$export$f648f36420f83db(obj) {
    let predefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [
        "constructor"
    ];
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    for (const key of propNames){
        if (typeof obj[key] === "function") {
            if (!predefined.find((name)=>key === name)) obj[key] = obj[key].bind(obj);
        }
    }
}


function $c06a07b3f6443903$export$2e2bcd8739ae039(condition, message) {
    if (!condition) throw new Error(message || "Assertion failed");
}



function $9c44cc46ef7deaf1$export$19cd34ab73b4c7a7() {
    let timestamp;
    if ((0, $58cc8c917413a7dc$export$2e2bcd8739ae039) && "performance" in (0, $72a0e31c3f6d6aed$export$8291e5b88f90ce4)) {
        var _window$performance, _window$performance$n;
        timestamp = (0, $72a0e31c3f6d6aed$export$8291e5b88f90ce4) === null || (0, $72a0e31c3f6d6aed$export$8291e5b88f90ce4) === void 0 ? void 0 : (_window$performance = (0, $72a0e31c3f6d6aed$export$8291e5b88f90ce4).performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
    } else if ("hrtime" in (0, $72a0e31c3f6d6aed$export$e54fe5b0f43758f7)) {
        var _process$hrtime;
        const timeParts = (0, $72a0e31c3f6d6aed$export$e54fe5b0f43758f7) === null || (0, $72a0e31c3f6d6aed$export$e54fe5b0f43758f7) === void 0 ? void 0 : (_process$hrtime = (0, $72a0e31c3f6d6aed$export$e54fe5b0f43758f7).hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call((0, $72a0e31c3f6d6aed$export$e54fe5b0f43758f7));
        timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
    } else timestamp = Date.now();
    return timestamp;
}


const $88fdfccabe5e323d$var$originalConsole = {
    debug: (0, $58cc8c917413a7dc$export$2e2bcd8739ae039) ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
};
const $88fdfccabe5e323d$var$DEFAULT_SETTINGS = {
    enabled: true,
    level: 0
};
function $88fdfccabe5e323d$var$noop() {}
const $88fdfccabe5e323d$var$cache = {};
const $88fdfccabe5e323d$var$ONCE = {
    once: true
};
class $88fdfccabe5e323d$export$2e2bcd8739ae039 {
    constructor(){
        let { id: id  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            id: ""
        };
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "VERSION", (0, $3b0c2dd0bdd7037d$export$a4ad2735b021c132));
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_startTs", (0, $9c44cc46ef7deaf1$export$19cd34ab73b4c7a7)());
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_deltaTs", (0, $9c44cc46ef7deaf1$export$19cd34ab73b4c7a7)());
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_storage", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "userData", {});
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "LOG_THROTTLE_TIMEOUT", 0);
        this.id = id;
        this._storage = new (0, $c1f669f220866fe9$export$2e2bcd8739ae039)("__probe-".concat(this.id, "__"), $88fdfccabe5e323d$var$DEFAULT_SETTINGS);
        this.userData = {};
        this.timeStamp("".concat(this.id, " started"));
        (0, $3d686a00c9f13fdf$export$f648f36420f83db)(this);
        Object.seal(this);
    }
    set level(newLevel) {
        this.setLevel(newLevel);
    }
    get level() {
        return this.getLevel();
    }
    isEnabled() {
        return this._storage.config.enabled;
    }
    getLevel() {
        return this._storage.config.level;
    }
    getTotal() {
        return Number(((0, $9c44cc46ef7deaf1$export$19cd34ab73b4c7a7)() - this._startTs).toPrecision(10));
    }
    getDelta() {
        return Number(((0, $9c44cc46ef7deaf1$export$19cd34ab73b4c7a7)() - this._deltaTs).toPrecision(10));
    }
    set priority(newPriority) {
        this.level = newPriority;
    }
    get priority() {
        return this.level;
    }
    getPriority() {
        return this.level;
    }
    enable() {
        let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this._storage.updateConfiguration({
            enabled: enabled
        });
        return this;
    }
    setLevel(level) {
        this._storage.updateConfiguration({
            level: level
        });
        return this;
    }
    get(setting) {
        return this._storage.config[setting];
    }
    set(setting, value) {
        this._storage.updateConfiguration({
            [setting]: value
        });
    }
    settings() {
        if (console.table) console.table(this._storage.config);
        else console.log(this._storage.config);
    }
    assert(condition, message) {
        (0, $c06a07b3f6443903$export$2e2bcd8739ae039)(condition, message);
    }
    warn(message) {
        return this._getLogFunction(0, message, $88fdfccabe5e323d$var$originalConsole.warn, arguments, $88fdfccabe5e323d$var$ONCE);
    }
    error(message) {
        return this._getLogFunction(0, message, $88fdfccabe5e323d$var$originalConsole.error, arguments);
    }
    deprecated(oldUsage, newUsage) {
        return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
    }
    removed(oldUsage, newUsage) {
        return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
    }
    probe(logLevel, message) {
        return this._getLogFunction(logLevel, message, $88fdfccabe5e323d$var$originalConsole.log, arguments, {
            time: true,
            once: true
        });
    }
    log(logLevel, message) {
        return this._getLogFunction(logLevel, message, $88fdfccabe5e323d$var$originalConsole.debug, arguments);
    }
    info(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.info, arguments);
    }
    once(logLevel, message) {
        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)args[_key - 2] = arguments[_key];
        return this._getLogFunction(logLevel, message, $88fdfccabe5e323d$var$originalConsole.debug || $88fdfccabe5e323d$var$originalConsole.info, arguments, $88fdfccabe5e323d$var$ONCE);
    }
    table(logLevel, table, columns) {
        if (table) return this._getLogFunction(logLevel, table, console.table || $88fdfccabe5e323d$var$noop, columns && [
            columns
        ], {
            tag: $88fdfccabe5e323d$var$getTableHeader(table)
        });
        return $88fdfccabe5e323d$var$noop;
    }
    image(_ref) {
        let { logLevel: logLevel , priority: priority , image: image , message: message = "" , scale: scale = 1  } = _ref;
        if (!this._shouldLog(logLevel || priority)) return $88fdfccabe5e323d$var$noop;
        return (0, $58cc8c917413a7dc$export$2e2bcd8739ae039) ? $88fdfccabe5e323d$var$logImageInBrowser({
            image: image,
            message: message,
            scale: scale
        }) : $88fdfccabe5e323d$var$logImageInNode({
            image: image,
            message: message,
            scale: scale
        });
    }
    time(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.timeStamp || $88fdfccabe5e323d$var$noop);
    }
    group(logLevel, message) {
        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
            collapsed: false
        };
        const options = $88fdfccabe5e323d$export$abc60e668512edf9({
            logLevel: logLevel,
            message: message,
            opts: opts
        });
        const { collapsed: collapsed  } = opts;
        options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
        return this._getLogFunction(options);
    }
    groupCollapsed(logLevel, message) {
        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return this.group(logLevel, message, Object.assign({}, opts, {
            collapsed: true
        }));
    }
    groupEnd(logLevel) {
        return this._getLogFunction(logLevel, "", console.groupEnd || $88fdfccabe5e323d$var$noop);
    }
    withGroup(logLevel, message, func) {
        this.group(logLevel, message)();
        try {
            func();
        } finally{
            this.groupEnd(logLevel)();
        }
    }
    trace() {
        if (console.trace) console.trace();
    }
    _shouldLog(logLevel) {
        return this.isEnabled() && this.getLevel() >= $88fdfccabe5e323d$var$normalizeLogLevel(logLevel);
    }
    _getLogFunction(logLevel, message, method, args, opts) {
        if (this._shouldLog(logLevel)) {
            opts = $88fdfccabe5e323d$export$abc60e668512edf9({
                logLevel: logLevel,
                message: message,
                args: args,
                opts: opts
            });
            method = method || opts.method;
            (0, $c06a07b3f6443903$export$2e2bcd8739ae039)(method);
            opts.total = this.getTotal();
            opts.delta = this.getDelta();
            this._deltaTs = (0, $9c44cc46ef7deaf1$export$19cd34ab73b4c7a7)();
            const tag = opts.tag || opts.message;
            if (opts.once) {
                if (!$88fdfccabe5e323d$var$cache[tag]) $88fdfccabe5e323d$var$cache[tag] = (0, $9c44cc46ef7deaf1$export$19cd34ab73b4c7a7)();
                else return $88fdfccabe5e323d$var$noop;
            }
            message = $88fdfccabe5e323d$var$decorateMessage(this.id, opts.message, opts);
            return method.bind(console, message, ...opts.args);
        }
        return $88fdfccabe5e323d$var$noop;
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($88fdfccabe5e323d$export$2e2bcd8739ae039, "VERSION", (0, $3b0c2dd0bdd7037d$export$a4ad2735b021c132));
function $88fdfccabe5e323d$var$normalizeLogLevel(logLevel) {
    if (!logLevel) return 0;
    let resolvedLevel;
    switch(typeof logLevel){
        case "number":
            resolvedLevel = logLevel;
            break;
        case "object":
            resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
            break;
        default:
            return 0;
    }
    (0, $c06a07b3f6443903$export$2e2bcd8739ae039)(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
}
function $88fdfccabe5e323d$export$abc60e668512edf9(opts) {
    const { logLevel: logLevel , message: message  } = opts;
    opts.logLevel = $88fdfccabe5e323d$var$normalizeLogLevel(logLevel);
    const args = opts.args ? Array.from(opts.args) : [];
    while(args.length && args.shift() !== message);
    switch(typeof logLevel){
        case "string":
        case "function":
            if (message !== undefined) args.unshift(message);
            opts.message = logLevel;
            break;
        case "object":
            Object.assign(opts, logLevel);
            break;
        default:
    }
    if (typeof opts.message === "function") opts.message = opts.message();
    const messageType = typeof opts.message;
    (0, $c06a07b3f6443903$export$2e2bcd8739ae039)(messageType === "string" || messageType === "object");
    return Object.assign(opts, {
        args: args
    }, opts.opts);
}
function $88fdfccabe5e323d$var$decorateMessage(id, message, opts) {
    if (typeof message === "string") {
        const time = opts.time ? (0, $3857e0fef6b33c0d$export$cbb503201166aab7)((0, $3857e0fef6b33c0d$export$3203edd9e5edd663)(opts.total)) : "";
        message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
        message = (0, $d107ad8121232cc1$export$4c4d9288a45f1fb3)(message, opts.color, opts.background);
    }
    return message;
}

function $88fdfccabe5e323d$var$logImageInNode(_ref2) {
    let { image: image , message: message = "" , scale: scale = 1  } = _ref2;
    let asciify = null;
    try {
        asciify = (parcelRequire("9aLFZ"));
    } catch (error) {}
    if (asciify) return ()=>asciify(image, {
            fit: "box",
            width: "".concat(Math.round(80 * scale), "%")
        }).then((data)=>console.log(data));
    return $88fdfccabe5e323d$var$noop;
}
function $88fdfccabe5e323d$var$logImageInBrowser(_ref3) {
    let { image: image , message: message = "" , scale: scale = 1  } = _ref3;
    if (typeof image === "string") {
        const img = new Image();
        img.onload = ()=>{
            const args = (0, $3857e0fef6b33c0d$export$9171d83acafa047c)(img, message, scale);
            console.log(...args);
        };
        img.src = image;
        return $88fdfccabe5e323d$var$noop;
    }
    const element = image.nodeName || "";
    if (element.toLowerCase() === "img") {
        console.log(...(0, $3857e0fef6b33c0d$export$9171d83acafa047c)(image, message, scale));
        return $88fdfccabe5e323d$var$noop;
    }
    if (element.toLowerCase() === "canvas") {
        const img = new Image();
        img.onload = ()=>console.log(...(0, $3857e0fef6b33c0d$export$9171d83acafa047c)(img, message, scale));
        img.src = image.toDataURL();
        return $88fdfccabe5e323d$var$noop;
    }
    return $88fdfccabe5e323d$var$noop;
}
function $88fdfccabe5e323d$var$getTableHeader(table) {
    for(const key in table){
        for(const title in table[key])return title || "untitled";
    }
    return "empty";
}










var $3c64196f3b0487f1$export$2e2bcd8739ae039 = new (0, $88fdfccabe5e323d$export$2e2bcd8739ae039)({
    id: "@probe.gl/log"
});


const $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3 = new (0, $88fdfccabe5e323d$export$2e2bcd8739ae039)({
    id: "luma.gl"
});


function $611f47f49512a05f$export$a7a9523472993e97(condition, message) {
    if (!condition) throw new Error(message || "luma.gl: assertion failed.");
}


const $325e733792a03f4e$var$ERR_CONTEXT = "Invalid WebGLRenderingContext";
const $325e733792a03f4e$export$48f7473fb8287ec0 = $325e733792a03f4e$var$ERR_CONTEXT;
const $325e733792a03f4e$export$f882315798580146 = "Requires WebGL2";
function $325e733792a03f4e$export$3a471d0dd6792be6(gl) {
    if (typeof WebGLRenderingContext !== "undefined" && gl instanceof WebGLRenderingContext) return true;
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) return true;
    return Boolean(gl && Number.isFinite(gl._version));
}
function $325e733792a03f4e$export$e3518b1ac7891039(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) return true;
    return Boolean(gl && gl._version === 2);
}
function $325e733792a03f4e$export$89dcfcb9130f2c28(gl) {
    return $325e733792a03f4e$export$e3518b1ac7891039(gl) ? gl : null;
}
function $325e733792a03f4e$export$9b0605fd3c935712(gl) {
    (0, $611f47f49512a05f$export$a7a9523472993e97)($325e733792a03f4e$export$3a471d0dd6792be6(gl), $325e733792a03f4e$var$ERR_CONTEXT);
    return gl;
}
function $325e733792a03f4e$export$22897d77b4bb5316(gl) {
    (0, $611f47f49512a05f$export$a7a9523472993e97)($325e733792a03f4e$export$e3518b1ac7891039(gl), $325e733792a03f4e$export$f882315798580146);
    return gl;
}


const $44909f389943f36e$var$glErrorShadow = {};
function $44909f389943f36e$var$error(msg) {
    if (globalThis.console && globalThis.console.error) globalThis.console.error(msg);
}
function $44909f389943f36e$var$log(msg) {
    if (globalThis.console && globalThis.console.log) globalThis.console.log(msg);
}
function $44909f389943f36e$var$synthesizeGLError(err, opt_msg) {
    $44909f389943f36e$var$glErrorShadow[err] = true;
    if (opt_msg !== undefined) $44909f389943f36e$var$error(opt_msg);
}
function $44909f389943f36e$var$wrapGLError(gl) {
    const f = gl.getError;
    gl.getError = function getError() {
        let err;
        do {
            err = f.apply(gl);
            if (err !== 0) $44909f389943f36e$var$glErrorShadow[err] = true;
        }while (err !== 0);
        for(err in $44909f389943f36e$var$glErrorShadow)if ($44909f389943f36e$var$glErrorShadow[err]) {
            delete $44909f389943f36e$var$glErrorShadow[err];
            return parseInt(err, 10);
        }
        return 0;
    };
}
const $44909f389943f36e$var$WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES1(ext) {
    const gl = ext.gl;
    this.ext = ext;
    this.isAlive = true;
    this.hasBeenBound = false;
    this.elementArrayBuffer = null;
    this.attribs = new Array(ext.maxVertexAttribs);
    for(let n = 0; n < this.attribs.length; n++){
        const attrib = new WebGLVertexArrayObjectOES1.VertexAttrib(gl);
        this.attribs[n] = attrib;
    }
    this.maxAttrib = 0;
};
$44909f389943f36e$var$WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
    this.enabled = false;
    this.buffer = null;
    this.size = 4;
    this.type = 5126;
    this.normalized = false;
    this.stride = 16;
    this.offset = 0;
    this.cached = "";
    this.recache();
};
$44909f389943f36e$var$WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
    this.cached = [
        this.size,
        this.type,
        this.normalized,
        this.stride,
        this.offset
    ].join(":");
};
const $44909f389943f36e$var$OESVertexArrayObject = function OESVertexArrayObject(gl) {
    const self = this;
    this.gl = gl;
    $44909f389943f36e$var$wrapGLError(gl);
    const original = this.original = {
        getParameter: gl.getParameter,
        enableVertexAttribArray: gl.enableVertexAttribArray,
        disableVertexAttribArray: gl.disableVertexAttribArray,
        bindBuffer: gl.bindBuffer,
        getVertexAttrib: gl.getVertexAttrib,
        vertexAttribPointer: gl.vertexAttribPointer
    };
    gl.getParameter = function getParameter(pname) {
        if (pname === self.VERTEX_ARRAY_BINDING_OES) {
            if (self.currentVertexArrayObject === self.defaultVertexArrayObject) return null;
            return self.currentVertexArrayObject;
        }
        return original.getParameter.apply(this, arguments);
    };
    gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
        const vao = self.currentVertexArrayObject;
        vao.maxAttrib = Math.max(vao.maxAttrib, index);
        const attrib = vao.attribs[index];
        attrib.enabled = true;
        return original.enableVertexAttribArray.apply(this, arguments);
    };
    gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
        const vao = self.currentVertexArrayObject;
        vao.maxAttrib = Math.max(vao.maxAttrib, index);
        const attrib = vao.attribs[index];
        attrib.enabled = false;
        return original.disableVertexAttribArray.apply(this, arguments);
    };
    gl.bindBuffer = function bindBuffer(target, buffer) {
        switch(target){
            case 34962:
                self.currentArrayBuffer = buffer;
                break;
            case 34963:
                self.currentVertexArrayObject.elementArrayBuffer = buffer;
                break;
            default:
        }
        return original.bindBuffer.apply(this, arguments);
    };
    gl.getVertexAttrib = function getVertexAttrib(index, pname) {
        const vao = self.currentVertexArrayObject;
        const attrib = vao.attribs[index];
        switch(pname){
            case 34975:
                return attrib.buffer;
            case 34338:
                return attrib.enabled;
            case 34339:
                return attrib.size;
            case 34340:
                return attrib.stride;
            case 34341:
                return attrib.type;
            case 34922:
                return attrib.normalized;
            default:
                return original.getVertexAttrib.apply(this, arguments);
        }
    };
    gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
        const vao = self.currentVertexArrayObject;
        vao.maxAttrib = Math.max(vao.maxAttrib, indx);
        const attrib = vao.attribs[indx];
        attrib.buffer = self.currentArrayBuffer;
        attrib.size = size;
        attrib.type = type;
        attrib.normalized = normalized;
        attrib.stride = stride;
        attrib.offset = offset;
        attrib.recache();
        return original.vertexAttribPointer.apply(this, arguments);
    };
    if (gl.instrumentExtension) gl.instrumentExtension(this, "OES_vertex_array_object");
    if (gl.canvas) gl.canvas.addEventListener("webglcontextrestored", ()=>{
        $44909f389943f36e$var$log("OESVertexArrayObject emulation library context restored");
        self.reset_();
    }, true);
    this.reset_();
};
$44909f389943f36e$var$OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 0x85b5;
$44909f389943f36e$var$OESVertexArrayObject.prototype.reset_ = function reset_() {
    const contextWasLost = this.vertexArrayObjects !== undefined;
    if (contextWasLost) for(let ii = 0; ii < this.vertexArrayObjects.length; ++ii)this.vertexArrayObjects.isAlive = false;
    const gl = this.gl;
    this.maxVertexAttribs = gl.getParameter(34921);
    this.defaultVertexArrayObject = new $44909f389943f36e$var$WebGLVertexArrayObjectOES(this);
    this.currentVertexArrayObject = null;
    this.currentArrayBuffer = null;
    this.vertexArrayObjects = [
        this.defaultVertexArrayObject
    ];
    this.bindVertexArrayOES(null);
};
$44909f389943f36e$var$OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
    const arrayObject = new $44909f389943f36e$var$WebGLVertexArrayObjectOES(this);
    this.vertexArrayObjects.push(arrayObject);
    return arrayObject;
};
$44909f389943f36e$var$OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
    arrayObject.isAlive = false;
    this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
    if (this.currentVertexArrayObject === arrayObject) this.bindVertexArrayOES(null);
};
$44909f389943f36e$var$OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
    if (arrayObject && arrayObject instanceof $44909f389943f36e$var$WebGLVertexArrayObjectOES) {
        if (arrayObject.hasBeenBound && arrayObject.ext === this) return true;
    }
    return false;
};
$44909f389943f36e$var$OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
    const gl = this.gl;
    if (arrayObject && !arrayObject.isAlive) {
        $44909f389943f36e$var$synthesizeGLError(1282, "bindVertexArrayOES: attempt to bind deleted arrayObject");
        return;
    }
    const original = this.original;
    const oldVAO = this.currentVertexArrayObject;
    this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
    this.currentVertexArrayObject.hasBeenBound = true;
    const newVAO = this.currentVertexArrayObject;
    if (oldVAO === newVAO) return;
    if (!oldVAO || newVAO.elementArrayBuffer !== oldVAO.elementArrayBuffer) original.bindBuffer.call(gl, 34963, newVAO.elementArrayBuffer);
    let currentBinding = this.currentArrayBuffer;
    const maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
    for(let n = 0; n <= maxAttrib; n++){
        const attrib = newVAO.attribs[n];
        const oldAttrib = oldVAO ? oldVAO.attribs[n] : null;
        if (!oldVAO || attrib.enabled !== oldAttrib.enabled) {
            if (attrib.enabled) original.enableVertexAttribArray.call(gl, n);
            else original.disableVertexAttribArray.call(gl, n);
        }
        if (attrib.enabled) {
            let bufferChanged = false;
            if (!oldVAO || attrib.buffer !== oldAttrib.buffer) {
                if (currentBinding !== attrib.buffer) {
                    original.bindBuffer.call(gl, 34962, attrib.buffer);
                    currentBinding = attrib.buffer;
                }
                bufferChanged = true;
            }
            if (bufferChanged || attrib.cached !== oldAttrib.cached) original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
        }
    }
    if (this.currentArrayBuffer !== currentBinding) original.bindBuffer.call(gl, 34962, this.currentArrayBuffer);
};
function $44909f389943f36e$export$a14b3889aebee3e2(gl) {
    if (typeof gl.createVertexArray === "function") return;
    const original_getSupportedExtensions = gl.getSupportedExtensions;
    gl.getSupportedExtensions = function getSupportedExtensions() {
        const list = original_getSupportedExtensions.call(this) || [];
        if (list.indexOf("OES_vertex_array_object") < 0) list.push("OES_vertex_array_object");
        return list;
    };
    const original_getExtension = gl.getExtension;
    gl.getExtension = function getExtension(name) {
        const ext = original_getExtension.call(this, name);
        if (ext) return ext;
        if (name !== "OES_vertex_array_object") return null;
        if (!gl.__OESVertexArrayObject) this.__OESVertexArrayObject = new $44909f389943f36e$var$OESVertexArrayObject(this);
        return this.__OESVertexArrayObject;
    };
}






const $621a69577d3810ee$var$OES_element_index = "OES_element_index";
const $621a69577d3810ee$var$WEBGL_draw_buffers = "WEBGL_draw_buffers";
const $621a69577d3810ee$var$EXT_disjoint_timer_query = "EXT_disjoint_timer_query";
const $621a69577d3810ee$var$EXT_disjoint_timer_query_webgl2 = "EXT_disjoint_timer_query_webgl2";
const $621a69577d3810ee$var$EXT_texture_filter_anisotropic = "EXT_texture_filter_anisotropic";
const $621a69577d3810ee$var$WEBGL_debug_renderer_info = "WEBGL_debug_renderer_info";
const $621a69577d3810ee$var$GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8b8b;
const $621a69577d3810ee$var$GL_DONT_CARE = 0x1100;
const $621a69577d3810ee$var$GL_GPU_DISJOINT_EXT = 0x8fbb;
const $621a69577d3810ee$var$GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84ff;
const $621a69577d3810ee$var$GL_UNMASKED_VENDOR_WEBGL = 0x9245;
const $621a69577d3810ee$var$GL_UNMASKED_RENDERER_WEBGL = 0x9246;
const $621a69577d3810ee$var$getWebGL2ValueOrZero = (gl)=>!(0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? 0 : undefined;
const $621a69577d3810ee$var$WEBGL_PARAMETERS = {
    [3074]: (gl)=>!(0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? 36064 : undefined,
    [$621a69577d3810ee$var$GL_FRAGMENT_SHADER_DERIVATIVE_HINT]: (gl)=>!(0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? $621a69577d3810ee$var$GL_DONT_CARE : undefined,
    [35977]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [32937]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [$621a69577d3810ee$var$GL_GPU_DISJOINT_EXT]: (gl, getParameter)=>{
        const ext = (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? gl.getExtension($621a69577d3810ee$var$EXT_disjoint_timer_query_webgl2) : gl.getExtension($621a69577d3810ee$var$EXT_disjoint_timer_query);
        return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
    },
    [$621a69577d3810ee$var$GL_UNMASKED_VENDOR_WEBGL]: (gl, getParameter)=>{
        const ext = gl.getExtension($621a69577d3810ee$var$WEBGL_debug_renderer_info);
        return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || 7936);
    },
    [$621a69577d3810ee$var$GL_UNMASKED_RENDERER_WEBGL]: (gl, getParameter)=>{
        const ext = gl.getExtension($621a69577d3810ee$var$WEBGL_debug_renderer_info);
        return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || 7937);
    },
    [$621a69577d3810ee$var$GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT]: (gl, getParameter)=>{
        const ext = gl.luma.extensions[$621a69577d3810ee$var$EXT_texture_filter_anisotropic];
        return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1.0;
    },
    [32883]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35071]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [37447]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [36063]: (gl, getParameter)=>{
        if (!(0, $325e733792a03f4e$export$e3518b1ac7891039)(gl)) {
            const ext = gl.getExtension($621a69577d3810ee$var$WEBGL_draw_buffers);
            return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
        }
        return undefined;
    },
    [35379]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35374]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35377]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [34852]: (gl)=>{
        if (!(0, $325e733792a03f4e$export$e3518b1ac7891039)(gl)) {
            const ext = gl.getExtension($621a69577d3810ee$var$WEBGL_draw_buffers);
            return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
        }
        return undefined;
    },
    [36203]: (gl)=>gl.getExtension($621a69577d3810ee$var$OES_element_index) ? 2147483647 : 65535,
    [33001]: (gl)=>gl.getExtension($621a69577d3810ee$var$OES_element_index) ? 16777216 : 65535,
    [33000]: (gl)=>16777216,
    [37157]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35373]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35657]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [36183]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [37137]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [34045]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35978]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35979]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35968]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35376]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35375]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35659]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [37154]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35371]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35658]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35076]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35077]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35380]: $621a69577d3810ee$var$getWebGL2ValueOrZero
};
function $621a69577d3810ee$export$76e91f2080178ba1(gl, originalGetParameter, pname) {
    const limit = $621a69577d3810ee$var$WEBGL_PARAMETERS[pname];
    const value = typeof limit === "function" ? limit(gl, originalGetParameter, pname) : limit;
    const result = value !== undefined ? value : originalGetParameter(pname);
    return result;
}


const $71b2d93ff8e47bee$var$OES_vertex_array_object = "OES_vertex_array_object";
const $71b2d93ff8e47bee$var$ANGLE_instanced_arrays = "ANGLE_instanced_arrays";
const $71b2d93ff8e47bee$var$WEBGL_draw_buffers = "WEBGL_draw_buffers";
const $71b2d93ff8e47bee$var$EXT_disjoint_timer_query = "EXT_disjoint_timer_query";
const $71b2d93ff8e47bee$var$EXT_texture_filter_anisotropic = "EXT_texture_filter_anisotropic";
const $71b2d93ff8e47bee$var$ERR_VAO_NOT_SUPPORTED = "VertexArray requires WebGL2 or OES_vertex_array_object extension";
function $71b2d93ff8e47bee$var$getExtensionData(gl, extension) {
    return {
        webgl2: (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl),
        ext: gl.getExtension(extension)
    };
}
const $71b2d93ff8e47bee$export$55b4f9cc9ea3ebcb = {
    [$71b2d93ff8e47bee$var$OES_vertex_array_object]: {
        meta: {
            suffix: "OES"
        },
        createVertexArray: ()=>{
            (0, $611f47f49512a05f$export$a7a9523472993e97)(false, $71b2d93ff8e47bee$var$ERR_VAO_NOT_SUPPORTED);
        },
        deleteVertexArray: ()=>{},
        bindVertexArray: ()=>{},
        isVertexArray: ()=>false
    },
    [$71b2d93ff8e47bee$var$ANGLE_instanced_arrays]: {
        meta: {
            suffix: "ANGLE"
        },
        vertexAttribDivisor (location, divisor) {
            (0, $611f47f49512a05f$export$a7a9523472993e97)(divisor === 0, "WebGL instanced rendering not supported");
        },
        drawElementsInstanced: ()=>{},
        drawArraysInstanced: ()=>{}
    },
    [$71b2d93ff8e47bee$var$WEBGL_draw_buffers]: {
        meta: {
            suffix: "WEBGL"
        },
        drawBuffers: ()=>{
            (0, $611f47f49512a05f$export$a7a9523472993e97)(false);
        }
    },
    [$71b2d93ff8e47bee$var$EXT_disjoint_timer_query]: {
        meta: {
            suffix: "EXT"
        },
        createQuery: ()=>{
            (0, $611f47f49512a05f$export$a7a9523472993e97)(false);
        },
        deleteQuery: ()=>{
            (0, $611f47f49512a05f$export$a7a9523472993e97)(false);
        },
        beginQuery: ()=>{
            (0, $611f47f49512a05f$export$a7a9523472993e97)(false);
        },
        endQuery: ()=>{},
        getQuery (handle, pname) {
            return this.getQueryObject(handle, pname);
        },
        getQueryParameter (handle, pname) {
            return this.getQueryObject(handle, pname);
        },
        getQueryObject: ()=>{}
    }
};
const $71b2d93ff8e47bee$export$16cadaab146130da = {
    readBuffer: (gl, originalFunc, attachment)=>{
        if ((0, $325e733792a03f4e$export$e3518b1ac7891039)(gl)) originalFunc(attachment);
    },
    getVertexAttrib: (gl, originalFunc, location, pname)=>{
        const { webgl2: webgl2 , ext: ext  } = $71b2d93ff8e47bee$var$getExtensionData(gl, $71b2d93ff8e47bee$var$ANGLE_instanced_arrays);
        let result;
        switch(pname){
            case 35069:
                result = !webgl2 ? false : undefined;
                break;
            case 35070:
                result = !webgl2 && !ext ? 0 : undefined;
                break;
            default:
        }
        return result !== undefined ? result : originalFunc(location, pname);
    },
    getProgramParameter: (gl, originalFunc, program, pname)=>{
        if (!(0, $325e733792a03f4e$export$e3518b1ac7891039)(gl)) switch(pname){
            case 35967:
                return 35981;
            case 35971:
                return 0;
            case 35382:
                return 0;
            default:
        }
        return originalFunc(program, pname);
    },
    getInternalformatParameter: (gl, originalFunc, target, format, pname)=>{
        if (!(0, $325e733792a03f4e$export$e3518b1ac7891039)(gl)) switch(pname){
            case 32937:
                return new Int32Array([
                    0
                ]);
            default:
        }
        return gl.getInternalformatParameter(target, format, pname);
    },
    getTexParameter (gl, originalFunc, target, pname) {
        switch(pname){
            case 34046:
                const { extensions: extensions  } = gl.luma;
                const ext = extensions[$71b2d93ff8e47bee$var$EXT_texture_filter_anisotropic];
                pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
                break;
            default:
        }
        return originalFunc(target, pname);
    },
    getParameter: (0, $621a69577d3810ee$export$76e91f2080178ba1),
    hint (gl, originalFunc, pname, value) {
        return originalFunc(pname, value);
    }
};


function $1f185b328a16f979$export$2546a51f55104d54(gl) {
    gl.luma = gl.luma || {};
    const { luma: luma  } = gl;
    if (!luma.polyfilled) {
        (0, $44909f389943f36e$export$a14b3889aebee3e2)(gl);
        $1f185b328a16f979$var$initializeExtensions(gl);
        $1f185b328a16f979$var$installPolyfills(gl, (0, $71b2d93ff8e47bee$export$55b4f9cc9ea3ebcb));
        $1f185b328a16f979$var$installOverrides(gl, {
            target: luma,
            target2: gl
        });
        luma.polyfilled = true;
    }
    return gl;
}
globalThis.polyfillContext = $1f185b328a16f979$export$2546a51f55104d54;
function $1f185b328a16f979$var$initializeExtensions(gl) {
    gl.luma.extensions = {};
    const EXTENSIONS = gl.getSupportedExtensions() || [];
    for (const extension of EXTENSIONS)gl.luma[extension] = gl.getExtension(extension);
}
function $1f185b328a16f979$var$installOverrides(gl, _ref) {
    let { target: target , target2: target2  } = _ref;
    Object.keys((0, $71b2d93ff8e47bee$export$16cadaab146130da)).forEach((key)=>{
        if (typeof (0, $71b2d93ff8e47bee$export$16cadaab146130da)[key] === "function") {
            const originalFunc = gl[key] ? gl[key].bind(gl) : ()=>{};
            const polyfill = (0, $71b2d93ff8e47bee$export$16cadaab146130da)[key].bind(null, gl, originalFunc);
            target[key] = polyfill;
            target2[key] = polyfill;
        }
    });
}
function $1f185b328a16f979$var$installPolyfills(gl, polyfills) {
    for (const extension of Object.getOwnPropertyNames(polyfills))if (extension !== "overrides") $1f185b328a16f979$var$polyfillExtension(gl, {
        extension: extension,
        target: gl.luma,
        target2: gl
    });
}
function $1f185b328a16f979$var$polyfillExtension(gl, _ref2) {
    let { extension: extension , target: target , target2: target2  } = _ref2;
    const defaults = (0, $71b2d93ff8e47bee$export$55b4f9cc9ea3ebcb)[extension];
    (0, $611f47f49512a05f$export$a7a9523472993e97)(defaults);
    const { meta: meta = {}  } = defaults;
    const { suffix: suffix = ""  } = meta;
    const ext = gl.getExtension(extension);
    for (const key of Object.keys(defaults)){
        const extKey = "".concat(key).concat(suffix);
        let polyfill = null;
        if (key === "meta") ;
        else if (typeof gl[key] === "function") ;
        else if (ext && typeof ext[extKey] === "function") polyfill = function() {
            return ext[extKey](...arguments);
        };
        else if (typeof defaults[key] === "function") polyfill = defaults[key].bind(target);
        if (polyfill) {
            target[key] = polyfill;
            target2[key] = polyfill;
        }
    }
}



const $2cabdcb30df9ebb5$export$baa06478962d475e = {
    [3042]: false,
    [32773]: new Float32Array([
        0,
        0,
        0,
        0
    ]),
    [32777]: 32774,
    [34877]: 32774,
    [32969]: 1,
    [32968]: 0,
    [32971]: 1,
    [32970]: 0,
    [3106]: new Float32Array([
        0,
        0,
        0,
        0
    ]),
    [3107]: [
        true,
        true,
        true,
        true
    ],
    [2884]: false,
    [2885]: 1029,
    [2929]: false,
    [2931]: 1,
    [2932]: 513,
    [2928]: new Float32Array([
        0,
        1
    ]),
    [2930]: true,
    [3024]: true,
    [36006]: null,
    [2886]: 2305,
    [33170]: 4352,
    [2849]: 1,
    [32823]: false,
    [32824]: 0,
    [10752]: 0,
    [32938]: 1.0,
    [32939]: false,
    [3089]: false,
    [3088]: new Int32Array([
        0,
        0,
        1024,
        1024
    ]),
    [2960]: false,
    [2961]: 0,
    [2968]: 0xffffffff,
    [36005]: 0xffffffff,
    [2962]: 519,
    [2967]: 0,
    [2963]: 0xffffffff,
    [34816]: 519,
    [36003]: 0,
    [36004]: 0xffffffff,
    [2964]: 7680,
    [2965]: 7680,
    [2966]: 7680,
    [34817]: 7680,
    [34818]: 7680,
    [34819]: 7680,
    [2978]: [
        0,
        0,
        1024,
        1024
    ],
    [3333]: 4,
    [3317]: 4,
    [37440]: false,
    [37441]: false,
    [37443]: 37444,
    [35723]: 4352,
    [36010]: null,
    [35977]: false,
    [3330]: 0,
    [3332]: 0,
    [3331]: 0,
    [3314]: 0,
    [32878]: 0,
    [3316]: 0,
    [3315]: 0,
    [32877]: 0
};
const $2cabdcb30df9ebb5$var$enable = (gl, value, key)=>value ? gl.enable(key) : gl.disable(key);
const $2cabdcb30df9ebb5$var$hint = (gl, value, key)=>gl.hint(key, value);
const $2cabdcb30df9ebb5$var$pixelStorei = (gl, value, key)=>gl.pixelStorei(key, value);
const $2cabdcb30df9ebb5$var$drawFramebuffer = (gl, value)=>{
    const target = (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? 36009 : 36160;
    return gl.bindFramebuffer(target, value);
};
const $2cabdcb30df9ebb5$var$readFramebuffer = (gl, value)=>{
    return gl.bindFramebuffer(36008, value);
};
function $2cabdcb30df9ebb5$var$isArray(array) {
    return Array.isArray(array) || ArrayBuffer.isView(array);
}
const $2cabdcb30df9ebb5$export$f29b03183ed64cfb = {
    [3042]: $2cabdcb30df9ebb5$var$enable,
    [32773]: (gl, value)=>gl.blendColor(...value),
    [32777]: "blendEquation",
    [34877]: "blendEquation",
    [32969]: "blendFunc",
    [32968]: "blendFunc",
    [32971]: "blendFunc",
    [32970]: "blendFunc",
    [3106]: (gl, value)=>gl.clearColor(...value),
    [3107]: (gl, value)=>gl.colorMask(...value),
    [2884]: $2cabdcb30df9ebb5$var$enable,
    [2885]: (gl, value)=>gl.cullFace(value),
    [2929]: $2cabdcb30df9ebb5$var$enable,
    [2931]: (gl, value)=>gl.clearDepth(value),
    [2932]: (gl, value)=>gl.depthFunc(value),
    [2928]: (gl, value)=>gl.depthRange(...value),
    [2930]: (gl, value)=>gl.depthMask(value),
    [3024]: $2cabdcb30df9ebb5$var$enable,
    [35723]: $2cabdcb30df9ebb5$var$hint,
    [36006]: $2cabdcb30df9ebb5$var$drawFramebuffer,
    [2886]: (gl, value)=>gl.frontFace(value),
    [33170]: $2cabdcb30df9ebb5$var$hint,
    [2849]: (gl, value)=>gl.lineWidth(value),
    [32823]: $2cabdcb30df9ebb5$var$enable,
    [32824]: "polygonOffset",
    [10752]: "polygonOffset",
    [35977]: $2cabdcb30df9ebb5$var$enable,
    [32938]: "sampleCoverage",
    [32939]: "sampleCoverage",
    [3089]: $2cabdcb30df9ebb5$var$enable,
    [3088]: (gl, value)=>gl.scissor(...value),
    [2960]: $2cabdcb30df9ebb5$var$enable,
    [2961]: (gl, value)=>gl.clearStencil(value),
    [2968]: (gl, value)=>gl.stencilMaskSeparate(1028, value),
    [36005]: (gl, value)=>gl.stencilMaskSeparate(1029, value),
    [2962]: "stencilFuncFront",
    [2967]: "stencilFuncFront",
    [2963]: "stencilFuncFront",
    [34816]: "stencilFuncBack",
    [36003]: "stencilFuncBack",
    [36004]: "stencilFuncBack",
    [2964]: "stencilOpFront",
    [2965]: "stencilOpFront",
    [2966]: "stencilOpFront",
    [34817]: "stencilOpBack",
    [34818]: "stencilOpBack",
    [34819]: "stencilOpBack",
    [2978]: (gl, value)=>gl.viewport(...value),
    [3333]: $2cabdcb30df9ebb5$var$pixelStorei,
    [3317]: $2cabdcb30df9ebb5$var$pixelStorei,
    [37440]: $2cabdcb30df9ebb5$var$pixelStorei,
    [37441]: $2cabdcb30df9ebb5$var$pixelStorei,
    [37443]: $2cabdcb30df9ebb5$var$pixelStorei,
    [3330]: $2cabdcb30df9ebb5$var$pixelStorei,
    [3332]: $2cabdcb30df9ebb5$var$pixelStorei,
    [3331]: $2cabdcb30df9ebb5$var$pixelStorei,
    [36010]: $2cabdcb30df9ebb5$var$readFramebuffer,
    [3314]: $2cabdcb30df9ebb5$var$pixelStorei,
    [32878]: $2cabdcb30df9ebb5$var$pixelStorei,
    [3316]: $2cabdcb30df9ebb5$var$pixelStorei,
    [3315]: $2cabdcb30df9ebb5$var$pixelStorei,
    [32877]: $2cabdcb30df9ebb5$var$pixelStorei,
    framebuffer: (gl, framebuffer)=>{
        const handle = framebuffer && "handle" in framebuffer ? framebuffer.handle : framebuffer;
        return gl.bindFramebuffer(36160, handle);
    },
    blend: (gl, value)=>value ? gl.enable(3042) : gl.disable(3042),
    blendColor: (gl, value)=>gl.blendColor(...value),
    blendEquation: (gl, args)=>{
        args = $2cabdcb30df9ebb5$var$isArray(args) ? args : [
            args,
            args
        ];
        gl.blendEquationSeparate(...args);
    },
    blendFunc: (gl, args)=>{
        args = $2cabdcb30df9ebb5$var$isArray(args) && args.length === 2 ? [
            ...args,
            ...args
        ] : args;
        gl.blendFuncSeparate(...args);
    },
    clearColor: (gl, value)=>gl.clearColor(...value),
    clearDepth: (gl, value)=>gl.clearDepth(value),
    clearStencil: (gl, value)=>gl.clearStencil(value),
    colorMask: (gl, value)=>gl.colorMask(...value),
    cull: (gl, value)=>value ? gl.enable(2884) : gl.disable(2884),
    cullFace: (gl, value)=>gl.cullFace(value),
    depthTest: (gl, value)=>value ? gl.enable(2929) : gl.disable(2929),
    depthFunc: (gl, value)=>gl.depthFunc(value),
    depthMask: (gl, value)=>gl.depthMask(value),
    depthRange: (gl, value)=>gl.depthRange(...value),
    dither: (gl, value)=>value ? gl.enable(3024) : gl.disable(3024),
    derivativeHint: (gl, value)=>{
        gl.hint(35723, value);
    },
    frontFace: (gl, value)=>gl.frontFace(value),
    mipmapHint: (gl, value)=>gl.hint(33170, value),
    lineWidth: (gl, value)=>gl.lineWidth(value),
    polygonOffsetFill: (gl, value)=>value ? gl.enable(32823) : gl.disable(32823),
    polygonOffset: (gl, value)=>gl.polygonOffset(...value),
    sampleCoverage: (gl, value)=>gl.sampleCoverage(...value),
    scissorTest: (gl, value)=>value ? gl.enable(3089) : gl.disable(3089),
    scissor: (gl, value)=>gl.scissor(...value),
    stencilTest: (gl, value)=>value ? gl.enable(2960) : gl.disable(2960),
    stencilMask: (gl, value)=>{
        value = $2cabdcb30df9ebb5$var$isArray(value) ? value : [
            value,
            value
        ];
        const [mask, backMask] = value;
        gl.stencilMaskSeparate(1028, mask);
        gl.stencilMaskSeparate(1029, backMask);
    },
    stencilFunc: (gl, args)=>{
        args = $2cabdcb30df9ebb5$var$isArray(args) && args.length === 3 ? [
            ...args,
            ...args
        ] : args;
        const [func, ref, mask, backFunc, backRef, backMask] = args;
        gl.stencilFuncSeparate(1028, func, ref, mask);
        gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
    },
    stencilOp: (gl, args)=>{
        args = $2cabdcb30df9ebb5$var$isArray(args) && args.length === 3 ? [
            ...args,
            ...args
        ] : args;
        const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
        gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
        gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
    },
    viewport: (gl, value)=>gl.viewport(...value)
};
function $2cabdcb30df9ebb5$var$getValue(glEnum, values, cache) {
    return values[glEnum] !== undefined ? values[glEnum] : cache[glEnum];
}
const $2cabdcb30df9ebb5$export$ff5443824a4dc32 = {
    blendEquation: (gl, values, cache)=>gl.blendEquationSeparate($2cabdcb30df9ebb5$var$getValue(32777, values, cache), $2cabdcb30df9ebb5$var$getValue(34877, values, cache)),
    blendFunc: (gl, values, cache)=>gl.blendFuncSeparate($2cabdcb30df9ebb5$var$getValue(32969, values, cache), $2cabdcb30df9ebb5$var$getValue(32968, values, cache), $2cabdcb30df9ebb5$var$getValue(32971, values, cache), $2cabdcb30df9ebb5$var$getValue(32970, values, cache)),
    polygonOffset: (gl, values, cache)=>gl.polygonOffset($2cabdcb30df9ebb5$var$getValue(32824, values, cache), $2cabdcb30df9ebb5$var$getValue(10752, values, cache)),
    sampleCoverage: (gl, values, cache)=>gl.sampleCoverage($2cabdcb30df9ebb5$var$getValue(32938, values, cache), $2cabdcb30df9ebb5$var$getValue(32939, values, cache)),
    stencilFuncFront: (gl, values, cache)=>gl.stencilFuncSeparate(1028, $2cabdcb30df9ebb5$var$getValue(2962, values, cache), $2cabdcb30df9ebb5$var$getValue(2967, values, cache), $2cabdcb30df9ebb5$var$getValue(2963, values, cache)),
    stencilFuncBack: (gl, values, cache)=>gl.stencilFuncSeparate(1029, $2cabdcb30df9ebb5$var$getValue(34816, values, cache), $2cabdcb30df9ebb5$var$getValue(36003, values, cache), $2cabdcb30df9ebb5$var$getValue(36004, values, cache)),
    stencilOpFront: (gl, values, cache)=>gl.stencilOpSeparate(1028, $2cabdcb30df9ebb5$var$getValue(2964, values, cache), $2cabdcb30df9ebb5$var$getValue(2965, values, cache), $2cabdcb30df9ebb5$var$getValue(2966, values, cache)),
    stencilOpBack: (gl, values, cache)=>gl.stencilOpSeparate(1029, $2cabdcb30df9ebb5$var$getValue(34817, values, cache), $2cabdcb30df9ebb5$var$getValue(34818, values, cache), $2cabdcb30df9ebb5$var$getValue(34819, values, cache))
};
const $2cabdcb30df9ebb5$export$21a690e042a82719 = {
    enable: (update, capability)=>update({
            [capability]: true
        }),
    disable: (update, capability)=>update({
            [capability]: false
        }),
    pixelStorei: (update, pname, value)=>update({
            [pname]: value
        }),
    hint: (update, pname, hint1)=>update({
            [pname]: hint1
        }),
    bindFramebuffer: (update, target, framebuffer)=>{
        switch(target){
            case 36160:
                return update({
                    [36006]: framebuffer,
                    [36010]: framebuffer
                });
            case 36009:
                return update({
                    [36006]: framebuffer
                });
            case 36008:
                return update({
                    [36010]: framebuffer
                });
            default:
                return null;
        }
    },
    blendColor: (update, r, g, b, a)=>update({
            [32773]: new Float32Array([
                r,
                g,
                b,
                a
            ])
        }),
    blendEquation: (update, mode)=>update({
            [32777]: mode,
            [34877]: mode
        }),
    blendEquationSeparate: (update, modeRGB, modeAlpha)=>update({
            [32777]: modeRGB,
            [34877]: modeAlpha
        }),
    blendFunc: (update, src, dst)=>update({
            [32969]: src,
            [32968]: dst,
            [32971]: src,
            [32970]: dst
        }),
    blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha)=>update({
            [32969]: srcRGB,
            [32968]: dstRGB,
            [32971]: srcAlpha,
            [32970]: dstAlpha
        }),
    clearColor: (update, r, g, b, a)=>update({
            [3106]: new Float32Array([
                r,
                g,
                b,
                a
            ])
        }),
    clearDepth: (update, depth)=>update({
            [2931]: depth
        }),
    clearStencil: (update, s)=>update({
            [2961]: s
        }),
    colorMask: (update, r, g, b, a)=>update({
            [3107]: [
                r,
                g,
                b,
                a
            ]
        }),
    cullFace: (update, mode)=>update({
            [2885]: mode
        }),
    depthFunc: (update, func)=>update({
            [2932]: func
        }),
    depthRange: (update, zNear, zFar)=>update({
            [2928]: new Float32Array([
                zNear,
                zFar
            ])
        }),
    depthMask: (update, mask)=>update({
            [2930]: mask
        }),
    frontFace: (update, face)=>update({
            [2886]: face
        }),
    lineWidth: (update, width)=>update({
            [2849]: width
        }),
    polygonOffset: (update, factor, units)=>update({
            [32824]: factor,
            [10752]: units
        }),
    sampleCoverage: (update, value, invert)=>update({
            [32938]: value,
            [32939]: invert
        }),
    scissor: (update, x, y, width, height)=>update({
            [3088]: new Int32Array([
                x,
                y,
                width,
                height
            ])
        }),
    stencilMask: (update, mask)=>update({
            [2968]: mask,
            [36005]: mask
        }),
    stencilMaskSeparate: (update, face, mask)=>update({
            [face === 1028 ? 2968 : 36005]: mask
        }),
    stencilFunc: (update, func, ref, mask)=>update({
            [2962]: func,
            [2967]: ref,
            [2963]: mask,
            [34816]: func,
            [36003]: ref,
            [36004]: mask
        }),
    stencilFuncSeparate: (update, face, func, ref, mask)=>update({
            [face === 1028 ? 2962 : 34816]: func,
            [face === 1028 ? 2967 : 36003]: ref,
            [face === 1028 ? 2963 : 36004]: mask
        }),
    stencilOp: (update, fail, zfail, zpass)=>update({
            [2964]: fail,
            [2965]: zfail,
            [2966]: zpass,
            [34817]: fail,
            [34818]: zfail,
            [34819]: zpass
        }),
    stencilOpSeparate: (update, face, fail, zfail, zpass)=>update({
            [face === 1028 ? 2964 : 34817]: fail,
            [face === 1028 ? 2965 : 34818]: zfail,
            [face === 1028 ? 2966 : 34819]: zpass
        }),
    viewport: (update, x, y, width, height)=>update({
            [2978]: [
                x,
                y,
                width,
                height
            ]
        })
};
const $2cabdcb30df9ebb5$var$isEnabled = (gl, key)=>gl.isEnabled(key);
const $2cabdcb30df9ebb5$export$f7e7f6f928a85334 = {
    [3042]: $2cabdcb30df9ebb5$var$isEnabled,
    [2884]: $2cabdcb30df9ebb5$var$isEnabled,
    [2929]: $2cabdcb30df9ebb5$var$isEnabled,
    [3024]: $2cabdcb30df9ebb5$var$isEnabled,
    [32823]: $2cabdcb30df9ebb5$var$isEnabled,
    [32926]: $2cabdcb30df9ebb5$var$isEnabled,
    [32928]: $2cabdcb30df9ebb5$var$isEnabled,
    [3089]: $2cabdcb30df9ebb5$var$isEnabled,
    [2960]: $2cabdcb30df9ebb5$var$isEnabled,
    [35977]: $2cabdcb30df9ebb5$var$isEnabled
};





function $40e068f0e4b7a959$export$23cfe696632d10f4(object) {
    for(const key in object)return false;
    return true;
}
function $40e068f0e4b7a959$export$9b55716ca87eded(x, y) {
    if (x === y) return true;
    const isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
    const isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);
    if (isArrayX && isArrayY && x.length === y.length) {
        for(let i = 0; i < x.length; ++i){
            if (x[i] !== y[i]) return false;
        }
        return true;
    }
    return false;
}


function $0aaaa72a803ca01a$var$installGetterOverride(gl, functionName) {
    const originalGetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function get() {
        const pname = arguments.length <= 0 ? undefined : arguments[0];
        if (!(pname in gl.state.cache)) return originalGetterFunc(...arguments);
        return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc(...arguments);
    };
    Object.defineProperty(gl[functionName], "name", {
        value: "".concat(functionName, "-from-cache"),
        configurable: false
    });
}
function $0aaaa72a803ca01a$var$installSetterSpy(gl, functionName, setter) {
    const originalSetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function set() {
        for(var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++)params[_key] = arguments[_key];
        const { valueChanged: valueChanged , oldValue: oldValue  } = setter(gl.state._updateCache, ...params);
        if (valueChanged) originalSetterFunc(...params);
        return oldValue;
    };
    Object.defineProperty(gl[functionName], "name", {
        value: "".concat(functionName, "-to-cache"),
        configurable: false
    });
}
function $0aaaa72a803ca01a$var$installProgramSpy(gl) {
    const originalUseProgram = gl.useProgram.bind(gl);
    gl.useProgram = function useProgramLuma(handle) {
        if (gl.state.program !== handle) {
            originalUseProgram(handle);
            gl.state.program = handle;
        }
    };
}
class $0aaaa72a803ca01a$var$GLState {
    constructor(gl){
        let { copyState: copyState = false , log: log = ()=>{}  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        this.gl = gl;
        this.program = null;
        this.stateStack = [];
        this.enable = true;
        this.cache = copyState ? (0, $54220aa8b6471f1a$export$1d5e65f36fbcdb49)(gl) : Object.assign({}, (0, $2cabdcb30df9ebb5$export$baa06478962d475e));
        this.log = log;
        this._updateCache = this._updateCache.bind(this);
        Object.seal(this);
    }
    push() {
        let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.stateStack.push({});
    }
    pop() {
        (0, $611f47f49512a05f$export$a7a9523472993e97)(this.stateStack.length > 0);
        const oldValues = this.stateStack[this.stateStack.length - 1];
        (0, $54220aa8b6471f1a$export$60752c4a8a24d484)(this.gl, oldValues);
        this.stateStack.pop();
    }
    _updateCache(values) {
        let valueChanged = false;
        let oldValue;
        const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];
        for(const key in values){
            (0, $611f47f49512a05f$export$a7a9523472993e97)(key !== undefined);
            const value = values[key];
            const cached = this.cache[key];
            if (!(0, $40e068f0e4b7a959$export$9b55716ca87eded)(value, cached)) {
                valueChanged = true;
                oldValue = cached;
                if (oldValues && !(key in oldValues)) oldValues[key] = cached;
                this.cache[key] = value;
            }
        }
        return {
            valueChanged: valueChanged,
            oldValue: oldValue
        };
    }
}
function $0aaaa72a803ca01a$export$eda55831a64d5931(gl) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const { enable: enable = true , copyState: copyState  } = options;
    (0, $611f47f49512a05f$export$a7a9523472993e97)(copyState !== undefined);
    if (!gl.state) {
        const { polyfillContext: polyfillContext  } = globalThis;
        if (polyfillContext) polyfillContext(gl);
        gl.state = new $0aaaa72a803ca01a$var$GLState(gl, {
            copyState: copyState
        });
        $0aaaa72a803ca01a$var$installProgramSpy(gl);
        for(const key in 0, $2cabdcb30df9ebb5$export$21a690e042a82719){
            const setter = (0, $2cabdcb30df9ebb5$export$21a690e042a82719)[key];
            $0aaaa72a803ca01a$var$installSetterSpy(gl, key, setter);
        }
        $0aaaa72a803ca01a$var$installGetterOverride(gl, "getParameter");
        $0aaaa72a803ca01a$var$installGetterOverride(gl, "isEnabled");
    }
    gl.state.enable = enable;
    return gl;
}
function $0aaaa72a803ca01a$export$529f9c1c84156b45(gl) {
    if (!gl.state) $0aaaa72a803ca01a$export$eda55831a64d5931(gl, {
        copyState: false
    });
    gl.state.push();
}
function $0aaaa72a803ca01a$export$30ca4f2cb45c903e(gl) {
    (0, $611f47f49512a05f$export$a7a9523472993e97)(gl.state);
    gl.state.pop();
}





function $54220aa8b6471f1a$export$60752c4a8a24d484(gl, values) {
    (0, $611f47f49512a05f$export$a7a9523472993e97)((0, $325e733792a03f4e$export$3a471d0dd6792be6)(gl), "setParameters requires a WebGL context");
    if ((0, $40e068f0e4b7a959$export$23cfe696632d10f4)(values)) return;
    const compositeSetters = {};
    for(const key in values){
        const glConstant = Number(key);
        const setter = (0, $2cabdcb30df9ebb5$export$f29b03183ed64cfb)[key];
        if (setter) {
            if (typeof setter === "string") compositeSetters[setter] = true;
            else setter(gl, values[key], glConstant);
        }
    }
    const cache = gl.state && gl.state.cache;
    if (cache) for(const key1 in compositeSetters){
        const compositeSetter = (0, $2cabdcb30df9ebb5$export$ff5443824a4dc32)[key1];
        compositeSetter(gl, values, cache);
    }
}
function $54220aa8b6471f1a$export$1d5e65f36fbcdb49(gl, parameters) {
    parameters = parameters || (0, $2cabdcb30df9ebb5$export$baa06478962d475e);
    if (typeof parameters === "number") {
        const key = parameters;
        const getter = (0, $2cabdcb30df9ebb5$export$f7e7f6f928a85334)[key];
        return getter ? getter(gl, key) : gl.getParameter(key);
    }
    const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
    const state = {};
    for (const key of parameterKeys){
        const getter = (0, $2cabdcb30df9ebb5$export$f7e7f6f928a85334)[key];
        state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
    }
    return state;
}
function $54220aa8b6471f1a$export$2ee1427ea70eaaab(gl) {
    $54220aa8b6471f1a$export$60752c4a8a24d484(gl, (0, $2cabdcb30df9ebb5$export$baa06478962d475e));
}
function $54220aa8b6471f1a$export$b1e7058a2936b651(gl, parameters, func) {
    if ((0, $40e068f0e4b7a959$export$23cfe696632d10f4)(parameters)) return func(gl);
    const { nocatch: nocatch = true  } = parameters;
    (0, $0aaaa72a803ca01a$export$529f9c1c84156b45)(gl);
    $54220aa8b6471f1a$export$60752c4a8a24d484(gl, parameters);
    let value;
    if (nocatch) {
        value = func(gl);
        (0, $0aaaa72a803ca01a$export$30ca4f2cb45c903e)(gl);
    } else try {
        value = func(gl);
    } finally{
        (0, $0aaaa72a803ca01a$export$30ca4f2cb45c903e)(gl);
    }
    return value;
}







function $294e503c6396a3ff$export$df40057290e74703(gl) {
    const { luma: luma  } = gl;
    if (gl.canvas && luma) {
        const { clientWidth: clientWidth  } = luma.canvasSizeInfo;
        return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;
    }
    return 1;
}
function $294e503c6396a3ff$export$af080a4e21b7825c(gl, cssPixel) {
    let yInvert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    const ratio = $294e503c6396a3ff$export$df40057290e74703(gl);
    const width = gl.drawingBufferWidth;
    const height = gl.drawingBufferHeight;
    return $294e503c6396a3ff$var$scalePixels(cssPixel, ratio, width, height, yInvert);
}
function $294e503c6396a3ff$export$cf4a949e5ad681d(useDevicePixels) {
    const windowRatio = typeof window === "undefined" ? 1 : window.devicePixelRatio || 1;
    if (Number.isFinite(useDevicePixels)) return useDevicePixels <= 0 ? 1 : useDevicePixels;
    return useDevicePixels ? windowRatio : 1;
}
function $294e503c6396a3ff$var$scalePixels(pixel, ratio, width, height, yInvert) {
    const x = $294e503c6396a3ff$var$scaleX(pixel[0], ratio, width);
    let y = $294e503c6396a3ff$var$scaleY(pixel[1], ratio, height, yInvert);
    let t = $294e503c6396a3ff$var$scaleX(pixel[0] + 1, ratio, width);
    const xHigh = t === width - 1 ? t : t - 1;
    t = $294e503c6396a3ff$var$scaleY(pixel[1] + 1, ratio, height, yInvert);
    let yHigh;
    if (yInvert) {
        t = t === 0 ? t : t + 1;
        yHigh = y;
        y = t;
    } else yHigh = t === height - 1 ? t : t - 1;
    return {
        x: x,
        y: y,
        width: Math.max(xHigh - x + 1, 1),
        height: Math.max(yHigh - y + 1, 1)
    };
}
function $294e503c6396a3ff$var$scaleX(x, ratio, width) {
    const r = Math.min(Math.round(x * ratio), width - 1);
    return r;
}
function $294e503c6396a3ff$var$scaleY(y, ratio, height, yInvert) {
    return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);
}



const $f89b67ad8c6f5746$var$isBrowser = (0, $58cc8c917413a7dc$export$2e2bcd8739ae039)();
const $f89b67ad8c6f5746$var$isPage = $f89b67ad8c6f5746$var$isBrowser && typeof document !== "undefined";
const $f89b67ad8c6f5746$var$CONTEXT_DEFAULTS = {
    webgl2: true,
    webgl1: true,
    throwOnError: true,
    manageState: true,
    canvas: null,
    debug: false,
    width: 800,
    height: 600
};
function $f89b67ad8c6f5746$export$a32ea65c51ffebe7() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, $611f47f49512a05f$export$a7a9523472993e97)($f89b67ad8c6f5746$var$isBrowser, "createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils");
    options = Object.assign({}, $f89b67ad8c6f5746$var$CONTEXT_DEFAULTS, options);
    const { width: width , height: height  } = options;
    function onError(message) {
        if (options.throwOnError) throw new Error(message);
        console.error(message);
        return null;
    }
    options.onError = onError;
    let gl;
    const { canvas: canvas  } = options;
    const targetCanvas = $f89b67ad8c6f5746$var$getCanvas({
        canvas: canvas,
        width: width,
        height: height,
        onError: onError
    });
    gl = $f89b67ad8c6f5746$var$createBrowserContext(targetCanvas, options);
    if (!gl) return null;
    gl = $f89b67ad8c6f5746$export$6b6cef073fe6a207(gl, options);
    $f89b67ad8c6f5746$var$logInfo(gl);
    return gl;
}
function $f89b67ad8c6f5746$export$6b6cef073fe6a207(gl) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!gl || gl._instrumented) return gl;
    gl._version = gl._version || $f89b67ad8c6f5746$var$getVersion(gl);
    gl.luma = gl.luma || {};
    gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
    options = Object.assign({}, $f89b67ad8c6f5746$var$CONTEXT_DEFAULTS, options);
    const { manageState: manageState , debug: debug  } = options;
    if (manageState) (0, $0aaaa72a803ca01a$export$eda55831a64d5931)(gl, {
        copyState: false,
        log: function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
            return (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).log(1, ...args)();
        }
    });
    if ($f89b67ad8c6f5746$var$isBrowser && debug) {
        if (!globalThis.makeDebugContext) (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')();
        else {
            gl = globalThis.makeDebugContext(gl, options);
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).level = Math.max((0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).level, 1);
        }
    }
    gl._instrumented = true;
    return gl;
}
function $f89b67ad8c6f5746$export$6f15ab3b829c3189(gl) {
    const vendorMasked = gl.getParameter(7936);
    const rendererMasked = gl.getParameter(7937);
    const ext = gl.getExtension("WEBGL_debug_renderer_info");
    const vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || 7936);
    const rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || 7937);
    return {
        vendor: vendorUnmasked || vendorMasked,
        renderer: rendererUnmasked || rendererMasked,
        vendorMasked: vendorMasked,
        rendererMasked: rendererMasked,
        version: gl.getParameter(7938),
        shadingLanguageVersion: gl.getParameter(35724)
    };
}
function $f89b67ad8c6f5746$export$4ed444b69b8944fd(gl) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (gl.canvas) {
        const devicePixelRatio = (0, $294e503c6396a3ff$export$cf4a949e5ad681d)(options.useDevicePixels);
        $f89b67ad8c6f5746$var$setDevicePixelRatio(gl, devicePixelRatio, options);
        return;
    }
    const ext = gl.getExtension("STACKGL_resize_drawingbuffer");
    if (ext && "width" in options && "height" in options) ext.resize(options.width, options.height);
}
function $f89b67ad8c6f5746$var$createBrowserContext(canvas, options) {
    const { onError: onError  } = options;
    let errorMessage = null;
    const onCreateError = (error)=>errorMessage = error.statusMessage || errorMessage;
    canvas.addEventListener("webglcontextcreationerror", onCreateError, false);
    const { webgl1: webgl1 = true , webgl2: webgl2 = true  } = options;
    let gl = null;
    if (webgl2) {
        gl = gl || canvas.getContext("webgl2", options);
        gl = gl || canvas.getContext("experimental-webgl2", options);
    }
    if (webgl1) {
        gl = gl || canvas.getContext("webgl", options);
        gl = gl || canvas.getContext("experimental-webgl", options);
    }
    canvas.removeEventListener("webglcontextcreationerror", onCreateError, false);
    if (!gl) return onError("Failed to create ".concat(webgl2 && !webgl1 ? "WebGL2" : "WebGL", " context: ").concat(errorMessage || "Unknown error"));
    if (options.onContextLost) canvas.addEventListener("webglcontextlost", options.onContextLost, false);
    if (options.onContextRestored) canvas.addEventListener("webglcontextrestored", options.onContextRestored, false);
    return gl;
}
function $f89b67ad8c6f5746$var$getCanvas(_ref) {
    let { canvas: canvas , width: width = 800 , height: height = 600 , onError: onError  } = _ref;
    let targetCanvas;
    if (typeof canvas === "string") {
        const isPageLoaded = $f89b67ad8c6f5746$var$isPage && document.readyState === "complete";
        if (!isPageLoaded) onError("createGLContext called on canvas '".concat(canvas, "' before page was loaded"));
        targetCanvas = document.getElementById(canvas);
    } else if (canvas) targetCanvas = canvas;
    else {
        targetCanvas = document.createElement("canvas");
        targetCanvas.id = "lumagl-canvas";
        targetCanvas.style.width = Number.isFinite(width) ? "".concat(width, "px") : "100%";
        targetCanvas.style.height = Number.isFinite(height) ? "".concat(height, "px") : "100%";
        document.body.insertBefore(targetCanvas, document.body.firstChild);
    }
    return targetCanvas;
}
function $f89b67ad8c6f5746$var$logInfo(gl) {
    const webGL = (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? "WebGL2" : "WebGL1";
    const info = $f89b67ad8c6f5746$export$6f15ab3b829c3189(gl);
    const driver = info ? "(".concat(info.vendor, ",").concat(info.renderer, ")") : "";
    const debug = gl.debug ? " debug" : "";
    (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).info(1, "".concat(webGL).concat(debug, " context ").concat(driver))();
}
function $f89b67ad8c6f5746$var$getVersion(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) return 2;
    return 1;
}
function $f89b67ad8c6f5746$var$setDevicePixelRatio(gl, devicePixelRatio, options) {
    let clientWidth = "width" in options ? options.width : gl.canvas.clientWidth;
    let clientHeight = "height" in options ? options.height : gl.canvas.clientHeight;
    if (!clientWidth || !clientHeight) {
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).log(1, "Canvas clientWidth/clientHeight is 0")();
        devicePixelRatio = 1;
        clientWidth = gl.canvas.width || 1;
        clientHeight = gl.canvas.height || 1;
    }
    gl.luma = gl.luma || {};
    gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
    const cachedSize = gl.luma.canvasSizeInfo;
    if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
        let clampedPixelRatio = devicePixelRatio;
        const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
        const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
        gl.canvas.width = canvasWidth;
        gl.canvas.height = canvasHeight;
        if (gl.drawingBufferWidth !== canvasWidth || gl.drawingBufferHeight !== canvasHeight) {
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("Device pixel ratio clamped")();
            clampedPixelRatio = Math.min(gl.drawingBufferWidth / clientWidth, gl.drawingBufferHeight / clientHeight);
            gl.canvas.width = Math.floor(clientWidth * clampedPixelRatio);
            gl.canvas.height = Math.floor(clientHeight * clampedPixelRatio);
        }
        Object.assign(gl.luma.canvasSizeInfo, {
            clientWidth: clientWidth,
            clientHeight: clientHeight,
            devicePixelRatio: devicePixelRatio
        });
    }
}








function $bf567bf995a1ec07$export$2e2bcd8739ae039() {
    let timestamp;
    if (typeof window !== "undefined" && window.performance) timestamp = window.performance.now();
    else if (typeof $7jljs$process !== "undefined" && $7jljs$process.hrtime) {
        const timeParts = $7jljs$process.hrtime();
        timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
    } else timestamp = Date.now();
    return timestamp;
}


class $c4430e0424ce29bf$export$2e2bcd8739ae039 {
    constructor(name, type){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "name", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "type", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "sampleSize", 1);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "time", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "count", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "samples", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "lastTiming", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "lastSampleTime", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "lastSampleCount", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_count", 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_time", 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_samples", 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_startTime", 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_timerPending", false);
        this.name = name;
        this.type = type;
        this.reset();
    }
    setSampleSize(samples) {
        this.sampleSize = samples;
        return this;
    }
    incrementCount() {
        this.addCount(1);
        return this;
    }
    decrementCount() {
        this.subtractCount(1);
        return this;
    }
    addCount(value) {
        this._count += value;
        this._samples++;
        this._checkSampling();
        return this;
    }
    subtractCount(value) {
        this._count -= value;
        this._samples++;
        this._checkSampling();
        return this;
    }
    addTime(time) {
        this._time += time;
        this.lastTiming = time;
        this._samples++;
        this._checkSampling();
        return this;
    }
    timeStart() {
        this._startTime = (0, $bf567bf995a1ec07$export$2e2bcd8739ae039)();
        this._timerPending = true;
        return this;
    }
    timeEnd() {
        if (!this._timerPending) return this;
        this.addTime((0, $bf567bf995a1ec07$export$2e2bcd8739ae039)() - this._startTime);
        this._timerPending = false;
        this._checkSampling();
        return this;
    }
    getSampleAverageCount() {
        return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
    getSampleAverageTime() {
        return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
    getSampleHz() {
        return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;
    }
    getAverageCount() {
        return this.samples > 0 ? this.count / this.samples : 0;
    }
    getAverageTime() {
        return this.samples > 0 ? this.time / this.samples : 0;
    }
    getHz() {
        return this.time > 0 ? this.samples / (this.time / 1000) : 0;
    }
    reset() {
        this.time = 0;
        this.count = 0;
        this.samples = 0;
        this.lastTiming = 0;
        this.lastSampleTime = 0;
        this.lastSampleCount = 0;
        this._count = 0;
        this._time = 0;
        this._samples = 0;
        this._startTime = 0;
        this._timerPending = false;
        return this;
    }
    _checkSampling() {
        if (this._samples === this.sampleSize) {
            this.lastSampleTime = this._time;
            this.lastSampleCount = this._count;
            this.count += this._count;
            this.time += this._time;
            this.samples += this._samples;
            this._time = 0;
            this._count = 0;
            this._samples = 0;
        }
    }
}


class $2fb061cfbc5cb32d$export$2e2bcd8739ae039 {
    constructor(options){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "stats", {});
        this.id = options.id;
        this.stats = {};
        this._initializeStats(options.stats);
        Object.seal(this);
    }
    get(name) {
        let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "count";
        return this._getOrCreate({
            name: name,
            type: type
        });
    }
    get size() {
        return Object.keys(this.stats).length;
    }
    reset() {
        for(const key in this.stats)this.stats[key].reset();
        return this;
    }
    forEach(fn) {
        for(const key in this.stats)fn(this.stats[key]);
    }
    getTable() {
        const table = {};
        this.forEach((stat)=>{
            table[stat.name] = {
                time: stat.time || 0,
                count: stat.count || 0,
                average: stat.getAverageTime() || 0,
                hz: stat.getHz() || 0
            };
        });
        return table;
    }
    _initializeStats() {
        let stats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        stats.forEach((stat)=>this._getOrCreate(stat));
    }
    _getOrCreate(stat) {
        if (!stat || !stat.name) return null;
        const { name: name , type: type  } = stat;
        if (!this.stats[name]) {
            if (stat instanceof (0, $c4430e0424ce29bf$export$2e2bcd8739ae039)) this.stats[name] = stat;
            else this.stats[name] = new (0, $c4430e0424ce29bf$export$2e2bcd8739ae039)(name, type);
        }
        return this.stats[name];
    }
}







const $0a3fbec7776af5cb$var$VERSION = "8.5.16";
const $0a3fbec7776af5cb$var$STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
class $0a3fbec7776af5cb$export$a763db1752b80c33 {
    constructor(){
        this.stats = new Map();
    }
    get(name) {
        if (!this.stats.has(name)) this.stats.set(name, new (0, $2fb061cfbc5cb32d$export$2e2bcd8739ae039)({
            id: name
        }));
        return this.stats.get(name);
    }
}
const $0a3fbec7776af5cb$export$fb95d6e12d0fb414 = new $0a3fbec7776af5cb$export$a763db1752b80c33();
if (globalThis.luma && globalThis.luma.VERSION !== $0a3fbec7776af5cb$var$VERSION) throw new Error("luma.gl - multiple VERSIONs detected: ".concat(globalThis.luma.VERSION, " vs ").concat($0a3fbec7776af5cb$var$VERSION));
if (!globalThis.luma) {
    if ((0, $58cc8c917413a7dc$export$2e2bcd8739ae039)()) (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).log(1, "luma.gl ".concat($0a3fbec7776af5cb$var$VERSION, " - ").concat($0a3fbec7776af5cb$var$STARTUP_MESSAGE))();
    globalThis.luma = globalThis.luma || {
        VERSION: $0a3fbec7776af5cb$var$VERSION,
        version: $0a3fbec7776af5cb$var$VERSION,
        log: $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3,
        stats: $0a3fbec7776af5cb$export$fb95d6e12d0fb414,
        globals: {
            modules: {},
            nodeIO: {}
        }
    };
}
var $0a3fbec7776af5cb$export$2e2bcd8739ae039 = globalThis.luma;

function $cb3c1c602b31e96d$export$6cb2c4c0a22909c0(callback) {
    return typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1000 / 60);
}
function $cb3c1c602b31e96d$export$e00521de187a817a(timerId) {
    return typeof window !== "undefined" && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
}





function $fc8ccbf4aa55ce20$export$a7a9523472993e97(condition, message) {
    if (!condition) throw new Error(message || "luma.gl: assertion failed.");
}


function $d2f1571231f3f4d0$export$38eb86f225c9e34c(gl, name) {
    if (typeof name !== "string") return name;
    const number = Number(name);
    if (!isNaN(number)) return number;
    name = name.replace(/^.*\./, "");
    const value = gl[name];
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(value !== undefined, "Accessing undefined constant GL.".concat(name));
    return value;
}
function $d2f1571231f3f4d0$export$a47fb462a08de82f(gl, value) {
    value = Number(value);
    for(const key in gl){
        if (gl[key] === value) return "GL.".concat(key);
    }
    return String(value);
}
function $d2f1571231f3f4d0$export$7869d83d4284f7ff(gl, value) {
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(value !== undefined, "undefined key");
    value = Number(value);
    for(const key in gl){
        if (gl[key] === value) return "GL.".concat(key);
    }
    return String(value);
}




const $757dc76705f498e6$var$uidCounters = {};
function $757dc76705f498e6$export$e2a22331486dcca0() {
    let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "id";
    $757dc76705f498e6$var$uidCounters[id] = $757dc76705f498e6$var$uidCounters[id] || 1;
    const count = $757dc76705f498e6$var$uidCounters[id]++;
    return "".concat(id, "-").concat(count);
}
function $757dc76705f498e6$export$b9e43d1765415474(n) {
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(typeof n === "number", "Input must be a number");
    return n && (n & n - 1) === 0;
}
function $757dc76705f498e6$export$23cfe696632d10f4(obj) {
    let isEmpty = true;
    for(const key in obj){
        isEmpty = false;
        break;
    }
    return isEmpty;
}



function $cd105bc7922a3ca2$export$5c9302507afeb7af(instance, className, version, methodNames) {
    const upgradeMessage = "See luma.gl ".concat(version, " Upgrade Guide at https://luma.gl/docs/upgrade-guide");
    const prototype = Object.getPrototypeOf(instance);
    methodNames.forEach((methodName)=>{
        if (prototype.methodName) return;
        prototype[methodName] = ()=>{
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).removed("Calling removed method ".concat(className, ".").concat(methodName, ": "), upgradeMessage)();
            throw new Error(methodName);
        };
    });
}


const $dabe379caebdf3da$var$ERR_RESOURCE_METHOD_UNDEFINED = "Resource subclass must define virtual methods";
class $dabe379caebdf3da$export$2e2bcd8739ae039 {
    get [Symbol.toStringTag]() {
        return "Resource";
    }
    constructor(gl){
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, $325e733792a03f4e$export$9b0605fd3c935712)(gl);
        const { id: id , userData: userData = {}  } = opts;
        this.gl = gl;
        this.gl2 = gl;
        this.id = id || (0, $757dc76705f498e6$export$e2a22331486dcca0)(this[Symbol.toStringTag]);
        this.userData = userData;
        this._bound = false;
        this._handle = opts.handle;
        if (this._handle === undefined) this._handle = this._createHandle();
        this.byteLength = 0;
        this._initStats();
        this._addStats();
    }
    toString() {
        return "".concat(this[Symbol.toStringTag] || this.constructor.name, "(").concat(this.id, ")");
    }
    get handle() {
        return this._handle;
    }
    delete() {
        let { deleteChildren: deleteChildren = false  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const children = this._handle && this._deleteHandle(this._handle);
        if (this._handle) this._removeStats();
        this._handle = null;
        if (children && deleteChildren) children.filter(Boolean).forEach((child)=>child.delete());
        return this;
    }
    bind() {
        let funcOrHandle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.handle;
        if (typeof funcOrHandle !== "function") {
            this._bindHandle(funcOrHandle);
            return this;
        }
        let value;
        if (!this._bound) {
            this._bindHandle(this.handle);
            this._bound = true;
            value = funcOrHandle();
            this._bound = false;
            this._bindHandle(null);
        } else value = funcOrHandle();
        return value;
    }
    unbind() {
        this.bind(null);
    }
    getParameter(pname) {
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        pname = (0, $d2f1571231f3f4d0$export$38eb86f225c9e34c)(this.gl, pname);
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(pname);
        const parameters = this.constructor.PARAMETERS || {};
        const parameter = parameters[pname];
        if (parameter) {
            const isWebgl2 = (0, $325e733792a03f4e$export$e3518b1ac7891039)(this.gl);
            const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
            if (!parameterAvailable) {
                const webgl1Default = parameter.webgl1;
                const webgl2Default = "webgl2" in parameter ? parameter.webgl2 : parameter.webgl1;
                const defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
                return defaultValue;
            }
        }
        return this._getParameter(pname, opts);
    }
    getParameters() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { parameters: parameters , keys: keys  } = options;
        const PARAMETERS = this.constructor.PARAMETERS || {};
        const isWebgl2 = (0, $325e733792a03f4e$export$e3518b1ac7891039)(this.gl);
        const values = {};
        const parameterKeys = parameters || Object.keys(PARAMETERS);
        for (const pname of parameterKeys){
            const parameter = PARAMETERS[pname];
            const parameterAvailable = parameter && (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
            if (parameterAvailable) {
                const key = keys ? (0, $d2f1571231f3f4d0$export$a47fb462a08de82f)(this.gl, pname) : pname;
                values[key] = this.getParameter(pname, options);
                if (keys && parameter.type === "GLenum") values[key] = (0, $d2f1571231f3f4d0$export$a47fb462a08de82f)(this.gl, values[key]);
            }
        }
        return values;
    }
    setParameter(pname, value) {
        pname = (0, $d2f1571231f3f4d0$export$38eb86f225c9e34c)(this.gl, pname);
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(pname);
        const parameters = this.constructor.PARAMETERS || {};
        const parameter = parameters[pname];
        if (parameter) {
            const isWebgl2 = (0, $325e733792a03f4e$export$e3518b1ac7891039)(this.gl);
            const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
            if (!parameterAvailable) throw new Error("Parameter not available on this platform");
            if (parameter.type === "GLenum") value = (0, $d2f1571231f3f4d0$export$38eb86f225c9e34c)(value);
        }
        this._setParameter(pname, value);
        return this;
    }
    setParameters(parameters) {
        for(const pname in parameters)this.setParameter(pname, parameters[pname]);
        return this;
    }
    stubRemovedMethods(className, version, methodNames) {
        return (0, $cd105bc7922a3ca2$export$5c9302507afeb7af)(this, className, version, methodNames);
    }
    initialize(opts) {}
    _createHandle() {
        throw new Error($dabe379caebdf3da$var$ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _deleteHandle() {
        throw new Error($dabe379caebdf3da$var$ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _bindHandle(handle) {
        throw new Error($dabe379caebdf3da$var$ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _getOptsFromHandle() {
        throw new Error($dabe379caebdf3da$var$ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _getParameter(pname, opts) {
        throw new Error($dabe379caebdf3da$var$ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _setParameter(pname, value) {
        throw new Error($dabe379caebdf3da$var$ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _context() {
        this.gl.luma = this.gl.luma || {};
        return this.gl.luma;
    }
    _initStats() {
        this.gl.stats = this.gl.stats || new (0, $0a3fbec7776af5cb$export$a763db1752b80c33)();
    }
    _addStats() {
        const name = this[Symbol.toStringTag];
        const stats = (0, $0a3fbec7776af5cb$export$fb95d6e12d0fb414).get("Resource Counts");
        stats.get("Resources Created").incrementCount();
        stats.get("".concat(name, "s Created")).incrementCount();
        stats.get("".concat(name, "s Active")).incrementCount();
    }
    _removeStats() {
        const name = this[Symbol.toStringTag];
        const stats = (0, $0a3fbec7776af5cb$export$fb95d6e12d0fb414).get("Resource Counts");
        stats.get("".concat(name, "s Active")).decrementCount();
    }
    _trackAllocatedMemory(bytes) {
        let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this[Symbol.toStringTag];
        this._doTrackAllocatedMemory(bytes, name);
        this._doTrackAllocatedMemory(bytes, name, this.gl.stats.get("Memory Usage"));
    }
    _doTrackAllocatedMemory(bytes) {
        let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this[Symbol.toStringTag];
        let stats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, $0a3fbec7776af5cb$export$fb95d6e12d0fb414).get("Memory Usage");
        stats.get("GPU Memory").addCount(bytes);
        stats.get("".concat(name, " Memory")).addCount(bytes);
        this.byteLength = bytes;
    }
    _trackDeallocatedMemory() {
        let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this[Symbol.toStringTag];
        this._doTrackDeallocatedMemory(name);
        this._doTrackDeallocatedMemory(name, this.gl.stats.get("Memory Usage"));
    }
    _doTrackDeallocatedMemory() {
        let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this[Symbol.toStringTag];
        let stats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, $0a3fbec7776af5cb$export$fb95d6e12d0fb414).get("Memory Usage");
        stats.get("GPU Memory").subtractCount(this.byteLength);
        stats.get("".concat(name, " Memory")).subtractCount(this.byteLength);
        this.byteLength = 0;
    }
}



const $eee37e63e18ddcdf$var$ERR_TYPE_DEDUCTION = "Failed to deduce GL constant from typed array";
function $eee37e63e18ddcdf$export$127239b7f8a5750f(arrayOrType) {
    const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    switch(type){
        case Float32Array:
            return 5126;
        case Uint16Array:
            return 5123;
        case Uint32Array:
            return 5125;
        case Uint8Array:
            return 5121;
        case Uint8ClampedArray:
            return 5121;
        case Int8Array:
            return 5120;
        case Int16Array:
            return 5122;
        case Int32Array:
            return 5124;
        default:
            throw new Error($eee37e63e18ddcdf$var$ERR_TYPE_DEDUCTION);
    }
}
function $eee37e63e18ddcdf$export$9619a05b47814a85(glType) {
    let { clamped: clamped = true  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    switch(glType){
        case 5126:
            return Float32Array;
        case 5123:
        case 33635:
        case 32819:
        case 32820:
            return Uint16Array;
        case 5125:
            return Uint32Array;
        case 5121:
            return clamped ? Uint8ClampedArray : Uint8Array;
        case 5120:
            return Int8Array;
        case 5122:
            return Int16Array;
        case 5124:
            return Int32Array;
        default:
            throw new Error("Failed to deduce typed array type from GL constant");
    }
}
function $eee37e63e18ddcdf$export$2478197380c2212f(_ref) {
    let { data: data , width: width , height: height , bytesPerPixel: bytesPerPixel = 4 , temp: temp  } = _ref;
    const bytesPerRow = width * bytesPerPixel;
    temp = temp || new Uint8Array(bytesPerRow);
    for(let y = 0; y < height / 2; ++y){
        const topOffset = y * bytesPerRow;
        const bottomOffset = (height - y - 1) * bytesPerRow;
        temp.set(data.subarray(topOffset, topOffset + bytesPerRow));
        data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
        data.set(temp, bottomOffset);
    }
}
function $eee37e63e18ddcdf$export$b405024b493a473f(_ref2) {
    let { data: data , width: width , height: height  } = _ref2;
    const newWidth = Math.round(width / 2);
    const newHeight = Math.round(height / 2);
    const newData = new Uint8Array(newWidth * newHeight * 4);
    for(let y = 0; y < newHeight; y++){
        for(let x = 0; x < newWidth; x++)for(let c = 0; c < 4; c++)newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];
    }
    return {
        data: newData,
        width: newWidth,
        height: newHeight
    };
}




function $91dad1923f57789f$export$aac163a490409890(className, props, propChecks) {
    const { removedProps: removedProps = {} , deprecatedProps: deprecatedProps = {} , replacedProps: replacedProps = {}  } = propChecks;
    for(const propName in removedProps)if (propName in props) {
        const replacementProp = removedProps[propName];
        const replacement = replacementProp ? "".concat(className, ".").concat(removedProps[propName]) : "N/A";
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).removed("".concat(className, ".").concat(propName), replacement)();
    }
    for(const propName1 in deprecatedProps)if (propName1 in props) {
        const replacementProp = deprecatedProps[propName1];
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).deprecated("".concat(className, ".").concat(propName1), "".concat(className, ".").concat(replacementProp))();
    }
    let newProps = null;
    for(const propName2 in replacedProps)if (propName2 in props) {
        const replacementProp = replacedProps[propName2];
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).deprecated("".concat(className, ".").concat(propName2), "".concat(className, ".").concat(replacementProp))();
        newProps = newProps || Object.assign({}, props);
        newProps[replacementProp] = props[propName2];
        delete newProps[propName2];
    }
    return newProps || props;
}


const $905df3b590d61c61$export$e62d85e07017bac6 = {
    offset: 0,
    stride: 0,
    type: 5126,
    size: 1,
    divisor: 0,
    normalized: false,
    integer: false
};
const $905df3b590d61c61$var$PROP_CHECKS = {
    deprecatedProps: {
        instanced: "divisor",
        isInstanced: "divisor"
    }
};
class $905df3b590d61c61$export$2e2bcd8739ae039 {
    static getBytesPerElement(accessor) {
        const ArrayType = (0, $eee37e63e18ddcdf$export$9619a05b47814a85)(accessor.type || 5126);
        return ArrayType.BYTES_PER_ELEMENT;
    }
    static getBytesPerVertex(accessor) {
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(accessor.size);
        const ArrayType = (0, $eee37e63e18ddcdf$export$9619a05b47814a85)(accessor.type || 5126);
        return ArrayType.BYTES_PER_ELEMENT * accessor.size;
    }
    static resolve() {
        for(var _len = arguments.length, accessors = new Array(_len), _key = 0; _key < _len; _key++)accessors[_key] = arguments[_key];
        return new $905df3b590d61c61$export$2e2bcd8739ae039(...[
            $905df3b590d61c61$export$e62d85e07017bac6,
            ...accessors
        ]);
    }
    constructor(){
        for(var _len2 = arguments.length, accessors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)accessors[_key2] = arguments[_key2];
        accessors.forEach((accessor)=>this._assign(accessor));
        Object.freeze(this);
    }
    toString() {
        return JSON.stringify(this);
    }
    get BYTES_PER_ELEMENT() {
        return $905df3b590d61c61$export$2e2bcd8739ae039.getBytesPerElement(this);
    }
    get BYTES_PER_VERTEX() {
        return $905df3b590d61c61$export$2e2bcd8739ae039.getBytesPerVertex(this);
    }
    _assign() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        props = (0, $91dad1923f57789f$export$aac163a490409890)("Accessor", props, $905df3b590d61c61$var$PROP_CHECKS);
        if (props.type !== undefined) {
            this.type = props.type;
            if (props.type === 5124 || props.type === 5125) this.integer = true;
        }
        if (props.size !== undefined) this.size = props.size;
        if (props.offset !== undefined) this.offset = props.offset;
        if (props.stride !== undefined) this.stride = props.stride;
        if (props.normalized !== undefined) this.normalized = props.normalized;
        if (props.integer !== undefined) this.integer = props.integer;
        if (props.divisor !== undefined) this.divisor = props.divisor;
        if (props.buffer !== undefined) this.buffer = props.buffer;
        if (props.index !== undefined) {
            if (typeof props.index === "boolean") this.index = props.index ? 1 : 0;
            else this.index = props.index;
        }
        if (props.instanced !== undefined) this.divisor = props.instanced ? 1 : 0;
        if (props.isInstanced !== undefined) this.divisor = props.isInstanced ? 1 : 0;
        return this;
    }
}






const $28a69bf6d03705d1$var$DEBUG_DATA_LENGTH = 10;
const $28a69bf6d03705d1$var$DEPRECATED_PROPS = {
    offset: "accessor.offset",
    stride: "accessor.stride",
    type: "accessor.type",
    size: "accessor.size",
    divisor: "accessor.divisor",
    normalized: "accessor.normalized",
    integer: "accessor.integer",
    instanced: "accessor.divisor",
    isInstanced: "accessor.divisor"
};
const $28a69bf6d03705d1$var$PROP_CHECKS_INITIALIZE = {
    removedProps: {},
    replacedProps: {
        bytes: "byteLength"
    },
    deprecatedProps: $28a69bf6d03705d1$var$DEPRECATED_PROPS
};
const $28a69bf6d03705d1$var$PROP_CHECKS_SET_PROPS = {
    removedProps: $28a69bf6d03705d1$var$DEPRECATED_PROPS
};
class $28a69bf6d03705d1$export$2e2bcd8739ae039 extends (0, $dabe379caebdf3da$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "Buffer";
    }
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        super(gl, props);
        this.stubRemovedMethods("Buffer", "v6.0", [
            "layout",
            "setLayout",
            "getIndexedParameter"
        ]);
        this.target = props.target || (this.gl.webgl2 ? 36662 : 34962);
        this.initialize(props);
        Object.seal(this);
    }
    getElementCount() {
        let accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;
        return Math.round(this.byteLength / (0, $905df3b590d61c61$export$2e2bcd8739ae039).getBytesPerElement(accessor));
    }
    getVertexCount() {
        let accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;
        return Math.round(this.byteLength / (0, $905df3b590d61c61$export$2e2bcd8739ae039).getBytesPerVertex(accessor));
    }
    initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (ArrayBuffer.isView(props)) props = {
            data: props
        };
        if (Number.isFinite(props)) props = {
            byteLength: props
        };
        props = (0, $91dad1923f57789f$export$aac163a490409890)("Buffer", props, $28a69bf6d03705d1$var$PROP_CHECKS_INITIALIZE);
        this.usage = props.usage || 35044;
        this.debugData = null;
        this.setAccessor(Object.assign({}, props, props.accessor));
        if (props.data) this._setData(props.data, props.offset, props.byteLength);
        else this._setByteLength(props.byteLength || 0);
        return this;
    }
    setProps(props) {
        props = (0, $91dad1923f57789f$export$aac163a490409890)("Buffer", props, $28a69bf6d03705d1$var$PROP_CHECKS_SET_PROPS);
        if ("accessor" in props) this.setAccessor(props.accessor);
        return this;
    }
    setAccessor(accessor) {
        accessor = Object.assign({}, accessor);
        delete accessor.buffer;
        this.accessor = new (0, $905df3b590d61c61$export$2e2bcd8739ae039)(accessor);
        return this;
    }
    reallocate(byteLength) {
        if (byteLength > this.byteLength) {
            this._setByteLength(byteLength);
            return true;
        }
        this.bytesUsed = byteLength;
        return false;
    }
    setData(props) {
        return this.initialize(props);
    }
    subData(props) {
        if (ArrayBuffer.isView(props)) props = {
            data: props
        };
        const { data: data , offset: offset = 0 , srcOffset: srcOffset = 0  } = props;
        const byteLength = props.byteLength || props.length;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(data);
        const target = this.gl.webgl2 ? 36663 : this.target;
        this.gl.bindBuffer(target, this.handle);
        if (srcOffset !== 0 || byteLength !== undefined) {
            (0, $325e733792a03f4e$export$22897d77b4bb5316)(this.gl);
            this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);
        } else this.gl.bufferSubData(target, offset, data);
        this.gl.bindBuffer(target, null);
        this.debugData = null;
        this._inferType(data);
        return this;
    }
    copyData(_ref) {
        let { sourceBuffer: sourceBuffer , readOffset: readOffset = 0 , writeOffset: writeOffset = 0 , size: size  } = _ref;
        const { gl: gl  } = this;
        (0, $325e733792a03f4e$export$22897d77b4bb5316)(gl);
        gl.bindBuffer(36662, sourceBuffer.handle);
        gl.bindBuffer(36663, this.handle);
        gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);
        gl.bindBuffer(36662, null);
        gl.bindBuffer(36663, null);
        this.debugData = null;
        return this;
    }
    getData() {
        let { dstData: dstData = null , srcByteOffset: srcByteOffset = 0 , dstOffset: dstOffset = 0 , length: length = 0  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, $325e733792a03f4e$export$22897d77b4bb5316)(this.gl);
        const ArrayType = (0, $eee37e63e18ddcdf$export$9619a05b47814a85)(this.accessor.type || 5126, {
            clamped: false
        });
        const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);
        const dstElementOffset = dstOffset;
        let dstAvailableElementCount;
        let dstElementCount;
        if (dstData) {
            dstElementCount = dstData.length;
            dstAvailableElementCount = dstElementCount - dstElementOffset;
        } else {
            dstAvailableElementCount = Math.min(sourceAvailableElementCount, length || sourceAvailableElementCount);
            dstElementCount = dstElementOffset + dstAvailableElementCount;
        }
        const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
        length = length || copyElementCount;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(length <= copyElementCount);
        dstData = dstData || new ArrayType(dstElementCount);
        this.gl.bindBuffer(36662, this.handle);
        this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length);
        this.gl.bindBuffer(36662, null);
        return dstData;
    }
    bind() {
        let { target: target = this.target , index: index = this.accessor && this.accessor.index , offset: offset = 0 , size: size  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (target === 35345 || target === 35982) {
            if (size !== undefined) this.gl.bindBufferRange(target, index, this.handle, offset, size);
            else {
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(offset === 0);
                this.gl.bindBufferBase(target, index, this.handle);
            }
        } else this.gl.bindBuffer(target, this.handle);
        return this;
    }
    unbind() {
        let { target: target = this.target , index: index = this.accessor && this.accessor.index  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const isIndexedBuffer = target === 35345 || target === 35982;
        if (isIndexedBuffer) this.gl.bindBufferBase(target, index, null);
        else this.gl.bindBuffer(target, null);
        return this;
    }
    getDebugData() {
        if (!this.debugData) {
            this.debugData = this.getData({
                length: Math.min($28a69bf6d03705d1$var$DEBUG_DATA_LENGTH, this.byteLength)
            });
            return {
                data: this.debugData,
                changed: true
            };
        }
        return {
            data: this.debugData,
            changed: false
        };
    }
    invalidateDebugData() {
        this.debugData = null;
    }
    _setData(data) {
        let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let byteLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : data.byteLength + offset;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(ArrayBuffer.isView(data));
        this._trackDeallocatedMemory();
        const target = this._getTarget();
        this.gl.bindBuffer(target, this.handle);
        this.gl.bufferData(target, byteLength, this.usage);
        this.gl.bufferSubData(target, offset, data);
        this.gl.bindBuffer(target, null);
        this.debugData = data.slice(0, $28a69bf6d03705d1$var$DEBUG_DATA_LENGTH);
        this.bytesUsed = byteLength;
        this._trackAllocatedMemory(byteLength);
        const type = (0, $eee37e63e18ddcdf$export$127239b7f8a5750f)(data);
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(type);
        this.setAccessor(new (0, $905df3b590d61c61$export$2e2bcd8739ae039)(this.accessor, {
            type: type
        }));
        return this;
    }
    _setByteLength(byteLength) {
        let usage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.usage;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(byteLength >= 0);
        this._trackDeallocatedMemory();
        let data = byteLength;
        if (byteLength === 0) data = new Float32Array(0);
        const target = this._getTarget();
        this.gl.bindBuffer(target, this.handle);
        this.gl.bufferData(target, data, usage);
        this.gl.bindBuffer(target, null);
        this.usage = usage;
        this.debugData = null;
        this.bytesUsed = byteLength;
        this._trackAllocatedMemory(byteLength);
        return this;
    }
    _getTarget() {
        return this.gl.webgl2 ? 36663 : this.target;
    }
    _getAvailableElementCount(srcByteOffset) {
        const ArrayType = (0, $eee37e63e18ddcdf$export$9619a05b47814a85)(this.accessor.type || 5126, {
            clamped: false
        });
        const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
        return this.getElementCount() - sourceElementOffset;
    }
    _inferType(data) {
        if (!this.accessor.type) this.setAccessor(new (0, $905df3b590d61c61$export$2e2bcd8739ae039)(this.accessor, {
            type: (0, $eee37e63e18ddcdf$export$127239b7f8a5750f)(data)
        }));
    }
    _createHandle() {
        return this.gl.createBuffer();
    }
    _deleteHandle() {
        this.gl.deleteBuffer(this.handle);
        this._trackDeallocatedMemory();
    }
    _getParameter(pname) {
        this.gl.bindBuffer(this.target, this.handle);
        const value = this.gl.getBufferParameter(this.target, pname);
        this.gl.bindBuffer(this.target, null);
        return value;
    }
    get type() {
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).deprecated("Buffer.type", "Buffer.accessor.type")();
        return this.accessor.type;
    }
    get bytes() {
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).deprecated("Buffer.bytes", "Buffer.byteLength")();
        return this.byteLength;
    }
    setByteLength(byteLength) {
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).deprecated("setByteLength", "reallocate")();
        return this.reallocate(byteLength);
    }
    updateAccessor(opts) {
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).deprecated("updateAccessor(...)", "setAccessor(new Accessor(buffer.accessor, ...)")();
        this.accessor = new (0, $905df3b590d61c61$export$2e2bcd8739ae039)(this.accessor, opts);
        return this;
    }
}



const $7e79c6e30bc6943f$export$ff6ccd50a74e6c72 = {
    [6407]: {
        dataFormat: 6407,
        types: [
            5121,
            33635
        ]
    },
    [6408]: {
        dataFormat: 6408,
        types: [
            5121,
            32819,
            32820
        ]
    },
    [6406]: {
        dataFormat: 6406,
        types: [
            5121
        ]
    },
    [6409]: {
        dataFormat: 6409,
        types: [
            5121
        ]
    },
    [6410]: {
        dataFormat: 6410,
        types: [
            5121
        ]
    },
    [33326]: {
        dataFormat: 6403,
        types: [
            5126
        ],
        gl2: true
    },
    [33328]: {
        dataFormat: 33319,
        types: [
            5126
        ],
        gl2: true
    },
    [34837]: {
        dataFormat: 6407,
        types: [
            5126
        ],
        gl2: true
    },
    [34836]: {
        dataFormat: 6408,
        types: [
            5126
        ],
        gl2: true
    }
};
const $7e79c6e30bc6943f$export$1b400e62d2e54950 = {
    [6403]: 1,
    [36244]: 1,
    [33319]: 2,
    [33320]: 2,
    [6407]: 3,
    [36248]: 3,
    [6408]: 4,
    [36249]: 4,
    [6402]: 1,
    [34041]: 1,
    [6406]: 1,
    [6409]: 1,
    [6410]: 2
};
const $7e79c6e30bc6943f$export$9acf869cba30dad8 = {
    [5126]: 4,
    [5125]: 4,
    [5124]: 4,
    [5123]: 2,
    [5122]: 2,
    [5131]: 2,
    [5120]: 1,
    [5121]: 1
};
function $7e79c6e30bc6943f$export$a3bf67278d0a9114(gl, format) {
    const info = $7e79c6e30bc6943f$export$ff6ccd50a74e6c72[format];
    if (!info) return false;
    if (info.gl1 === undefined && info.gl2 === undefined) return true;
    const value = (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? info.gl2 || info.gl1 : info.gl1;
    return typeof value === "string" ? gl.getExtension(value) : value;
}
function $7e79c6e30bc6943f$export$769628e6c078fe4c(gl, format) {
    const info = $7e79c6e30bc6943f$export$ff6ccd50a74e6c72[format];
    switch(info && info.types[0]){
        case 5126:
            return gl.getExtension("OES_texture_float_linear");
        case 5131:
            return gl.getExtension("OES_texture_half_float_linear");
        default:
            return true;
    }
}




const $541c007d64b391ad$var$NPOT_MIN_FILTERS = [
    9729,
    9728
];
const $541c007d64b391ad$var$WebGLBuffer = globalThis.WebGLBuffer || function WebGLBuffer() {};
class $541c007d64b391ad$export$2e2bcd8739ae039 extends (0, $dabe379caebdf3da$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "Texture";
    }
    static isSupported(gl) {
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const { format: format , linearFiltering: linearFiltering  } = opts;
        let supported = true;
        if (format) {
            supported = supported && (0, $7e79c6e30bc6943f$export$a3bf67278d0a9114)(gl, format);
            supported = supported && (!linearFiltering || (0, $7e79c6e30bc6943f$export$769628e6c078fe4c)(gl, format));
        }
        return supported;
    }
    constructor(gl, props){
        const { id: id = (0, $757dc76705f498e6$export$e2a22331486dcca0)("texture") , handle: handle , target: target  } = props;
        super(gl, {
            id: id,
            handle: handle
        });
        this.target = target;
        this.textureUnit = undefined;
        this.loaded = false;
        this.width = undefined;
        this.height = undefined;
        this.depth = undefined;
        this.format = undefined;
        this.type = undefined;
        this.dataFormat = undefined;
        this.border = undefined;
        this.textureUnit = undefined;
        this.mipmaps = undefined;
    }
    toString() {
        return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
    }
    initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        let data = props.data;
        if (data instanceof Promise) {
            data.then((resolvedImageData)=>this.initialize(Object.assign({}, props, {
                    pixels: resolvedImageData,
                    data: resolvedImageData
                })));
            return this;
        }
        const isVideo = typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement;
        if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {
            this._video = null;
            data.addEventListener("loadeddata", ()=>this.initialize(props));
            return this;
        }
        const { pixels: pixels = null , format: format = 6408 , border: border = 0 , recreate: recreate = false , parameters: parameters = {} , pixelStore: pixelStore = {} , textureUnit: textureUnit  } = props;
        if (!data) data = pixels;
        let { width: width , height: height , dataFormat: dataFormat , type: type , compressed: compressed = false , mipmaps: mipmaps = true  } = props;
        const { depth: depth = 0  } = props;
        ({ width: width , height: height , compressed: compressed , dataFormat: dataFormat , type: type  } = this._deduceParameters({
            format: format,
            type: type,
            dataFormat: dataFormat,
            compressed: compressed,
            data: data,
            width: width,
            height: height
        }));
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.format = format;
        this.type = type;
        this.dataFormat = dataFormat;
        this.border = border;
        this.textureUnit = textureUnit;
        if (Number.isFinite(this.textureUnit)) {
            this.gl.activeTexture(33984 + this.textureUnit);
            this.gl.bindTexture(this.target, this.handle);
        }
        if (mipmaps && this._isNPOT()) {
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
            mipmaps = false;
            this._updateForNPOT(parameters);
        }
        this.mipmaps = mipmaps;
        this.setImageData({
            data: data,
            width: width,
            height: height,
            depth: depth,
            format: format,
            type: type,
            dataFormat: dataFormat,
            border: border,
            mipmaps: mipmaps,
            parameters: pixelStore,
            compressed: compressed
        });
        if (mipmaps) this.generateMipmap();
        this.setParameters(parameters);
        if (recreate) this.data = data;
        if (isVideo) this._video = {
            video: data,
            parameters: parameters,
            lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1
        };
        return this;
    }
    update() {
        if (this._video) {
            const { video: video , parameters: parameters , lastTime: lastTime  } = this._video;
            if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) return;
            this.setSubImageData({
                data: video,
                parameters: parameters
            });
            if (this.mipmaps) this.generateMipmap();
            this._video.lastTime = video.currentTime;
        }
    }
    resize(_ref) {
        let { height: height , width: width , mipmaps: mipmaps = false  } = _ref;
        if (width !== this.width || height !== this.height) return this.initialize({
            width: width,
            height: height,
            format: this.format,
            type: this.type,
            dataFormat: this.dataFormat,
            border: this.border,
            mipmaps: mipmaps
        });
        return this;
    }
    generateMipmap() {
        let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (this._isNPOT()) {
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
            return this;
        }
        this.mipmaps = true;
        this.gl.bindTexture(this.target, this.handle);
        (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(this.gl, params, ()=>{
            this.gl.generateMipmap(this.target);
        });
        this.gl.bindTexture(this.target, null);
        return this;
    }
    setImageData(options) {
        this._trackDeallocatedMemory("Texture");
        const { target: target = this.target , pixels: pixels = null , level: level = 0 , format: format = this.format , border: border = this.border , offset: offset = 0 , parameters: parameters = {}  } = options;
        let { data: data = null , type: type = this.type , width: width = this.width , height: height = this.height , dataFormat: dataFormat = this.dataFormat , compressed: compressed = false  } = options;
        if (!data) data = pixels;
        ({ type: type , dataFormat: dataFormat , compressed: compressed , width: width , height: height  } = this._deduceParameters({
            format: format,
            type: type,
            dataFormat: dataFormat,
            compressed: compressed,
            data: data,
            width: width,
            height: height
        }));
        const { gl: gl  } = this;
        gl.bindTexture(this.target, this.handle);
        let dataType = null;
        ({ data: data , dataType: dataType  } = this._getDataType({
            data: data,
            compressed: compressed
        }));
        let gl2;
        let compressedTextureSize = 0;
        (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(this.gl, parameters, ()=>{
            switch(dataType){
                case "null":
                    gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
                    break;
                case "typed-array":
                    gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);
                    break;
                case "buffer":
                    gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(gl);
                    gl2.bindBuffer(35052, data.handle || data);
                    gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);
                    gl2.bindBuffer(35052, null);
                    break;
                case "browser-object":
                    if ((0, $325e733792a03f4e$export$e3518b1ac7891039)(gl)) gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
                    else gl.texImage2D(target, level, format, dataFormat, type, data);
                    break;
                case "compressed":
                    for (const [levelIndex, levelData] of data.entries()){
                        gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, border, levelData.data);
                        compressedTextureSize += levelData.levelSize;
                    }
                    break;
                default:
                    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false, "Unknown image data type");
            }
        });
        if (dataType === "compressed") this._trackAllocatedMemory(compressedTextureSize, "Texture");
        else if (data && data.byteLength) this._trackAllocatedMemory(data.byteLength, "Texture");
        else {
            const channels = (0, $7e79c6e30bc6943f$export$1b400e62d2e54950)[this.dataFormat] || 4;
            const channelSize = (0, $7e79c6e30bc6943f$export$9acf869cba30dad8)[this.type] || 1;
            this._trackAllocatedMemory(this.width * this.height * channels * channelSize, "Texture");
        }
        this.loaded = true;
        return this;
    }
    setSubImageData(_ref2) {
        let { target: target = this.target , pixels: pixels = null , data: data = null , x: x = 0 , y: y = 0 , width: width = this.width , height: height = this.height , level: level = 0 , format: format = this.format , type: type = this.type , dataFormat: dataFormat = this.dataFormat , compressed: compressed = false , offset: offset = 0 , border: border = this.border , parameters: parameters = {}  } = _ref2;
        ({ type: type , dataFormat: dataFormat , compressed: compressed , width: width , height: height  } = this._deduceParameters({
            format: format,
            type: type,
            dataFormat: dataFormat,
            compressed: compressed,
            data: data,
            width: width,
            height: height
        }));
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(this.depth === 0, "texSubImage not supported for 3D textures");
        if (!data) data = pixels;
        if (data && data.data) {
            const ndarray = data;
            data = ndarray.data;
            width = ndarray.shape[0];
            height = ndarray.shape[1];
        }
        if (data instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) data = data.handle;
        this.gl.bindTexture(this.target, this.handle);
        (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(this.gl, parameters, ()=>{
            if (compressed) this.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);
            else if (data === null) this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);
            else if (ArrayBuffer.isView(data)) this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);
            else if (data instanceof $541c007d64b391ad$var$WebGLBuffer) {
                const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(this.gl);
                gl2.bindBuffer(35052, data);
                gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);
                gl2.bindBuffer(35052, null);
            } else if ((0, $325e733792a03f4e$export$e3518b1ac7891039)(this.gl)) {
                const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(this.gl);
                gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);
            } else this.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);
        });
        this.gl.bindTexture(this.target, null);
    }
    copyFramebuffer() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")();
        return null;
    }
    getActiveUnit() {
        return this.gl.getParameter(34016) - 33984;
    }
    bind() {
        let textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;
        const { gl: gl  } = this;
        if (textureUnit !== undefined) {
            this.textureUnit = textureUnit;
            gl.activeTexture(33984 + textureUnit);
        }
        gl.bindTexture(this.target, this.handle);
        return textureUnit;
    }
    unbind() {
        let textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;
        const { gl: gl  } = this;
        if (textureUnit !== undefined) {
            this.textureUnit = textureUnit;
            gl.activeTexture(33984 + textureUnit);
        }
        gl.bindTexture(this.target, null);
        return textureUnit;
    }
    _getDataType(_ref3) {
        let { data: data , compressed: compressed = false  } = _ref3;
        if (compressed) return {
            data: data,
            dataType: "compressed"
        };
        if (data === null) return {
            data: data,
            dataType: "null"
        };
        if (ArrayBuffer.isView(data)) return {
            data: data,
            dataType: "typed-array"
        };
        if (data instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) return {
            data: data.handle,
            dataType: "buffer"
        };
        if (data instanceof $541c007d64b391ad$var$WebGLBuffer) return {
            data: data,
            dataType: "buffer"
        };
        return {
            data: data,
            dataType: "browser-object"
        };
    }
    _deduceParameters(opts) {
        const { format: format , data: data  } = opts;
        let { width: width , height: height , dataFormat: dataFormat , type: type , compressed: compressed  } = opts;
        const textureFormat = (0, $7e79c6e30bc6943f$export$ff6ccd50a74e6c72)[format];
        dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;
        type = type || textureFormat && textureFormat.types[0];
        compressed = compressed || textureFormat && textureFormat.compressed;
        ({ width: width , height: height  } = this._deduceImageSize(data, width, height));
        return {
            dataFormat: dataFormat,
            type: type,
            compressed: compressed,
            width: width,
            height: height,
            format: format,
            data: data
        };
    }
    _deduceImageSize(data, width, height) {
        let size;
        if (typeof ImageData !== "undefined" && data instanceof ImageData) size = {
            width: data.width,
            height: data.height
        };
        else if (typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement) size = {
            width: data.naturalWidth,
            height: data.naturalHeight
        };
        else if (typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement) size = {
            width: data.width,
            height: data.height
        };
        else if (typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap) size = {
            width: data.width,
            height: data.height
        };
        else if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) size = {
            width: data.videoWidth,
            height: data.videoHeight
        };
        else if (!data) size = {
            width: width >= 0 ? width : 1,
            height: height >= 0 ? height : 1
        };
        else size = {
            width: width,
            height: height
        };
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(size, "Could not deduced texture size");
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(width === undefined || size.width === width, "Deduced texture width does not match supplied width");
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(height === undefined || size.height === height, "Deduced texture height does not match supplied height");
        return size;
    }
    _createHandle() {
        return this.gl.createTexture();
    }
    _deleteHandle() {
        this.gl.deleteTexture(this.handle);
        this._trackDeallocatedMemory("Texture");
    }
    _getParameter(pname) {
        switch(pname){
            case 4096:
                return this.width;
            case 4097:
                return this.height;
            default:
                this.gl.bindTexture(this.target, this.handle);
                const value = this.gl.getTexParameter(this.target, pname);
                this.gl.bindTexture(this.target, null);
                return value;
        }
    }
    _setParameter(pname, param) {
        this.gl.bindTexture(this.target, this.handle);
        param = this._getNPOTParam(pname, param);
        switch(pname){
            case 33082:
            case 33083:
                this.gl.texParameterf(this.handle, pname, param);
                break;
            case 4096:
            case 4097:
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
                break;
            default:
                this.gl.texParameteri(this.target, pname, param);
                break;
        }
        this.gl.bindTexture(this.target, null);
        return this;
    }
    _isNPOT() {
        if ((0, $325e733792a03f4e$export$e3518b1ac7891039)(this.gl)) return false;
        if (!this.width || !this.height) return false;
        return !(0, $757dc76705f498e6$export$b9e43d1765415474)(this.width) || !(0, $757dc76705f498e6$export$b9e43d1765415474)(this.height);
    }
    _updateForNPOT(parameters) {
        if (parameters[this.gl.TEXTURE_MIN_FILTER] === undefined) parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;
        if (parameters[this.gl.TEXTURE_WRAP_S] === undefined) parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;
        if (parameters[this.gl.TEXTURE_WRAP_T] === undefined) parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;
    }
    _getNPOTParam(pname, param) {
        if (this._isNPOT()) switch(pname){
            case 10241:
                if ($541c007d64b391ad$var$NPOT_MIN_FILTERS.indexOf(param) === -1) param = 9729;
                break;
            case 10242:
            case 10243:
                if (param !== 33071) param = 33071;
                break;
            default:
                break;
        }
        return param;
    }
}



let $5874bd7c18e6bc05$var$pathPrefix = "";
function $5874bd7c18e6bc05$export$fa7cbeea6a0f8cd3(prefix) {
    $5874bd7c18e6bc05$var$pathPrefix = prefix;
}
function $5874bd7c18e6bc05$export$3ae43cdaeb063d33(url) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(typeof url === "string");
    url = $5874bd7c18e6bc05$var$pathPrefix + url;
    const dataType = options.dataType || "text";
    return fetch(url, options).then((res)=>res[dataType]());
}
function $5874bd7c18e6bc05$export$fe58198efe02b173(url, opts) {
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(typeof url === "string");
    url = $5874bd7c18e6bc05$var$pathPrefix + url;
    return new Promise((resolve, reject)=>{
        try {
            const image = new Image();
            image.onload = ()=>resolve(image);
            image.onerror = ()=>reject(new Error("Could not load image ".concat(url, ".")));
            image.crossOrigin = opts && opts.crossOrigin || "anonymous";
            image.src = url;
        } catch (error) {
            reject(error);
        }
    });
}


class $df31c887249e3faa$export$2e2bcd8739ae039 extends (0, $541c007d64b391ad$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "Texture2D";
    }
    static isSupported(gl, opts) {
        return (0, $541c007d64b391ad$export$2e2bcd8739ae039).isSupported(gl, opts);
    }
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, $325e733792a03f4e$export$9b0605fd3c935712)(gl);
        if (props instanceof Promise || typeof props === "string") props = {
            data: props
        };
        if (typeof props.data === "string") props = Object.assign({}, props, {
            data: (0, $5874bd7c18e6bc05$export$fe58198efe02b173)(props.data)
        });
        super(gl, Object.assign({}, props, {
            target: 3553
        }));
        this.initialize(props);
        Object.seal(this);
    }
}




const $499b8d3cccd7f89c$var$FACES = [
    34069,
    34070,
    34071,
    34072,
    34073,
    34074
];
class $499b8d3cccd7f89c$export$2e2bcd8739ae039 extends (0, $541c007d64b391ad$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "TextureCube";
    }
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, $325e733792a03f4e$export$9b0605fd3c935712)(gl);
        super(gl, Object.assign({}, props, {
            target: 34067
        }));
        this.initialize(props);
        Object.seal(this);
    }
    initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { mipmaps: mipmaps = true , parameters: parameters = {}  } = props;
        this.opts = props;
        this.setCubeMapImageData(props).then(()=>{
            this.loaded = true;
            if (mipmaps) this.generateMipmap(props);
            this.setParameters(parameters);
        });
        return this;
    }
    subImage(_ref) {
        let { face: face , data: data , x: x = 0 , y: y = 0 , mipmapLevel: mipmapLevel = 0  } = _ref;
        return this._subImage({
            target: face,
            data: data,
            x: x,
            y: y,
            mipmapLevel: mipmapLevel
        });
    }
    async setCubeMapImageData(_ref2) {
        let { width: width , height: height , pixels: pixels , data: data , border: border = 0 , format: format = 6408 , type: type = 5121  } = _ref2;
        const { gl: gl  } = this;
        const imageDataMap = pixels || data;
        const resolvedFaces = await Promise.all($499b8d3cccd7f89c$var$FACES.map((face)=>{
            const facePixels = imageDataMap[face];
            return Promise.all(Array.isArray(facePixels) ? facePixels : [
                facePixels
            ]);
        }));
        this.bind();
        $499b8d3cccd7f89c$var$FACES.forEach((face, index)=>{
            if (resolvedFaces[index].length > 1 && this.opts.mipmaps !== false) (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("".concat(this.id, " has mipmap and multiple LODs."))();
            resolvedFaces[index].forEach((image, lodLevel)=>{
                if (width && height) gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);
                else gl.texImage2D(face, lodLevel, format, format, type, image);
            });
        });
        this.unbind();
    }
    setImageDataForFace(options) {
        const { face: face , width: width , height: height , pixels: pixels , data: data , border: border = 0 , format: format = 6408 , type: type = 5121  } = options;
        const { gl: gl  } = this;
        const imageData = pixels || data;
        this.bind();
        if (imageData instanceof Promise) imageData.then((resolvedImageData)=>this.setImageDataForFace(Object.assign({}, options, {
                face: face,
                data: resolvedImageData,
                pixels: resolvedImageData
            })));
        else if (this.width || this.height) gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);
        else gl.texImage2D(face, 0, format, format, type, imageData);
        return this;
    }
}
$499b8d3cccd7f89c$export$2e2bcd8739ae039.FACES = $499b8d3cccd7f89c$var$FACES;






class $4aa833ce3ed7a225$export$2e2bcd8739ae039 extends (0, $541c007d64b391ad$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "Texture3D";
    }
    static isSupported(gl) {
        return (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl);
    }
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, $325e733792a03f4e$export$22897d77b4bb5316)(gl);
        props = Object.assign({
            depth: 1
        }, props, {
            target: 32879,
            unpackFlipY: false
        });
        super(gl, props);
        this.initialize(props);
        Object.seal(this);
    }
    setImageData(_ref) {
        let { level: level = 0 , dataFormat: dataFormat = 6408 , width: width , height: height , depth: depth = 1 , border: border = 0 , format: format , type: type = 5121 , offset: offset = 0 , data: data , parameters: parameters = {}  } = _ref;
        this._trackDeallocatedMemory("Texture");
        this.gl.bindTexture(this.target, this.handle);
        (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(this.gl, parameters, ()=>{
            if (ArrayBuffer.isView(data)) this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, data);
            if (data instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) {
                this.gl.bindBuffer(35052, data.handle);
                this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, offset);
            }
        });
        if (data && data.byteLength) this._trackAllocatedMemory(data.byteLength, "Texture");
        else {
            const channels = (0, $7e79c6e30bc6943f$export$1b400e62d2e54950)[this.dataFormat] || 4;
            const channelSize = (0, $7e79c6e30bc6943f$export$9acf869cba30dad8)[this.type] || 1;
            this._trackAllocatedMemory(this.width * this.height * this.depth * channels * channelSize, "Texture");
        }
        this.loaded = true;
        return this;
    }
}






const $7d33c99dc7978aa3$var$EXT_FLOAT_WEBGL2 = "EXT_color_buffer_float";
var $7d33c99dc7978aa3$export$2e2bcd8739ae039 = {
    [33189]: {
        bpp: 2
    },
    [33190]: {
        gl2: true,
        bpp: 3
    },
    [36012]: {
        gl2: true,
        bpp: 4
    },
    [36168]: {
        bpp: 1
    },
    [34041]: {
        bpp: 4
    },
    [35056]: {
        gl2: true,
        bpp: 4
    },
    [36013]: {
        gl2: true,
        bpp: 5
    },
    [32854]: {
        bpp: 2
    },
    [36194]: {
        bpp: 2
    },
    [32855]: {
        bpp: 2
    },
    [33321]: {
        gl2: true,
        bpp: 1
    },
    [33330]: {
        gl2: true,
        bpp: 1
    },
    [33329]: {
        gl2: true,
        bpp: 1
    },
    [33332]: {
        gl2: true,
        bpp: 2
    },
    [33331]: {
        gl2: true,
        bpp: 2
    },
    [33334]: {
        gl2: true,
        bpp: 4
    },
    [33333]: {
        gl2: true,
        bpp: 4
    },
    [33323]: {
        gl2: true,
        bpp: 2
    },
    [33336]: {
        gl2: true,
        bpp: 2
    },
    [33335]: {
        gl2: true,
        bpp: 2
    },
    [33338]: {
        gl2: true,
        bpp: 4
    },
    [33337]: {
        gl2: true,
        bpp: 4
    },
    [33340]: {
        gl2: true,
        bpp: 8
    },
    [33339]: {
        gl2: true,
        bpp: 8
    },
    [32849]: {
        gl2: true,
        bpp: 3
    },
    [32856]: {
        gl2: true,
        bpp: 4
    },
    [32857]: {
        gl2: true,
        bpp: 4
    },
    [36220]: {
        gl2: true,
        bpp: 4
    },
    [36238]: {
        gl2: true,
        bpp: 4
    },
    [36975]: {
        gl2: true,
        bpp: 4
    },
    [36214]: {
        gl2: true,
        bpp: 8
    },
    [36232]: {
        gl2: true,
        bpp: 8
    },
    [36226]: {
        gl2: true,
        bpp: 16
    },
    [36208]: {
        gl2: true,
        bpp: 16
    },
    [33325]: {
        gl2: $7d33c99dc7978aa3$var$EXT_FLOAT_WEBGL2,
        bpp: 2
    },
    [33327]: {
        gl2: $7d33c99dc7978aa3$var$EXT_FLOAT_WEBGL2,
        bpp: 4
    },
    [34842]: {
        gl2: $7d33c99dc7978aa3$var$EXT_FLOAT_WEBGL2,
        bpp: 8
    },
    [33326]: {
        gl2: $7d33c99dc7978aa3$var$EXT_FLOAT_WEBGL2,
        bpp: 4
    },
    [33328]: {
        gl2: $7d33c99dc7978aa3$var$EXT_FLOAT_WEBGL2,
        bpp: 8
    },
    [34836]: {
        gl2: $7d33c99dc7978aa3$var$EXT_FLOAT_WEBGL2,
        bpp: 16
    },
    [35898]: {
        gl2: $7d33c99dc7978aa3$var$EXT_FLOAT_WEBGL2,
        bpp: 4
    }
};




function $0082476f18a250b0$var$isFormatSupported(gl, format, formats) {
    const info = formats[format];
    if (!info) return false;
    const value = (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? info.gl2 || info.gl1 : info.gl1;
    if (typeof value === "string") return gl.getExtension(value);
    return value;
}
class $0082476f18a250b0$export$2e2bcd8739ae039 extends (0, $dabe379caebdf3da$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "Renderbuffer";
    }
    static isSupported(gl) {
        let { format: format  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            format: null
        };
        return !format || $0082476f18a250b0$var$isFormatSupported(gl, format, (0, $7d33c99dc7978aa3$export$2e2bcd8739ae039));
    }
    static getSamplesForFormat(gl, _ref) {
        let { format: format  } = _ref;
        return gl.getInternalformatParameter(36161, format, 32937);
    }
    constructor(gl){
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        super(gl, opts);
        this.initialize(opts);
        Object.seal(this);
    }
    initialize(_ref2) {
        let { format: format , width: width = 1 , height: height = 1 , samples: samples = 0  } = _ref2;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(format, "Needs format");
        this._trackDeallocatedMemory();
        this.gl.bindRenderbuffer(36161, this.handle);
        if (samples !== 0 && (0, $325e733792a03f4e$export$e3518b1ac7891039)(this.gl)) this.gl.renderbufferStorageMultisample(36161, samples, format, width, height);
        else this.gl.renderbufferStorage(36161, format, width, height);
        this.format = format;
        this.width = width;
        this.height = height;
        this.samples = samples;
        this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * (0, $7d33c99dc7978aa3$export$2e2bcd8739ae039)[this.format].bpp);
        return this;
    }
    resize(_ref3) {
        let { width: width , height: height  } = _ref3;
        if (width !== this.width || height !== this.height) return this.initialize({
            width: width,
            height: height,
            format: this.format,
            samples: this.samples
        });
        return this;
    }
    _createHandle() {
        return this.gl.createRenderbuffer();
    }
    _deleteHandle() {
        this.gl.deleteRenderbuffer(this.handle);
        this._trackDeallocatedMemory();
    }
    _bindHandle(handle) {
        this.gl.bindRenderbuffer(36161, handle);
    }
    _syncHandle(handle) {
        this.format = this.getParameter(36164);
        this.width = this.getParameter(36162);
        this.height = this.getParameter(36163);
        this.samples = this.getParameter(36011);
    }
    _getParameter(pname) {
        this.gl.bindRenderbuffer(36161, this.handle);
        const value = this.gl.getRenderbufferParameter(36161, pname);
        return value;
    }
}




const $9d2da77370080708$var$GL_DEPTH_BUFFER_BIT = 0x00000100;
const $9d2da77370080708$var$GL_STENCIL_BUFFER_BIT = 0x00000400;
const $9d2da77370080708$var$GL_COLOR_BUFFER_BIT = 0x00004000;
const $9d2da77370080708$var$GL_COLOR = 0x1800;
const $9d2da77370080708$var$GL_DEPTH = 0x1801;
const $9d2da77370080708$var$GL_STENCIL = 0x1802;
const $9d2da77370080708$var$GL_DEPTH_STENCIL = 0x84f9;
const $9d2da77370080708$var$ERR_ARGUMENTS = "clear: bad arguments";
function $9d2da77370080708$export$42ffd38884aecdac(gl) {
    let { framebuffer: framebuffer = null , color: color = null , depth: depth = null , stencil: stencil = null  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const parameters = {};
    if (framebuffer) parameters.framebuffer = framebuffer;
    let clearFlags = 0;
    if (color) {
        clearFlags |= $9d2da77370080708$var$GL_COLOR_BUFFER_BIT;
        if (color !== true) parameters.clearColor = color;
    }
    if (depth) {
        clearFlags |= $9d2da77370080708$var$GL_DEPTH_BUFFER_BIT;
        if (depth !== true) parameters.clearDepth = depth;
    }
    if (stencil) {
        clearFlags |= $9d2da77370080708$var$GL_STENCIL_BUFFER_BIT;
        if (depth !== true) parameters.clearStencil = depth;
    }
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(clearFlags !== 0, $9d2da77370080708$var$ERR_ARGUMENTS);
    (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(gl, parameters, ()=>{
        gl.clear(clearFlags);
    });
}
function $9d2da77370080708$export$abb0b37bc9255c0e(gl) {
    let { framebuffer: framebuffer = null , buffer: buffer = $9d2da77370080708$var$GL_COLOR , drawBuffer: drawBuffer = 0 , value: value = [
        0,
        0,
        0,
        0
    ]  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, $325e733792a03f4e$export$22897d77b4bb5316)(gl);
    (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(gl, {
        framebuffer: framebuffer
    }, ()=>{
        switch(buffer){
            case $9d2da77370080708$var$GL_COLOR:
                switch(value.constructor){
                    case Int32Array:
                        gl.clearBufferiv(buffer, drawBuffer, value);
                        break;
                    case Uint32Array:
                        gl.clearBufferuiv(buffer, drawBuffer, value);
                        break;
                    case Float32Array:
                    default:
                        gl.clearBufferfv(buffer, drawBuffer, value);
                }
                break;
            case $9d2da77370080708$var$GL_DEPTH:
                gl.clearBufferfv($9d2da77370080708$var$GL_DEPTH, 0, [
                    value
                ]);
                break;
            case $9d2da77370080708$var$GL_STENCIL:
                gl.clearBufferiv($9d2da77370080708$var$GL_STENCIL, 0, [
                    value
                ]);
                break;
            case $9d2da77370080708$var$GL_DEPTH_STENCIL:
                const [depth, stencil] = value;
                gl.clearBufferfi($9d2da77370080708$var$GL_DEPTH_STENCIL, 0, depth, stencil);
                break;
            default:
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false, $9d2da77370080708$var$ERR_ARGUMENTS);
        }
    });
}









function $6f98a3202da2e321$export$211a621476a5328b(format) {
    switch(format){
        case 6406:
        case 33326:
        case 6403:
            return 1;
        case 33328:
        case 33319:
            return 2;
        case 6407:
        case 34837:
            return 3;
        case 6408:
        case 34836:
            return 4;
        default:
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
            return 0;
    }
}
function $6f98a3202da2e321$export$25c250e029e88433(type) {
    switch(type){
        case 5121:
            return 1;
        case 33635:
        case 32819:
        case 32820:
            return 2;
        case 5126:
            return 4;
        default:
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
            return 0;
    }
}




function $c192e756436d1779$export$f9f2f48e7f9faaa5(source) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const { sourceX: sourceX = 0 , sourceY: sourceY = 0 , sourceFormat: sourceFormat = 6408  } = options;
    let { sourceAttachment: sourceAttachment = 36064 , target: target = null , sourceWidth: sourceWidth , sourceHeight: sourceHeight , sourceType: sourceType  } = options;
    const { framebuffer: framebuffer , deleteFramebuffer: deleteFramebuffer  } = $c192e756436d1779$var$getFramebuffer(source);
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(framebuffer);
    const { gl: gl , handle: handle , attachments: attachments  } = framebuffer;
    sourceWidth = sourceWidth || framebuffer.width;
    sourceHeight = sourceHeight || framebuffer.height;
    if (sourceAttachment === 36064 && handle === null) sourceAttachment = 1028;
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(attachments[sourceAttachment]);
    sourceType = sourceType || attachments[sourceAttachment].type;
    target = $c192e756436d1779$var$getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
    sourceType = sourceType || (0, $eee37e63e18ddcdf$export$127239b7f8a5750f)(target);
    const prevHandle = gl.bindFramebuffer(36160, handle);
    gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
    gl.bindFramebuffer(36160, prevHandle || null);
    if (deleteFramebuffer) framebuffer.delete();
    return target;
}
function $c192e756436d1779$export$c063f9191f0d5b03(source, _ref) {
    let { sourceX: sourceX = 0 , sourceY: sourceY = 0 , sourceFormat: sourceFormat = 6408 , target: target = null , targetByteOffset: targetByteOffset = 0 , sourceWidth: sourceWidth , sourceHeight: sourceHeight , sourceType: sourceType  } = _ref;
    const { framebuffer: framebuffer , deleteFramebuffer: deleteFramebuffer  } = $c192e756436d1779$var$getFramebuffer(source);
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(framebuffer);
    sourceWidth = sourceWidth || framebuffer.width;
    sourceHeight = sourceHeight || framebuffer.height;
    const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(framebuffer.gl);
    sourceType = sourceType || (target ? target.type : 5121);
    if (!target) {
        const components = (0, $6f98a3202da2e321$export$211a621476a5328b)(sourceFormat);
        const byteCount = (0, $6f98a3202da2e321$export$25c250e029e88433)(sourceType);
        const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
        target = new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(gl2, {
            byteLength: byteLength,
            accessor: {
                type: sourceType,
                size: components
            }
        });
    }
    target.bind({
        target: 35051
    });
    (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(gl2, {
        framebuffer: framebuffer
    }, ()=>{
        gl2.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, targetByteOffset);
    });
    target.unbind({
        target: 35051
    });
    if (deleteFramebuffer) framebuffer.delete();
    return target;
}
function $c192e756436d1779$export$310e97e05f1c81cc(source) {
    let { sourceAttachment: sourceAttachment = 36064 , targetMaxHeight: targetMaxHeight = Number.MAX_SAFE_INTEGER  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let data = $c192e756436d1779$export$f9f2f48e7f9faaa5(source, {
        sourceAttachment: sourceAttachment
    });
    let { width: width , height: height  } = source;
    while(height > targetMaxHeight)({ data: data , width: width , height: height  } = (0, $eee37e63e18ddcdf$export$b405024b493a473f)({
        data: data,
        width: width,
        height: height
    }));
    (0, $eee37e63e18ddcdf$export$2478197380c2212f)({
        data: data,
        width: width,
        height: height
    });
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext("2d");
    const imageData = context.createImageData(width, height);
    imageData.data.set(data);
    context.putImageData(imageData, 0, 0);
    return canvas.toDataURL();
}
function $c192e756436d1779$export$d848cd44c7a9b314(source) {
    let { sourceAttachment: sourceAttachment = 36064 , targetImage: targetImage = null  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const dataUrl = $c192e756436d1779$export$310e97e05f1c81cc(source, {
        sourceAttachment: sourceAttachment
    });
    targetImage = targetImage || new Image();
    targetImage.src = dataUrl;
    return targetImage;
}
function $c192e756436d1779$export$45ef68203138b6b0(source, target) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const { sourceX: sourceX = 0 , sourceY: sourceY = 0 , targetMipmaplevel: targetMipmaplevel = 0 , targetInternalFormat: targetInternalFormat = 6408  } = options;
    let { targetX: targetX , targetY: targetY , targetZ: targetZ , width: width , height: height  } = options;
    const { framebuffer: framebuffer , deleteFramebuffer: deleteFramebuffer  } = $c192e756436d1779$var$getFramebuffer(source);
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(framebuffer);
    const { gl: gl , handle: handle  } = framebuffer;
    const isSubCopy = typeof targetX !== "undefined" || typeof targetY !== "undefined" || typeof targetZ !== "undefined";
    targetX = targetX || 0;
    targetY = targetY || 0;
    targetZ = targetZ || 0;
    const prevHandle = gl.bindFramebuffer(36160, handle);
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(target);
    let texture = null;
    if (target instanceof (0, $541c007d64b391ad$export$2e2bcd8739ae039)) {
        texture = target;
        width = Number.isFinite(width) ? width : texture.width;
        height = Number.isFinite(height) ? height : texture.height;
        texture.bind(0);
        target = texture.target;
    }
    if (!isSubCopy) gl.copyTexImage2D(target, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0);
    else switch(target){
        case 3553:
        case 34067:
            gl.copyTexSubImage2D(target, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);
            break;
        case 35866:
        case 32879:
            const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(gl);
            gl2.copyTexSubImage3D(target, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);
            break;
        default:
    }
    if (texture) texture.unbind();
    gl.bindFramebuffer(36160, prevHandle || null);
    if (deleteFramebuffer) framebuffer.delete();
    return texture;
}
function $c192e756436d1779$export$1b8713e12f56ba52(source, target) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const { sourceX0: sourceX0 = 0 , sourceY0: sourceY0 = 0 , targetX0: targetX0 = 0 , targetY0: targetY0 = 0 , color: color = true , depth: depth = false , stencil: stencil = false , filter: filter = 9728  } = options;
    let { sourceX1: sourceX1 , sourceY1: sourceY1 , targetX1: targetX1 , targetY1: targetY1 , sourceAttachment: sourceAttachment = 36064 , mask: mask = 0  } = options;
    const { framebuffer: srcFramebuffer , deleteFramebuffer: deleteSrcFramebuffer  } = $c192e756436d1779$var$getFramebuffer(source);
    const { framebuffer: dstFramebuffer , deleteFramebuffer: deleteDstFramebuffer  } = $c192e756436d1779$var$getFramebuffer(target);
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(srcFramebuffer);
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(dstFramebuffer);
    const { gl: gl , handle: handle , width: width , height: height , readBuffer: readBuffer  } = dstFramebuffer;
    const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(gl);
    if (!srcFramebuffer.handle && sourceAttachment === 36064) sourceAttachment = 1028;
    if (color) mask |= 16384;
    if (depth) mask |= 256;
    if (stencil) mask |= 1024;
    if (deleteSrcFramebuffer || deleteDstFramebuffer) {
        if (mask & 1280) {
            mask = 16384;
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("Blitting from or into a Texture object, forcing mask to GL.COLOR_BUFFER_BIT")();
        }
    }
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(mask);
    sourceX1 = sourceX1 === undefined ? srcFramebuffer.width : sourceX1;
    sourceY1 = sourceY1 === undefined ? srcFramebuffer.height : sourceY1;
    targetX1 = targetX1 === undefined ? width : targetX1;
    targetY1 = targetY1 === undefined ? height : targetY1;
    const prevDrawHandle = gl.bindFramebuffer(36009, handle);
    const prevReadHandle = gl.bindFramebuffer(36008, srcFramebuffer.handle);
    gl2.readBuffer(sourceAttachment);
    gl2.blitFramebuffer(sourceX0, sourceY0, sourceX1, sourceY1, targetX0, targetY0, targetX1, targetY1, mask, filter);
    gl2.readBuffer(readBuffer);
    gl2.bindFramebuffer(36008, prevReadHandle || null);
    gl2.bindFramebuffer(36009, prevDrawHandle || null);
    if (deleteSrcFramebuffer) srcFramebuffer.delete();
    if (deleteDstFramebuffer) dstFramebuffer.delete();
    return dstFramebuffer;
}
function $c192e756436d1779$var$getFramebuffer(source) {
    if (!(source instanceof (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039))) return {
        framebuffer: (0, $379077f7c038ee76$export$37e0e55400e095ba)(source),
        deleteFramebuffer: true
    };
    return {
        framebuffer: source,
        deleteFramebuffer: false
    };
}
function $c192e756436d1779$var$getPixelArray(pixelArray, type, format, width, height) {
    if (pixelArray) return pixelArray;
    type = type || 5121;
    const ArrayType = (0, $eee37e63e18ddcdf$export$9619a05b47814a85)(type, {
        clamped: false
    });
    const components = (0, $6f98a3202da2e321$export$211a621476a5328b)(format);
    return new ArrayType(width * height * components);
}




const $8cba87f65ded858b$export$d6a5c11f04f75862 = {
    WEBGL2: "WEBGL2",
    VERTEX_ARRAY_OBJECT: "VERTEX_ARRAY_OBJECT",
    TIMER_QUERY: "TIMER_QUERY",
    INSTANCED_RENDERING: "INSTANCED_RENDERING",
    MULTIPLE_RENDER_TARGETS: "MULTIPLE_RENDER_TARGETS",
    ELEMENT_INDEX_UINT32: "ELEMENT_INDEX_UINT32",
    BLEND_EQUATION_MINMAX: "BLEND_EQUATION_MINMAX",
    FLOAT_BLEND: "FLOAT_BLEND",
    COLOR_ENCODING_SRGB: "COLOR_ENCODING_SRGB",
    TEXTURE_DEPTH: "TEXTURE_DEPTH",
    TEXTURE_FLOAT: "TEXTURE_FLOAT",
    TEXTURE_HALF_FLOAT: "TEXTURE_HALF_FLOAT",
    TEXTURE_FILTER_LINEAR_FLOAT: "TEXTURE_FILTER_LINEAR_FLOAT",
    TEXTURE_FILTER_LINEAR_HALF_FLOAT: "TEXTURE_FILTER_LINEAR_HALF_FLOAT",
    TEXTURE_FILTER_ANISOTROPIC: "TEXTURE_FILTER_ANISOTROPIC",
    COLOR_ATTACHMENT_RGBA32F: "COLOR_ATTACHMENT_RGBA32F",
    COLOR_ATTACHMENT_FLOAT: "COLOR_ATTACHMENT_FLOAT",
    COLOR_ATTACHMENT_HALF_FLOAT: "COLOR_ATTACHMENT_HALF_FLOAT",
    GLSL_FRAG_DATA: "GLSL_FRAG_DATA",
    GLSL_FRAG_DEPTH: "GLSL_FRAG_DEPTH",
    GLSL_DERIVATIVES: "GLSL_DERIVATIVES",
    GLSL_TEXTURE_LOD: "GLSL_TEXTURE_LOD"
};
function $8cba87f65ded858b$var$checkFloat32ColorAttachment(gl) {
    const testTexture = new (0, $df31c887249e3faa$export$2e2bcd8739ae039)(gl, {
        format: 6408,
        type: 5126,
        dataFormat: 6408
    });
    const testFb = new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(gl, {
        id: "test-framebuffer",
        check: false,
        attachments: {
            [36064]: testTexture
        }
    });
    const status = testFb.getStatus();
    testTexture.delete();
    testFb.delete();
    return status === 36053;
}
var $8cba87f65ded858b$export$2e2bcd8739ae039 = {
    [$8cba87f65ded858b$export$d6a5c11f04f75862.WEBGL2]: [
        false,
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.VERTEX_ARRAY_OBJECT]: [
        "OES_vertex_array_object",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.TIMER_QUERY]: [
        "EXT_disjoint_timer_query",
        "EXT_disjoint_timer_query_webgl2"
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.INSTANCED_RENDERING]: [
        "ANGLE_instanced_arrays",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.MULTIPLE_RENDER_TARGETS]: [
        "WEBGL_draw_buffers",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.ELEMENT_INDEX_UINT32]: [
        "OES_element_index_uint",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.BLEND_EQUATION_MINMAX]: [
        "EXT_blend_minmax",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.FLOAT_BLEND]: [
        "EXT_float_blend"
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.COLOR_ENCODING_SRGB]: [
        "EXT_sRGB",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.TEXTURE_DEPTH]: [
        "WEBGL_depth_texture",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.TEXTURE_FLOAT]: [
        "OES_texture_float",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.TEXTURE_HALF_FLOAT]: [
        "OES_texture_half_float",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.TEXTURE_FILTER_LINEAR_FLOAT]: [
        "OES_texture_float_linear"
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.TEXTURE_FILTER_LINEAR_HALF_FLOAT]: [
        "OES_texture_half_float_linear"
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.TEXTURE_FILTER_ANISOTROPIC]: [
        "EXT_texture_filter_anisotropic"
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.COLOR_ATTACHMENT_RGBA32F]: [
        $8cba87f65ded858b$var$checkFloat32ColorAttachment,
        "EXT_color_buffer_float"
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.COLOR_ATTACHMENT_FLOAT]: [
        false,
        "EXT_color_buffer_float"
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.COLOR_ATTACHMENT_HALF_FLOAT]: [
        "EXT_color_buffer_half_float"
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.GLSL_FRAG_DATA]: [
        "WEBGL_draw_buffers",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.GLSL_FRAG_DEPTH]: [
        "EXT_frag_depth",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.GLSL_DERIVATIVES]: [
        "OES_standard_derivatives",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.GLSL_TEXTURE_LOD]: [
        "EXT_shader_texture_lod",
        true
    ]
};




const $75ff6bc03ebbcaf6$var$LOG_UNSUPPORTED_FEATURE = 2;
function $75ff6bc03ebbcaf6$export$805ddaeeece0413e(gl, feature) {
    return $75ff6bc03ebbcaf6$export$990fdf4f5aca9ddb(gl, feature);
}
function $75ff6bc03ebbcaf6$export$990fdf4f5aca9ddb(gl, features) {
    features = Array.isArray(features) ? features : [
        features
    ];
    return features.every((feature)=>{
        return $75ff6bc03ebbcaf6$var$isFeatureSupported(gl, feature);
    });
}
function $75ff6bc03ebbcaf6$export$c5c8eb9e425b0de0(gl) {
    gl.luma = gl.luma || {};
    gl.luma.caps = gl.luma.caps || {};
    for(const cap in 0, $8cba87f65ded858b$export$2e2bcd8739ae039)if (gl.luma.caps[cap] === undefined) gl.luma.caps[cap] = $75ff6bc03ebbcaf6$var$isFeatureSupported(gl, cap);
    return gl.luma.caps;
}
function $75ff6bc03ebbcaf6$var$isFeatureSupported(gl, cap) {
    gl.luma = gl.luma || {};
    gl.luma.caps = gl.luma.caps || {};
    if (gl.luma.caps[cap] === undefined) gl.luma.caps[cap] = $75ff6bc03ebbcaf6$var$queryFeature(gl, cap);
    if (!gl.luma.caps[cap]) (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).log($75ff6bc03ebbcaf6$var$LOG_UNSUPPORTED_FEATURE, "Feature: ".concat(cap, " not supported"))();
    return gl.luma.caps[cap];
}
function $75ff6bc03ebbcaf6$var$queryFeature(gl, cap) {
    const feature = (0, $8cba87f65ded858b$export$2e2bcd8739ae039)[cap];
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(feature, cap);
    let isSupported;
    const featureDefinition = (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? feature[1] || feature[0] : feature[0];
    if (typeof featureDefinition === "function") isSupported = featureDefinition(gl);
    else if (Array.isArray(featureDefinition)) {
        isSupported = true;
        for (const extension of featureDefinition)isSupported = isSupported && Boolean(gl.getExtension(extension));
    } else if (typeof featureDefinition === "string") isSupported = Boolean(gl.getExtension(featureDefinition));
    else if (typeof featureDefinition === "boolean") isSupported = featureDefinition;
    else (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
    return isSupported;
}





const $a0e9e15bc57c4882$var$ERR_MULTIPLE_RENDERTARGETS = "Multiple render targets not supported";
class $a0e9e15bc57c4882$export$2e2bcd8739ae039 extends (0, $dabe379caebdf3da$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "Framebuffer";
    }
    static isSupported(gl) {
        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const { colorBufferFloat: colorBufferFloat , colorBufferHalfFloat: colorBufferHalfFloat  } = options;
        let supported = true;
        if (colorBufferFloat) supported = Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("WEBGL_color_buffer_float") || gl.getExtension("OES_texture_float"));
        if (colorBufferHalfFloat) supported = supported && Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("EXT_color_buffer_half_float"));
        return supported;
    }
    static getDefaultFramebuffer(gl) {
        gl.luma = gl.luma || {};
        gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new $a0e9e15bc57c4882$export$2e2bcd8739ae039(gl, {
            id: "default-framebuffer",
            handle: null,
            attachments: {}
        });
        return gl.luma.defaultFramebuffer;
    }
    get MAX_COLOR_ATTACHMENTS() {
        const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(this.gl);
        return gl2.getParameter(gl2.MAX_COLOR_ATTACHMENTS);
    }
    get MAX_DRAW_BUFFERS() {
        const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(this.gl);
        return gl2.getParameter(gl2.MAX_DRAW_BUFFERS);
    }
    constructor(gl){
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        super(gl, opts);
        this.width = null;
        this.height = null;
        this.attachments = {};
        this.readBuffer = 36064;
        this.drawBuffers = [
            36064
        ];
        this.ownResources = [];
        this.initialize(opts);
        Object.seal(this);
    }
    get color() {
        return this.attachments[36064] || null;
    }
    get texture() {
        return this.attachments[36064] || null;
    }
    get depth() {
        return this.attachments[36096] || this.attachments[33306] || null;
    }
    get stencil() {
        return this.attachments[36128] || this.attachments[33306] || null;
    }
    initialize(_ref) {
        let { width: width = 1 , height: height = 1 , attachments: attachments = null , color: color = true , depth: depth = true , stencil: stencil = false , check: check = true , readBuffer: readBuffer , drawBuffers: drawBuffers  } = _ref;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(width >= 0 && height >= 0, "Width and height need to be integers");
        this.width = width;
        this.height = height;
        if (attachments) for(const attachment in attachments){
            const target = attachments[attachment];
            const object = Array.isArray(target) ? target[0] : target;
            object.resize({
                width: width,
                height: height
            });
        }
        else attachments = this._createDefaultAttachments(color, depth, stencil, width, height);
        this.update({
            clearAttachments: true,
            attachments: attachments,
            readBuffer: readBuffer,
            drawBuffers: drawBuffers
        });
        if (attachments && check) this.checkStatus();
    }
    delete() {
        for (const resource of this.ownResources)resource.delete();
        super.delete();
        return this;
    }
    update(_ref2) {
        let { attachments: attachments = {} , readBuffer: readBuffer , drawBuffers: drawBuffers , clearAttachments: clearAttachments = false , resizeAttachments: resizeAttachments = true  } = _ref2;
        this.attach(attachments, {
            clearAttachments: clearAttachments,
            resizeAttachments: resizeAttachments
        });
        const { gl: gl  } = this;
        const prevHandle = gl.bindFramebuffer(36160, this.handle);
        if (readBuffer) this._setReadBuffer(readBuffer);
        if (drawBuffers) this._setDrawBuffers(drawBuffers);
        gl.bindFramebuffer(36160, prevHandle || null);
        return this;
    }
    resize() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        let { width: width , height: height  } = options;
        if (this.handle === null) {
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(width === undefined && height === undefined);
            this.width = this.gl.drawingBufferWidth;
            this.height = this.gl.drawingBufferHeight;
            return this;
        }
        if (width === undefined) width = this.gl.drawingBufferWidth;
        if (height === undefined) height = this.gl.drawingBufferHeight;
        if (width !== this.width && height !== this.height) (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(width, "x").concat(height))();
        for(const attachmentPoint in this.attachments)this.attachments[attachmentPoint].resize({
            width: width,
            height: height
        });
        this.width = width;
        this.height = height;
        return this;
    }
    attach(attachments) {
        let { clearAttachments: clearAttachments = false , resizeAttachments: resizeAttachments = true  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const newAttachments = {};
        if (clearAttachments) Object.keys(this.attachments).forEach((key)=>{
            newAttachments[key] = null;
        });
        Object.assign(newAttachments, attachments);
        const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
        for(const key1 in newAttachments){
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(key1 !== undefined, "Misspelled framebuffer binding point?");
            const attachment = Number(key1);
            const descriptor = newAttachments[attachment];
            let object = descriptor;
            if (!object) this._unattach(attachment);
            else if (object instanceof (0, $0082476f18a250b0$export$2e2bcd8739ae039)) this._attachRenderbuffer({
                attachment: attachment,
                renderbuffer: object
            });
            else if (Array.isArray(descriptor)) {
                const [texture, layer = 0, level = 0] = descriptor;
                object = texture;
                this._attachTexture({
                    attachment: attachment,
                    texture: texture,
                    layer: layer,
                    level: level
                });
            } else this._attachTexture({
                attachment: attachment,
                texture: object,
                layer: 0,
                level: 0
            });
            if (resizeAttachments && object) object.resize({
                width: this.width,
                height: this.height
            });
        }
        this.gl.bindFramebuffer(36160, prevHandle || null);
        Object.assign(this.attachments, attachments);
        Object.keys(this.attachments).filter((key)=>!this.attachments[key]).forEach((key)=>{
            delete this.attachments[key];
        });
    }
    checkStatus() {
        const { gl: gl  } = this;
        const status = this.getStatus();
        if (status !== 36053) throw new Error($a0e9e15bc57c4882$var$_getFrameBufferStatus(status));
        return this;
    }
    getStatus() {
        const { gl: gl  } = this;
        const prevHandle = gl.bindFramebuffer(36160, this.handle);
        const status = gl.checkFramebufferStatus(36160);
        gl.bindFramebuffer(36160, prevHandle || null);
        return status;
    }
    clear() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { color: color , depth: depth , stencil: stencil , drawBuffers: drawBuffers = []  } = options;
        const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
        if (color || depth || stencil) (0, $9d2da77370080708$export$42ffd38884aecdac)(this.gl, {
            color: color,
            depth: depth,
            stencil: stencil
        });
        drawBuffers.forEach((value, drawBuffer)=>{
            (0, $9d2da77370080708$export$abb0b37bc9255c0e)(this.gl, {
                drawBuffer: drawBuffer,
                value: value
            });
        });
        this.gl.bindFramebuffer(36160, prevHandle || null);
        return this;
    }
    readPixels() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).error("Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)")();
        return null;
    }
    readPixelsToBuffer() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).error("Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)")();
        return null;
    }
    copyToDataUrl() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).error("Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)")();
        return null;
    }
    copyToImage() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).error("Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)")();
        return null;
    }
    copyToTexture() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).error("Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})")();
        return null;
    }
    blit() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).error("Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)")();
        return null;
    }
    invalidate(_ref3) {
        let { attachments: attachments = [] , x: x = 0 , y: y = 0 , width: width , height: height  } = _ref3;
        const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(this.gl);
        const prevHandle = gl2.bindFramebuffer(36008, this.handle);
        const invalidateAll = x === 0 && y === 0 && width === undefined && height === undefined;
        if (invalidateAll) gl2.invalidateFramebuffer(36008, attachments);
        else gl2.invalidateFramebuffer(36008, attachments, x, y, width, height);
        gl2.bindFramebuffer(36008, prevHandle);
        return this;
    }
    getAttachmentParameter(attachment, pname, keys) {
        let value = this._getAttachmentParameterFallback(pname);
        if (value === null) {
            this.gl.bindFramebuffer(36160, this.handle);
            value = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);
            this.gl.bindFramebuffer(36160, null);
        }
        if (keys && value > 1000) value = (0, $d2f1571231f3f4d0$export$a47fb462a08de82f)(this.gl, value);
        return value;
    }
    getAttachmentParameters() {
        let attachment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 36064;
        let keys = arguments.length > 1 ? arguments[1] : undefined;
        let parameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];
        const values = {};
        for (const pname of parameters){
            const key = keys ? (0, $d2f1571231f3f4d0$export$a47fb462a08de82f)(this.gl, pname) : pname;
            values[key] = this.getAttachmentParameter(attachment, pname, keys);
        }
        return values;
    }
    getParameters() {
        let keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        const attachments = Object.keys(this.attachments);
        const parameters = {};
        for (const attachmentName of attachments){
            const attachment = Number(attachmentName);
            const key = keys ? (0, $d2f1571231f3f4d0$export$a47fb462a08de82f)(this.gl, attachment) : attachment;
            parameters[key] = this.getAttachmentParameters(attachment, keys);
        }
        return parameters;
    }
    show() {
        if (typeof window !== "undefined") window.open((0, $c192e756436d1779$export$310e97e05f1c81cc)(this), "luma-debug-texture");
        return this;
    }
    log() {
        let logLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        if (logLevel > (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).level || typeof window === "undefined") return this;
        message = message || "Framebuffer ".concat(this.id);
        const image = (0, $c192e756436d1779$export$310e97e05f1c81cc)(this, {
            targetMaxHeight: 100
        });
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).image({
            logLevel: logLevel,
            message: message,
            image: image
        }, message)();
        return this;
    }
    bind() {
        let { target: target = 36160  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.gl.bindFramebuffer(target, this.handle);
        return this;
    }
    unbind() {
        let { target: target = 36160  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.gl.bindFramebuffer(target, null);
        return this;
    }
    _createDefaultAttachments(color, depth, stencil, width, height) {
        let defaultAttachments = null;
        if (color) {
            defaultAttachments = defaultAttachments || {};
            defaultAttachments[36064] = new (0, $df31c887249e3faa$export$2e2bcd8739ae039)(this.gl, {
                id: "".concat(this.id, "-color0"),
                pixels: null,
                format: 6408,
                type: 5121,
                width: width,
                height: height,
                mipmaps: false,
                parameters: {
                    [10241]: 9729,
                    [10240]: 9729,
                    [10242]: 33071,
                    [10243]: 33071
                }
            });
            this.ownResources.push(defaultAttachments[36064]);
        }
        if (depth && stencil) {
            defaultAttachments = defaultAttachments || {};
            defaultAttachments[33306] = new (0, $0082476f18a250b0$export$2e2bcd8739ae039)(this.gl, {
                id: "".concat(this.id, "-depth-stencil"),
                format: 35056,
                width: width,
                height: 111
            });
            this.ownResources.push(defaultAttachments[33306]);
        } else if (depth) {
            defaultAttachments = defaultAttachments || {};
            defaultAttachments[36096] = new (0, $0082476f18a250b0$export$2e2bcd8739ae039)(this.gl, {
                id: "".concat(this.id, "-depth"),
                format: 33189,
                width: width,
                height: height
            });
            this.ownResources.push(defaultAttachments[36096]);
        } else if (stencil) (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
        return defaultAttachments;
    }
    _unattach(attachment) {
        const oldAttachment = this.attachments[attachment];
        if (!oldAttachment) return;
        if (oldAttachment instanceof (0, $0082476f18a250b0$export$2e2bcd8739ae039)) this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);
        else this.gl.framebufferTexture2D(36160, attachment, 3553, null, 0);
        delete this.attachments[attachment];
    }
    _attachRenderbuffer(_ref4) {
        let { attachment: attachment = 36064 , renderbuffer: renderbuffer  } = _ref4;
        const { gl: gl  } = this;
        gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);
        this.attachments[attachment] = renderbuffer;
    }
    _attachTexture(_ref5) {
        let { attachment: attachment = 36064 , texture: texture , layer: layer , level: level  } = _ref5;
        const { gl: gl  } = this;
        gl.bindTexture(texture.target, texture.handle);
        switch(texture.target){
            case 35866:
            case 32879:
                const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(gl);
                gl2.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
                break;
            case 34067:
                const face = $a0e9e15bc57c4882$var$mapIndexToCubeMapFace(layer);
                gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
                break;
            case 3553:
                gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
                break;
            default:
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false, "Illegal texture type");
        }
        gl.bindTexture(texture.target, null);
        this.attachments[attachment] = texture;
    }
    _setReadBuffer(readBuffer) {
        const gl2 = (0, $325e733792a03f4e$export$89dcfcb9130f2c28)(this.gl);
        if (gl2) gl2.readBuffer(readBuffer);
        else (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(readBuffer === 36064 || readBuffer === 1029, $a0e9e15bc57c4882$var$ERR_MULTIPLE_RENDERTARGETS);
        this.readBuffer = readBuffer;
    }
    _setDrawBuffers(drawBuffers) {
        const { gl: gl  } = this;
        const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(gl);
        if (gl2) gl2.drawBuffers(drawBuffers);
        else {
            const ext = gl.getExtension("WEBGL_draw_buffers");
            if (ext) ext.drawBuffersWEBGL(drawBuffers);
            else (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(drawBuffers.length === 1 && (drawBuffers[0] === 36064 || drawBuffers[0] === 1029), $a0e9e15bc57c4882$var$ERR_MULTIPLE_RENDERTARGETS);
        }
        this.drawBuffers = drawBuffers;
    }
    _getAttachmentParameterFallback(pname) {
        const caps = (0, $75ff6bc03ebbcaf6$export$c5c8eb9e425b0de0)(this.gl);
        switch(pname){
            case 36052:
                return !caps.WEBGL2 ? 0 : null;
            case 33298:
            case 33299:
            case 33300:
            case 33301:
            case 33302:
            case 33303:
                return !caps.WEBGL2 ? 8 : null;
            case 33297:
                return !caps.WEBGL2 ? 5125 : null;
            case 33296:
                return !caps.WEBGL2 && !caps.EXT_sRGB ? 9729 : null;
            default:
                return null;
        }
    }
    _createHandle() {
        return this.gl.createFramebuffer();
    }
    _deleteHandle() {
        this.gl.deleteFramebuffer(this.handle);
    }
    _bindHandle(handle) {
        return this.gl.bindFramebuffer(36160, handle);
    }
}
function $a0e9e15bc57c4882$var$mapIndexToCubeMapFace(layer) {
    return layer < 34069 ? layer + 34069 : layer;
}
function $a0e9e15bc57c4882$var$_getFrameBufferStatus(status) {
    const STATUS = $a0e9e15bc57c4882$export$2e2bcd8739ae039.STATUS || {};
    return STATUS[status] || "Framebuffer error ".concat(status);
}
const $a0e9e15bc57c4882$export$9bc39e54f49ae5f4 = [
    36049,
    36048,
    33296,
    33298,
    33299,
    33300,
    33301,
    33302,
    33303
];
$a0e9e15bc57c4882$export$2e2bcd8739ae039.ATTACHMENT_PARAMETERS = $a0e9e15bc57c4882$export$9bc39e54f49ae5f4;



function $379077f7c038ee76$export$a502ec217e00cfb1(refTexture, overrides) {
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(refTexture instanceof (0, $df31c887249e3faa$export$2e2bcd8739ae039) || refTexture instanceof (0, $499b8d3cccd7f89c$export$2e2bcd8739ae039) || refTexture instanceof (0, $4aa833ce3ed7a225$export$2e2bcd8739ae039));
    const TextureType = refTexture.constructor;
    const { gl: gl , width: width , height: height , format: format , type: type , dataFormat: dataFormat , border: border , mipmaps: mipmaps  } = refTexture;
    const textureOptions = Object.assign({
        width: width,
        height: height,
        format: format,
        type: type,
        dataFormat: dataFormat,
        border: border,
        mipmaps: mipmaps
    }, overrides);
    return new TextureType(gl, textureOptions);
}
function $379077f7c038ee76$export$37e0e55400e095ba(texture, opts) {
    const { gl: gl , width: width , height: height , id: id  } = texture;
    const framebuffer = new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(gl, Object.assign({}, opts, {
        id: "framebuffer-for-".concat(id),
        width: width,
        height: height,
        attachments: {
            [36064]: texture
        }
    }));
    return framebuffer;
}









const $b100fa53b681ec78$var$UNIFORM_SETTERS = {
    [5126]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform1fv", $b100fa53b681ec78$var$toFloatArray, 1, $b100fa53b681ec78$var$setVectorUniform),
    [35664]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform2fv", $b100fa53b681ec78$var$toFloatArray, 2, $b100fa53b681ec78$var$setVectorUniform),
    [35665]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform3fv", $b100fa53b681ec78$var$toFloatArray, 3, $b100fa53b681ec78$var$setVectorUniform),
    [35666]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform4fv", $b100fa53b681ec78$var$toFloatArray, 4, $b100fa53b681ec78$var$setVectorUniform),
    [5124]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform1iv", $b100fa53b681ec78$var$toIntArray, 1, $b100fa53b681ec78$var$setVectorUniform),
    [35667]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform2iv", $b100fa53b681ec78$var$toIntArray, 2, $b100fa53b681ec78$var$setVectorUniform),
    [35668]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform3iv", $b100fa53b681ec78$var$toIntArray, 3, $b100fa53b681ec78$var$setVectorUniform),
    [35669]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform4iv", $b100fa53b681ec78$var$toIntArray, 4, $b100fa53b681ec78$var$setVectorUniform),
    [35670]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform1iv", $b100fa53b681ec78$var$toIntArray, 1, $b100fa53b681ec78$var$setVectorUniform),
    [35671]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform2iv", $b100fa53b681ec78$var$toIntArray, 2, $b100fa53b681ec78$var$setVectorUniform),
    [35672]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform3iv", $b100fa53b681ec78$var$toIntArray, 3, $b100fa53b681ec78$var$setVectorUniform),
    [35673]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform4iv", $b100fa53b681ec78$var$toIntArray, 4, $b100fa53b681ec78$var$setVectorUniform),
    [35674]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniformMatrix2fv", $b100fa53b681ec78$var$toFloatArray, 4, $b100fa53b681ec78$var$setMatrixUniform),
    [35675]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniformMatrix3fv", $b100fa53b681ec78$var$toFloatArray, 9, $b100fa53b681ec78$var$setMatrixUniform),
    [35676]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniformMatrix4fv", $b100fa53b681ec78$var$toFloatArray, 16, $b100fa53b681ec78$var$setMatrixUniform),
    [35678]: $b100fa53b681ec78$var$getSamplerSetter,
    [35680]: $b100fa53b681ec78$var$getSamplerSetter,
    [5125]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform1uiv", $b100fa53b681ec78$var$toUIntArray, 1, $b100fa53b681ec78$var$setVectorUniform),
    [36294]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform2uiv", $b100fa53b681ec78$var$toUIntArray, 2, $b100fa53b681ec78$var$setVectorUniform),
    [36295]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform3uiv", $b100fa53b681ec78$var$toUIntArray, 3, $b100fa53b681ec78$var$setVectorUniform),
    [36296]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform4uiv", $b100fa53b681ec78$var$toUIntArray, 4, $b100fa53b681ec78$var$setVectorUniform),
    [35685]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniformMatrix2x3fv", $b100fa53b681ec78$var$toFloatArray, 6, $b100fa53b681ec78$var$setMatrixUniform),
    [35686]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniformMatrix2x4fv", $b100fa53b681ec78$var$toFloatArray, 8, $b100fa53b681ec78$var$setMatrixUniform),
    [35687]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniformMatrix3x2fv", $b100fa53b681ec78$var$toFloatArray, 6, $b100fa53b681ec78$var$setMatrixUniform),
    [35688]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniformMatrix3x4fv", $b100fa53b681ec78$var$toFloatArray, 12, $b100fa53b681ec78$var$setMatrixUniform),
    [35689]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniformMatrix4x2fv", $b100fa53b681ec78$var$toFloatArray, 8, $b100fa53b681ec78$var$setMatrixUniform),
    [35690]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniformMatrix4x3fv", $b100fa53b681ec78$var$toFloatArray, 12, $b100fa53b681ec78$var$setMatrixUniform),
    [35678]: $b100fa53b681ec78$var$getSamplerSetter,
    [35680]: $b100fa53b681ec78$var$getSamplerSetter,
    [35679]: $b100fa53b681ec78$var$getSamplerSetter,
    [35682]: $b100fa53b681ec78$var$getSamplerSetter,
    [36289]: $b100fa53b681ec78$var$getSamplerSetter,
    [36292]: $b100fa53b681ec78$var$getSamplerSetter,
    [36293]: $b100fa53b681ec78$var$getSamplerSetter,
    [36298]: $b100fa53b681ec78$var$getSamplerSetter,
    [36299]: $b100fa53b681ec78$var$getSamplerSetter,
    [36300]: $b100fa53b681ec78$var$getSamplerSetter,
    [36303]: $b100fa53b681ec78$var$getSamplerSetter,
    [36306]: $b100fa53b681ec78$var$getSamplerSetter,
    [36307]: $b100fa53b681ec78$var$getSamplerSetter,
    [36308]: $b100fa53b681ec78$var$getSamplerSetter,
    [36311]: $b100fa53b681ec78$var$getSamplerSetter
};
const $b100fa53b681ec78$var$FLOAT_ARRAY = {};
const $b100fa53b681ec78$var$INT_ARRAY = {};
const $b100fa53b681ec78$var$UINT_ARRAY = {};
const $b100fa53b681ec78$var$array1 = [
    0
];
function $b100fa53b681ec78$var$toTypedArray(value, uniformLength, Type, cache) {
    if (uniformLength === 1 && typeof value === "boolean") value = value ? 1 : 0;
    if (Number.isFinite(value)) {
        $b100fa53b681ec78$var$array1[0] = value;
        value = $b100fa53b681ec78$var$array1;
    }
    const length = value.length;
    if (length % uniformLength) (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("Uniform size should be multiples of ".concat(uniformLength), value)();
    if (value instanceof Type) return value;
    let result = cache[length];
    if (!result) {
        result = new Type(length);
        cache[length] = result;
    }
    for(let i = 0; i < length; i++)result[i] = value[i];
    return result;
}
function $b100fa53b681ec78$var$toFloatArray(value, uniformLength) {
    return $b100fa53b681ec78$var$toTypedArray(value, uniformLength, Float32Array, $b100fa53b681ec78$var$FLOAT_ARRAY);
}
function $b100fa53b681ec78$var$toIntArray(value, uniformLength) {
    return $b100fa53b681ec78$var$toTypedArray(value, uniformLength, Int32Array, $b100fa53b681ec78$var$INT_ARRAY);
}
function $b100fa53b681ec78$var$toUIntArray(value, uniformLength) {
    return $b100fa53b681ec78$var$toTypedArray(value, uniformLength, Uint32Array, $b100fa53b681ec78$var$UINT_ARRAY);
}
function $b100fa53b681ec78$export$c2b5b6d0be3c2cf0(gl, location, info) {
    const setter = $b100fa53b681ec78$var$UNIFORM_SETTERS[info.type];
    if (!setter) throw new Error("Unknown GLSL uniform type ".concat(info.type));
    return setter().bind(null, gl, location);
}
function $b100fa53b681ec78$export$ae5f39dc6a50a1c7(name) {
    if (name[name.length - 1] !== "]") return {
        name: name,
        length: 1,
        isArray: false
    };
    const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
    const matches = name.match(UNIFORM_NAME_REGEXP);
    if (!matches || matches.length < 2) throw new Error("Failed to parse GLSL uniform name ".concat(name));
    return {
        name: matches[1],
        length: matches[2] || 1,
        isArray: Boolean(matches[2])
    };
}
function $b100fa53b681ec78$export$c83bcc63b305493(uniforms, source, uniformMap) {
    for(const uniformName in uniforms){
        const value = uniforms[uniformName];
        const shouldCheck = !uniformMap || Boolean(uniformMap[uniformName]);
        if (shouldCheck && !$b100fa53b681ec78$var$checkUniformValue(value)) {
            source = source ? "".concat(source, " ") : "";
            console.error("".concat(source, " Bad uniform ").concat(uniformName), value);
            throw new Error("".concat(source, " Bad uniform ").concat(uniformName));
        }
    }
    return true;
}
function $b100fa53b681ec78$var$checkUniformValue(value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) return $b100fa53b681ec78$var$checkUniformArray(value);
    if (isFinite(value)) return true;
    else if (value === true || value === false) return true;
    else if (value instanceof (0, $541c007d64b391ad$export$2e2bcd8739ae039)) return true;
    else if (value instanceof (0, $0082476f18a250b0$export$2e2bcd8739ae039)) return true;
    else if (value instanceof (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)) return Boolean(value.texture);
    return false;
}
function $b100fa53b681ec78$export$5ced140387f3d289(uniforms, key, value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
        if (uniforms[key]) {
            const dest = uniforms[key];
            for(let i = 0, len = value.length; i < len; ++i)dest[i] = value[i];
        } else uniforms[key] = value.slice();
    } else uniforms[key] = value;
}
function $b100fa53b681ec78$var$checkUniformArray(value) {
    if (value.length === 0) return false;
    const checkLength = Math.min(value.length, 16);
    for(let i = 0; i < checkLength; ++i){
        if (!Number.isFinite(value[i])) return false;
    }
    return true;
}
function $b100fa53b681ec78$var$getSamplerSetter() {
    let cache = null;
    return (gl, location, value)=>{
        const update = cache !== value;
        if (update) {
            gl.uniform1i(location, value);
            cache = value;
        }
        return update;
    };
}
function $b100fa53b681ec78$var$getArraySetter(functionName, toArray, size, uniformSetter) {
    let cache = null;
    let cacheLength = null;
    return (gl, location, value)=>{
        const arrayValue = toArray(value, size);
        const length = arrayValue.length;
        let update = false;
        if (cache === null) {
            cache = new Float32Array(length);
            cacheLength = length;
            update = true;
        } else {
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(cacheLength === length, "Uniform length cannot change.");
            for(let i = 0; i < length; ++i)if (arrayValue[i] !== cache[i]) {
                update = true;
                break;
            }
        }
        if (update) {
            uniformSetter(gl, functionName, location, arrayValue);
            cache.set(arrayValue);
        }
        return update;
    };
}
function $b100fa53b681ec78$var$setVectorUniform(gl, functionName, location, value) {
    gl[functionName](location, value);
}
function $b100fa53b681ec78$var$setMatrixUniform(gl, functionName, location, value) {
    gl[functionName](location, false, value);
}



function $9ff4328555aea35a$export$2e2bcd8739ae039(shader) {
    let defaultName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "unnamed";
    const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
    const match = shader.match(SHADER_NAME_REGEXP);
    return match ? match[1] : defaultName;
}


const $29004a5c99443ec5$var$GL_FRAGMENT_SHADER = 0x8b30;
const $29004a5c99443ec5$var$GL_VERTEX_SHADER = 0x8b31;
function $29004a5c99443ec5$export$2e2bcd8739ae039(type) {
    switch(type){
        case $29004a5c99443ec5$var$GL_FRAGMENT_SHADER:
            return "fragment";
        case $29004a5c99443ec5$var$GL_VERTEX_SHADER:
            return "vertex";
        default:
            return "unknown type";
    }
}


function $014ecae11c365433$export$2e2bcd8739ae039(errLog, src, shaderType) {
    const { shaderName: shaderName , errors: errors , warnings: warnings  } = $014ecae11c365433$export$b279b0ccf17fdc42(errLog, src, shaderType);
    return "GLSL compilation error in ".concat(shaderName, "\n\n").concat(errors, "\n").concat(warnings);
}
function $014ecae11c365433$export$b279b0ccf17fdc42(errLog, src, shaderType, shaderName) {
    const errorStrings = errLog.split(/\r?\n/);
    const errors = {};
    const warnings = {};
    const name = shaderName || (0, $9ff4328555aea35a$export$2e2bcd8739ae039)(src) || "(unnamed)";
    const shaderDescription = "".concat((0, $29004a5c99443ec5$export$2e2bcd8739ae039)(shaderType), " shader ").concat(name);
    for(let i = 0; i < errorStrings.length; i++){
        const errorString = errorStrings[i];
        if (errorString.length <= 1) continue;
        const segments = errorString.split(":");
        const type = segments[0];
        const line = parseInt(segments[2], 10);
        if (isNaN(line)) throw new Error("GLSL compilation error in ".concat(shaderDescription, ": ").concat(errLog));
        if (type !== "WARNING") errors[line] = errorString;
        else warnings[line] = errorString;
    }
    const lines = $014ecae11c365433$var$addLineNumbers(src);
    return {
        shaderName: shaderDescription,
        errors: $014ecae11c365433$var$formatErrors(errors, lines),
        warnings: $014ecae11c365433$var$formatErrors(warnings, lines)
    };
}
function $014ecae11c365433$var$formatErrors(errors, lines) {
    let message = "";
    for(let i = 0; i < lines.length; i++){
        const line = lines[i];
        if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) continue;
        message += "".concat(line, "\n");
        if (errors[i + 1]) {
            const error = errors[i + 1];
            const segments = error.split(":", 3);
            const type = segments[0];
            const column = parseInt(segments[1], 10) || 0;
            const err = error.substring(segments.join(":").length + 1).trim();
            message += $014ecae11c365433$var$padLeft("^^^ ".concat(type, ": ").concat(err, "\n\n"), column);
        }
    }
    return message;
}
function $014ecae11c365433$var$addLineNumbers(string) {
    let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    let delim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ": ";
    const lines = string.split(/\r?\n/);
    const maxDigits = String(lines.length + start - 1).length;
    return lines.map((line, i)=>{
        const lineNumber = String(i + start);
        const digits = lineNumber.length;
        const prefix = $014ecae11c365433$var$padLeft(lineNumber, maxDigits - digits);
        return prefix + delim + line;
    });
}
function $014ecae11c365433$var$padLeft(string, digits) {
    let result = "";
    for(let i = 0; i < digits; ++i)result += " ";
    return "".concat(result).concat(string);
}






const $4700f6e92300c9e2$var$ERR_SOURCE = "Shader: GLSL source code must be a JavaScript string";
class $4700f6e92300c9e2$export$462bb059fed9d9e5 extends (0, $dabe379caebdf3da$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "Shader";
    }
    static getTypeName(shaderType) {
        switch(shaderType){
            case 35633:
                return "vertex-shader";
            case 35632:
                return "fragment-shader";
            default:
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
                return "unknown";
        }
    }
    constructor(gl, props){
        (0, $325e733792a03f4e$export$9b0605fd3c935712)(gl);
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(typeof props.source === "string", $4700f6e92300c9e2$var$ERR_SOURCE);
        const id = (0, $9ff4328555aea35a$export$2e2bcd8739ae039)(props.source, null) || props.id || (0, $757dc76705f498e6$export$e2a22331486dcca0)("unnamed ".concat($4700f6e92300c9e2$export$462bb059fed9d9e5.getTypeName(props.shaderType)));
        super(gl, {
            id: id
        });
        this.shaderType = props.shaderType;
        this.source = props.source;
        this.initialize(props);
    }
    initialize(_ref) {
        let { source: source  } = _ref;
        const shaderName = (0, $9ff4328555aea35a$export$2e2bcd8739ae039)(source, null);
        if (shaderName) this.id = (0, $757dc76705f498e6$export$e2a22331486dcca0)(shaderName);
        this._compile(source);
    }
    getParameter(pname) {
        return this.gl.getShaderParameter(this.handle, pname);
    }
    toString() {
        return "".concat($4700f6e92300c9e2$export$462bb059fed9d9e5.getTypeName(this.shaderType), ":").concat(this.id);
    }
    getName() {
        return (0, $9ff4328555aea35a$export$2e2bcd8739ae039)(this.source) || "unnamed-shader";
    }
    getSource() {
        return this.gl.getShaderSource(this.handle);
    }
    getTranslatedSource() {
        const extension = this.gl.getExtension("WEBGL_debug_shaders");
        return extension ? extension.getTranslatedShaderSource(this.handle) : "No translated source available. WEBGL_debug_shaders not implemented";
    }
    _compile() {
        let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.source;
        if (!source.startsWith("#version ")) source = "#version 100\n".concat(source);
        this.source = source;
        this.gl.shaderSource(this.handle, this.source);
        this.gl.compileShader(this.handle);
        const compileStatus = this.getParameter(35713);
        if (!compileStatus) {
            const infoLog = this.gl.getShaderInfoLog(this.handle);
            const { shaderName: shaderName , errors: errors , warnings: warnings  } = (0, $014ecae11c365433$export$b279b0ccf17fdc42)(infoLog, this.source, this.shaderType, this.id);
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).error("GLSL compilation errors in ".concat(shaderName, "\n").concat(errors))();
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("GLSL compilation warnings in ".concat(shaderName, "\n").concat(warnings))();
            throw new Error("GLSL compilation errors in ".concat(shaderName));
        }
    }
    _deleteHandle() {
        this.gl.deleteShader(this.handle);
    }
    _getOptsFromHandle() {
        return {
            type: this.getParameter(35663),
            source: this.getSource()
        };
    }
}
class $4700f6e92300c9e2$export$cb28509c217600d2 extends $4700f6e92300c9e2$export$462bb059fed9d9e5 {
    get [Symbol.toStringTag]() {
        return "VertexShader";
    }
    constructor(gl, props){
        if (typeof props === "string") props = {
            source: props
        };
        super(gl, Object.assign({}, props, {
            shaderType: 35633
        }));
    }
    _createHandle() {
        return this.gl.createShader(35633);
    }
}
class $4700f6e92300c9e2$export$2d38bde43c53f87a extends $4700f6e92300c9e2$export$462bb059fed9d9e5 {
    get [Symbol.toStringTag]() {
        return "FragmentShader";
    }
    constructor(gl, props){
        if (typeof props === "string") props = {
            source: props
        };
        super(gl, Object.assign({}, props, {
            shaderType: 35632
        }));
    }
    _createHandle() {
        return this.gl.createShader(35632);
    }
}





const $dd1bd7730cbb49ac$var$GL_BYTE = 0x1400;
const $dd1bd7730cbb49ac$var$GL_UNSIGNED_BYTE = 0x1401;
const $dd1bd7730cbb49ac$var$GL_SHORT = 0x1402;
const $dd1bd7730cbb49ac$var$GL_UNSIGNED_SHORT = 0x1403;
const $dd1bd7730cbb49ac$var$GL_POINTS = 0x0;
const $dd1bd7730cbb49ac$var$GL_LINES = 0x1;
const $dd1bd7730cbb49ac$var$GL_LINE_LOOP = 0x2;
const $dd1bd7730cbb49ac$var$GL_LINE_STRIP = 0x3;
const $dd1bd7730cbb49ac$var$GL_TRIANGLES = 0x4;
const $dd1bd7730cbb49ac$var$GL_TRIANGLE_STRIP = 0x5;
const $dd1bd7730cbb49ac$var$GL_TRIANGLE_FAN = 0x6;
const $dd1bd7730cbb49ac$var$GL_FLOAT = 0x1406;
const $dd1bd7730cbb49ac$var$GL_FLOAT_VEC2 = 0x8b50;
const $dd1bd7730cbb49ac$var$GL_FLOAT_VEC3 = 0x8b51;
const $dd1bd7730cbb49ac$var$GL_FLOAT_VEC4 = 0x8b52;
const $dd1bd7730cbb49ac$var$GL_INT = 0x1404;
const $dd1bd7730cbb49ac$var$GL_INT_VEC2 = 0x8b53;
const $dd1bd7730cbb49ac$var$GL_INT_VEC3 = 0x8b54;
const $dd1bd7730cbb49ac$var$GL_INT_VEC4 = 0x8b55;
const $dd1bd7730cbb49ac$var$GL_UNSIGNED_INT = 0x1405;
const $dd1bd7730cbb49ac$var$GL_UNSIGNED_INT_VEC2 = 0x8dc6;
const $dd1bd7730cbb49ac$var$GL_UNSIGNED_INT_VEC3 = 0x8dc7;
const $dd1bd7730cbb49ac$var$GL_UNSIGNED_INT_VEC4 = 0x8dc8;
const $dd1bd7730cbb49ac$var$GL_BOOL = 0x8b56;
const $dd1bd7730cbb49ac$var$GL_BOOL_VEC2 = 0x8b57;
const $dd1bd7730cbb49ac$var$GL_BOOL_VEC3 = 0x8b58;
const $dd1bd7730cbb49ac$var$GL_BOOL_VEC4 = 0x8b59;
const $dd1bd7730cbb49ac$var$GL_FLOAT_MAT2 = 0x8b5a;
const $dd1bd7730cbb49ac$var$GL_FLOAT_MAT3 = 0x8b5b;
const $dd1bd7730cbb49ac$var$GL_FLOAT_MAT4 = 0x8b5c;
const $dd1bd7730cbb49ac$var$GL_FLOAT_MAT2x3 = 0x8b65;
const $dd1bd7730cbb49ac$var$GL_FLOAT_MAT2x4 = 0x8b66;
const $dd1bd7730cbb49ac$var$GL_FLOAT_MAT3x2 = 0x8b67;
const $dd1bd7730cbb49ac$var$GL_FLOAT_MAT3x4 = 0x8b68;
const $dd1bd7730cbb49ac$var$GL_FLOAT_MAT4x2 = 0x8b69;
const $dd1bd7730cbb49ac$var$GL_FLOAT_MAT4x3 = 0x8b6a;
const $dd1bd7730cbb49ac$var$COMPOSITE_GL_TYPES = {
    [$dd1bd7730cbb49ac$var$GL_FLOAT]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        1,
        "float"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_VEC2]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        2,
        "vec2"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_VEC3]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        3,
        "vec3"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_VEC4]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        4,
        "vec4"
    ],
    [$dd1bd7730cbb49ac$var$GL_INT]: [
        $dd1bd7730cbb49ac$var$GL_INT,
        1,
        "int"
    ],
    [$dd1bd7730cbb49ac$var$GL_INT_VEC2]: [
        $dd1bd7730cbb49ac$var$GL_INT,
        2,
        "ivec2"
    ],
    [$dd1bd7730cbb49ac$var$GL_INT_VEC3]: [
        $dd1bd7730cbb49ac$var$GL_INT,
        3,
        "ivec3"
    ],
    [$dd1bd7730cbb49ac$var$GL_INT_VEC4]: [
        $dd1bd7730cbb49ac$var$GL_INT,
        4,
        "ivec4"
    ],
    [$dd1bd7730cbb49ac$var$GL_UNSIGNED_INT]: [
        $dd1bd7730cbb49ac$var$GL_UNSIGNED_INT,
        1,
        "uint"
    ],
    [$dd1bd7730cbb49ac$var$GL_UNSIGNED_INT_VEC2]: [
        $dd1bd7730cbb49ac$var$GL_UNSIGNED_INT,
        2,
        "uvec2"
    ],
    [$dd1bd7730cbb49ac$var$GL_UNSIGNED_INT_VEC3]: [
        $dd1bd7730cbb49ac$var$GL_UNSIGNED_INT,
        3,
        "uvec3"
    ],
    [$dd1bd7730cbb49ac$var$GL_UNSIGNED_INT_VEC4]: [
        $dd1bd7730cbb49ac$var$GL_UNSIGNED_INT,
        4,
        "uvec4"
    ],
    [$dd1bd7730cbb49ac$var$GL_BOOL]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        1,
        "bool"
    ],
    [$dd1bd7730cbb49ac$var$GL_BOOL_VEC2]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        2,
        "bvec2"
    ],
    [$dd1bd7730cbb49ac$var$GL_BOOL_VEC3]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        3,
        "bvec3"
    ],
    [$dd1bd7730cbb49ac$var$GL_BOOL_VEC4]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        4,
        "bvec4"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_MAT2]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        8,
        "mat2"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_MAT2x3]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        8,
        "mat2x3"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_MAT2x4]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        8,
        "mat2x4"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_MAT3]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        12,
        "mat3"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_MAT3x2]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        12,
        "mat3x2"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_MAT3x4]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        12,
        "mat3x4"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_MAT4]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        16,
        "mat4"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_MAT4x2]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        16,
        "mat4x2"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_MAT4x3]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        16,
        "mat4x3"
    ]
};
function $dd1bd7730cbb49ac$export$e50fcedcdc9b2c73(drawMode) {
    switch(drawMode){
        case $dd1bd7730cbb49ac$var$GL_POINTS:
            return $dd1bd7730cbb49ac$var$GL_POINTS;
        case $dd1bd7730cbb49ac$var$GL_LINES:
            return $dd1bd7730cbb49ac$var$GL_LINES;
        case $dd1bd7730cbb49ac$var$GL_LINE_STRIP:
            return $dd1bd7730cbb49ac$var$GL_LINES;
        case $dd1bd7730cbb49ac$var$GL_LINE_LOOP:
            return $dd1bd7730cbb49ac$var$GL_LINES;
        case $dd1bd7730cbb49ac$var$GL_TRIANGLES:
            return $dd1bd7730cbb49ac$var$GL_TRIANGLES;
        case $dd1bd7730cbb49ac$var$GL_TRIANGLE_STRIP:
            return $dd1bd7730cbb49ac$var$GL_TRIANGLES;
        case $dd1bd7730cbb49ac$var$GL_TRIANGLE_FAN:
            return $dd1bd7730cbb49ac$var$GL_TRIANGLES;
        default:
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
            return 0;
    }
}
function $dd1bd7730cbb49ac$export$eee3601b0ff4cdda(_ref) {
    let { drawMode: drawMode , vertexCount: vertexCount  } = _ref;
    switch(drawMode){
        case $dd1bd7730cbb49ac$var$GL_POINTS:
        case $dd1bd7730cbb49ac$var$GL_LINE_LOOP:
            return vertexCount;
        case $dd1bd7730cbb49ac$var$GL_LINES:
            return vertexCount / 2;
        case $dd1bd7730cbb49ac$var$GL_LINE_STRIP:
            return vertexCount - 1;
        case $dd1bd7730cbb49ac$var$GL_TRIANGLES:
            return vertexCount / 3;
        case $dd1bd7730cbb49ac$var$GL_TRIANGLE_STRIP:
        case $dd1bd7730cbb49ac$var$GL_TRIANGLE_FAN:
            return vertexCount - 2;
        default:
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
            return 0;
    }
}
function $dd1bd7730cbb49ac$export$bb010cc24ecaa644(_ref2) {
    let { drawMode: drawMode , vertexCount: vertexCount  } = _ref2;
    const primitiveCount = $dd1bd7730cbb49ac$export$eee3601b0ff4cdda({
        drawMode: drawMode,
        vertexCount: vertexCount
    });
    switch($dd1bd7730cbb49ac$export$e50fcedcdc9b2c73(drawMode)){
        case $dd1bd7730cbb49ac$var$GL_POINTS:
            return primitiveCount;
        case $dd1bd7730cbb49ac$var$GL_LINES:
            return primitiveCount * 2;
        case $dd1bd7730cbb49ac$var$GL_TRIANGLES:
            return primitiveCount * 3;
        default:
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
            return 0;
    }
}
function $dd1bd7730cbb49ac$export$646982523c4faa11(compositeGLType) {
    const typeAndSize = $dd1bd7730cbb49ac$var$COMPOSITE_GL_TYPES[compositeGLType];
    if (!typeAndSize) return null;
    const [type, components] = typeAndSize;
    return {
        type: type,
        components: components
    };
}
function $dd1bd7730cbb49ac$export$508acc40581a1522(type, components) {
    switch(type){
        case $dd1bd7730cbb49ac$var$GL_BYTE:
        case $dd1bd7730cbb49ac$var$GL_UNSIGNED_BYTE:
        case $dd1bd7730cbb49ac$var$GL_SHORT:
        case $dd1bd7730cbb49ac$var$GL_UNSIGNED_SHORT:
            type = $dd1bd7730cbb49ac$var$GL_FLOAT;
            break;
        default:
    }
    for(const glType in $dd1bd7730cbb49ac$var$COMPOSITE_GL_TYPES){
        const [compType, compComponents, name] = $dd1bd7730cbb49ac$var$COMPOSITE_GL_TYPES[glType];
        if (compType === type && compComponents === components) return {
            glType: glType,
            name: name
        };
    }
    return null;
}


class $df93dc3d9cc17a6d$export$2e2bcd8739ae039 {
    constructor(program){
        this.id = program.id;
        this.attributeInfos = [];
        this.attributeInfosByName = {};
        this.attributeInfosByLocation = [];
        this.varyingInfos = [];
        this.varyingInfosByName = {};
        Object.seal(this);
        this._readAttributesFromProgram(program);
        this._readVaryingsFromProgram(program);
    }
    getAttributeInfo(locationOrName) {
        const location = Number(locationOrName);
        if (Number.isFinite(location)) return this.attributeInfosByLocation[location];
        return this.attributeInfosByName[locationOrName] || null;
    }
    getAttributeLocation(locationOrName) {
        const attributeInfo = this.getAttributeInfo(locationOrName);
        return attributeInfo ? attributeInfo.location : -1;
    }
    getAttributeAccessor(locationOrName) {
        const attributeInfo = this.getAttributeInfo(locationOrName);
        return attributeInfo ? attributeInfo.accessor : null;
    }
    getVaryingInfo(locationOrName) {
        const location = Number(locationOrName);
        if (Number.isFinite(location)) return this.varyingInfos[location];
        return this.varyingInfosByName[locationOrName] || null;
    }
    getVaryingIndex(locationOrName) {
        const varying = this.getVaryingInfo();
        return varying ? varying.location : -1;
    }
    getVaryingAccessor(locationOrName) {
        const varying = this.getVaryingInfo();
        return varying ? varying.accessor : null;
    }
    _readAttributesFromProgram(program) {
        const { gl: gl  } = program;
        const count = gl.getProgramParameter(program.handle, 35721);
        for(let index = 0; index < count; index++){
            const { name: name , type: type , size: size  } = gl.getActiveAttrib(program.handle, index);
            const location = gl.getAttribLocation(program.handle, name);
            if (location >= 0) this._addAttribute(location, name, type, size);
        }
        this.attributeInfos.sort((a, b)=>a.location - b.location);
    }
    _readVaryingsFromProgram(program) {
        const { gl: gl  } = program;
        if (!(0, $325e733792a03f4e$export$e3518b1ac7891039)(gl)) return;
        const count = gl.getProgramParameter(program.handle, 35971);
        for(let location = 0; location < count; location++){
            const { name: name , type: type , size: size  } = gl.getTransformFeedbackVarying(program.handle, location);
            this._addVarying(location, name, type, size);
        }
        this.varyingInfos.sort((a, b)=>a.location - b.location);
    }
    _addAttribute(location, name, compositeType, size) {
        const { type: type , components: components  } = (0, $dd1bd7730cbb49ac$export$646982523c4faa11)(compositeType);
        const accessor = {
            type: type,
            size: size * components
        };
        this._inferProperties(location, name, accessor);
        const attributeInfo = {
            location: location,
            name: name,
            accessor: new (0, $905df3b590d61c61$export$2e2bcd8739ae039)(accessor)
        };
        this.attributeInfos.push(attributeInfo);
        this.attributeInfosByLocation[location] = attributeInfo;
        this.attributeInfosByName[attributeInfo.name] = attributeInfo;
    }
    _inferProperties(location, name, accessor) {
        if (/instance/i.test(name)) accessor.divisor = 1;
    }
    _addVarying(location, name, compositeType, size) {
        const { type: type , components: components  } = (0, $dd1bd7730cbb49ac$export$646982523c4faa11)(compositeType);
        const accessor = new (0, $905df3b590d61c61$export$2e2bcd8739ae039)({
            type: type,
            size: size * components
        });
        const varying = {
            location: location,
            name: name,
            accessor: accessor
        };
        this.varyingInfos.push(varying);
        this.varyingInfosByName[varying.name] = varying;
    }
}








const $6fea3ad8e77f174f$var$LOG_PROGRAM_PERF_PRIORITY = 4;
const $6fea3ad8e77f174f$var$GL_SEPARATE_ATTRIBS = 0x8c8d;
const $6fea3ad8e77f174f$var$V6_DEPRECATED_METHODS = [
    "setVertexArray",
    "setAttributes",
    "setBuffers",
    "unsetBuffers",
    "use",
    "getUniformCount",
    "getUniformInfo",
    "getUniformLocation",
    "getUniformValue",
    "getVarying",
    "getFragDataLocation",
    "getAttachedShaders",
    "getAttributeCount",
    "getAttributeLocation",
    "getAttributeInfo"
];
class $6fea3ad8e77f174f$export$2e2bcd8739ae039 extends (0, $dabe379caebdf3da$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "Program";
    }
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        super(gl, props);
        this.stubRemovedMethods("Program", "v6.0", $6fea3ad8e77f174f$var$V6_DEPRECATED_METHODS);
        this._isCached = false;
        this.initialize(props);
        Object.seal(this);
        this._setId(props.id);
    }
    initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { hash: hash , vs: vs , fs: fs , varyings: varyings , bufferMode: bufferMode = $6fea3ad8e77f174f$var$GL_SEPARATE_ATTRIBS  } = props;
        this.hash = hash || "";
        this.vs = typeof vs === "string" ? new (0, $4700f6e92300c9e2$export$cb28509c217600d2)(this.gl, {
            id: "".concat(props.id, "-vs"),
            source: vs
        }) : vs;
        this.fs = typeof fs === "string" ? new (0, $4700f6e92300c9e2$export$2d38bde43c53f87a)(this.gl, {
            id: "".concat(props.id, "-fs"),
            source: fs
        }) : fs;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(this.vs instanceof (0, $4700f6e92300c9e2$export$cb28509c217600d2));
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(this.fs instanceof (0, $4700f6e92300c9e2$export$2d38bde43c53f87a));
        this.uniforms = {};
        this._textureUniforms = {};
        if (varyings && varyings.length > 0) {
            (0, $325e733792a03f4e$export$22897d77b4bb5316)(this.gl);
            this.varyings = varyings;
            this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);
        }
        this._compileAndLink();
        this._readUniformLocationsFromLinkedProgram();
        this.configuration = new (0, $df93dc3d9cc17a6d$export$2e2bcd8739ae039)(this);
        return this.setProps(props);
    }
    delete() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (this._isCached) return this;
        return super.delete(options);
    }
    setProps(props) {
        if ("uniforms" in props) this.setUniforms(props.uniforms);
        return this;
    }
    draw(_ref) {
        let { logPriority: logPriority , drawMode: drawMode = 4 , vertexCount: vertexCount , offset: offset = 0 , start: start , end: end , isIndexed: isIndexed = false , indexType: indexType = 5123 , instanceCount: instanceCount = 0 , isInstanced: isInstanced = instanceCount > 0 , vertexArray: vertexArray = null , transformFeedback: transformFeedback , framebuffer: framebuffer , parameters: parameters = {} , uniforms: uniforms , samplers: samplers  } = _ref;
        if (uniforms || samplers) {
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).deprecated("Program.draw({uniforms})", "Program.setUniforms(uniforms)")();
            this.setUniforms(uniforms || {});
        }
        if ((0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).priority >= logPriority) {
            const fb = framebuffer ? framebuffer.id : "default";
            const message = "mode=".concat((0, $d2f1571231f3f4d0$export$a47fb462a08de82f)(this.gl, drawMode), " verts=").concat(vertexCount, " ") + "instances=".concat(instanceCount, " indexType=").concat((0, $d2f1571231f3f4d0$export$a47fb462a08de82f)(this.gl, indexType), " ") + "isInstanced=".concat(isInstanced, " isIndexed=").concat(isIndexed, " ") + "Framebuffer=".concat(fb);
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).log(logPriority, message)();
        }
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(vertexArray);
        this.gl.useProgram(this.handle);
        if (!this._areTexturesRenderable() || vertexCount === 0 || isInstanced && instanceCount === 0) return false;
        vertexArray.bindForDraw(vertexCount, instanceCount, ()=>{
            if (framebuffer !== undefined) parameters = Object.assign({}, parameters, {
                framebuffer: framebuffer
            });
            if (transformFeedback) {
                const primitiveMode = (0, $dd1bd7730cbb49ac$export$e50fcedcdc9b2c73)(drawMode);
                transformFeedback.begin(primitiveMode);
            }
            this._bindTextures();
            (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(this.gl, parameters, ()=>{
                if (isIndexed && isInstanced) this.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);
                else if (isIndexed && (0, $325e733792a03f4e$export$e3518b1ac7891039)(this.gl) && !isNaN(start) && !isNaN(end)) this.gl2.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);
                else if (isIndexed) this.gl.drawElements(drawMode, vertexCount, indexType, offset);
                else if (isInstanced) this.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);
                else this.gl.drawArrays(drawMode, offset, vertexCount);
            });
            if (transformFeedback) transformFeedback.end();
        });
        return true;
    }
    setUniforms() {
        let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if ((0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).priority >= 2) (0, $b100fa53b681ec78$export$c83bcc63b305493)(uniforms, this.id, this._uniformSetters);
        this.gl.useProgram(this.handle);
        for(const uniformName in uniforms){
            const uniform = uniforms[uniformName];
            const uniformSetter = this._uniformSetters[uniformName];
            if (uniformSetter) {
                let value = uniform;
                let textureUpdate = false;
                if (value instanceof (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)) value = value.texture;
                if (value instanceof (0, $541c007d64b391ad$export$2e2bcd8739ae039)) {
                    textureUpdate = this.uniforms[uniformName] !== uniform;
                    if (textureUpdate) {
                        if (uniformSetter.textureIndex === undefined) uniformSetter.textureIndex = this._textureIndexCounter++;
                        const texture = value;
                        const { textureIndex: textureIndex  } = uniformSetter;
                        texture.bind(textureIndex);
                        value = textureIndex;
                        this._textureUniforms[uniformName] = texture;
                    } else value = uniformSetter.textureIndex;
                } else if (this._textureUniforms[uniformName]) delete this._textureUniforms[uniformName];
                if (uniformSetter(value) || textureUpdate) (0, $b100fa53b681ec78$export$5ced140387f3d289)(this.uniforms, uniformName, uniform);
            }
        }
        return this;
    }
    _areTexturesRenderable() {
        let texturesRenderable = true;
        for(const uniformName in this._textureUniforms){
            const texture = this._textureUniforms[uniformName];
            texture.update();
            texturesRenderable = texturesRenderable && texture.loaded;
        }
        return texturesRenderable;
    }
    _bindTextures() {
        for(const uniformName in this._textureUniforms){
            const textureIndex = this._uniformSetters[uniformName].textureIndex;
            this._textureUniforms[uniformName].bind(textureIndex);
        }
    }
    _createHandle() {
        return this.gl.createProgram();
    }
    _deleteHandle() {
        this.gl.deleteProgram(this.handle);
    }
    _getOptionsFromHandle(handle) {
        const shaderHandles = this.gl.getAttachedShaders(handle);
        const opts = {};
        for (const shaderHandle of shaderHandles){
            const type = this.gl.getShaderParameter(this.handle, 35663);
            switch(type){
                case 35633:
                    opts.vs = new (0, $4700f6e92300c9e2$export$cb28509c217600d2)({
                        handle: shaderHandle
                    });
                    break;
                case 35632:
                    opts.fs = new (0, $4700f6e92300c9e2$export$2d38bde43c53f87a)({
                        handle: shaderHandle
                    });
                    break;
                default:
            }
        }
        return opts;
    }
    _getParameter(pname) {
        return this.gl.getProgramParameter(this.handle, pname);
    }
    _setId(id) {
        if (!id) {
            const programName = this._getName();
            this.id = (0, $757dc76705f498e6$export$e2a22331486dcca0)(programName);
        }
    }
    _getName() {
        let programName = this.vs.getName() || this.fs.getName();
        programName = programName.replace(/shader/i, "");
        programName = programName ? "".concat(programName, "-program") : "program";
        return programName;
    }
    _compileAndLink() {
        const { gl: gl  } = this;
        gl.attachShader(this.handle, this.vs.handle);
        gl.attachShader(this.handle, this.fs.handle);
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).time($6fea3ad8e77f174f$var$LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
        gl.linkProgram(this.handle);
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).timeEnd($6fea3ad8e77f174f$var$LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
        if (gl.debug || (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).level > 0) {
            const linked = gl.getProgramParameter(this.handle, 35714);
            if (!linked) throw new Error("Error linking: ".concat(gl.getProgramInfoLog(this.handle)));
            gl.validateProgram(this.handle);
            const validated = gl.getProgramParameter(this.handle, 35715);
            if (!validated) throw new Error("Error validating: ".concat(gl.getProgramInfoLog(this.handle)));
        }
    }
    _readUniformLocationsFromLinkedProgram() {
        const { gl: gl  } = this;
        this._uniformSetters = {};
        this._uniformCount = this._getParameter(35718);
        for(let i = 0; i < this._uniformCount; i++){
            const info = this.gl.getActiveUniform(this.handle, i);
            const { name: name  } = (0, $b100fa53b681ec78$export$ae5f39dc6a50a1c7)(info.name);
            let location = gl.getUniformLocation(this.handle, name);
            this._uniformSetters[name] = (0, $b100fa53b681ec78$export$c2b5b6d0be3c2cf0)(gl, location, info);
            if (info.size > 1) for(let l = 0; l < info.size; l++){
                location = gl.getUniformLocation(this.handle, "".concat(name, "[").concat(l, "]"));
                this._uniformSetters["".concat(name, "[").concat(l, "]")] = (0, $b100fa53b681ec78$export$c2b5b6d0be3c2cf0)(gl, location, info);
            }
        }
        this._textureIndexCounter = 0;
    }
    getActiveUniforms(uniformIndices, pname) {
        return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);
    }
    getUniformBlockIndex(blockName) {
        return this.gl2.getUniformBlockIndex(this.handle, blockName);
    }
    getActiveUniformBlockParameter(blockIndex, pname) {
        return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);
    }
    uniformBlockBinding(blockIndex, blockBinding) {
        this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);
    }
}





const $6db1ae640aab9558$var$GL_QUERY_RESULT = 0x8866;
const $6db1ae640aab9558$var$GL_QUERY_RESULT_AVAILABLE = 0x8867;
const $6db1ae640aab9558$var$GL_TIME_ELAPSED_EXT = 0x88bf;
const $6db1ae640aab9558$var$GL_GPU_DISJOINT_EXT = 0x8fbb;
const $6db1ae640aab9558$var$GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8c88;
const $6db1ae640aab9558$var$GL_ANY_SAMPLES_PASSED = 0x8c2f;
const $6db1ae640aab9558$var$GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8d6a;
class $6db1ae640aab9558$export$2e2bcd8739ae039 extends (0, $dabe379caebdf3da$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "Query";
    }
    static isSupported(gl) {
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        const webgl2 = (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl);
        const hasTimerQuery = (0, $75ff6bc03ebbcaf6$export$990fdf4f5aca9ddb)(gl, (0, $8cba87f65ded858b$export$d6a5c11f04f75862).TIMER_QUERY);
        let supported = webgl2 || hasTimerQuery;
        for (const key of opts)switch(key){
            case "queries":
                supported = supported && webgl2;
                break;
            case "timers":
                supported = supported && hasTimerQuery;
                break;
            default:
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
        }
        return supported;
    }
    constructor(gl){
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        super(gl, opts);
        this.target = null;
        this._queryPending = false;
        this._pollingPromise = null;
        Object.seal(this);
    }
    beginTimeElapsedQuery() {
        return this.begin($6db1ae640aab9558$var$GL_TIME_ELAPSED_EXT);
    }
    beginOcclusionQuery() {
        let { conservative: conservative = false  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this.begin(conservative ? $6db1ae640aab9558$var$GL_ANY_SAMPLES_PASSED_CONSERVATIVE : $6db1ae640aab9558$var$GL_ANY_SAMPLES_PASSED);
    }
    beginTransformFeedbackQuery() {
        return this.begin($6db1ae640aab9558$var$GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
    }
    begin(target) {
        if (this._queryPending) return this;
        this.target = target;
        this.gl2.beginQuery(this.target, this.handle);
        return this;
    }
    end() {
        if (this._queryPending) return this;
        if (this.target) {
            this.gl2.endQuery(this.target);
            this.target = null;
            this._queryPending = true;
        }
        return this;
    }
    isResultAvailable() {
        if (!this._queryPending) return false;
        const resultAvailable = this.gl2.getQueryParameter(this.handle, $6db1ae640aab9558$var$GL_QUERY_RESULT_AVAILABLE);
        if (resultAvailable) this._queryPending = false;
        return resultAvailable;
    }
    isTimerDisjoint() {
        return this.gl2.getParameter($6db1ae640aab9558$var$GL_GPU_DISJOINT_EXT);
    }
    getResult() {
        return this.gl2.getQueryParameter(this.handle, $6db1ae640aab9558$var$GL_QUERY_RESULT);
    }
    getTimerMilliseconds() {
        return this.getResult() / 1e6;
    }
    createPoll() {
        let limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.POSITIVE_INFINITY;
        if (this._pollingPromise) return this._pollingPromise;
        let counter = 0;
        this._pollingPromise = new Promise((resolve, reject)=>{
            const poll = ()=>{
                if (this.isResultAvailable()) {
                    resolve(this.getResult());
                    this._pollingPromise = null;
                } else if ((counter++) > limit) {
                    reject("Timed out");
                    this._pollingPromise = null;
                } else requestAnimationFrame(poll);
            };
            requestAnimationFrame(poll);
        });
        return this._pollingPromise;
    }
    _createHandle() {
        return $6db1ae640aab9558$export$2e2bcd8739ae039.isSupported(this.gl) ? this.gl2.createQuery() : null;
    }
    _deleteHandle() {
        this.gl2.deleteQuery(this.handle);
    }
}





class $feb45ae040c88295$export$2e2bcd8739ae039 extends (0, $dabe379caebdf3da$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "TransformFeedback";
    }
    static isSupported(gl) {
        return (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl);
    }
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, $325e733792a03f4e$export$22897d77b4bb5316)(gl);
        super(gl, props);
        this.initialize(props);
        this.stubRemovedMethods("TransformFeedback", "v6.0", [
            "pause",
            "resume"
        ]);
        Object.seal(this);
    }
    initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.buffers = {};
        this.unused = {};
        this.configuration = null;
        this.bindOnUse = true;
        if (!(0, $757dc76705f498e6$export$23cfe696632d10f4)(this.buffers)) this.bind(()=>this._unbindBuffers());
        this.setProps(props);
        return this;
    }
    setProps(props) {
        if ("program" in props) this.configuration = props.program && props.program.configuration;
        if ("configuration" in props) this.configuration = props.configuration;
        if ("bindOnUse" in props) props = props.bindOnUse;
        if ("buffers" in props) this.setBuffers(props.buffers);
    }
    setBuffers() {
        let buffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.bind(()=>{
            for(const bufferName in buffers)this.setBuffer(bufferName, buffers[bufferName]);
        });
        return this;
    }
    setBuffer(locationOrName, bufferOrParams) {
        const location = this._getVaryingIndex(locationOrName);
        const { buffer: buffer , byteSize: byteSize , byteOffset: byteOffset  } = this._getBufferParams(bufferOrParams);
        if (location < 0) {
            this.unused[locationOrName] = buffer;
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("".concat(this.id, " unused varying buffer ").concat(locationOrName))();
            return this;
        }
        this.buffers[location] = bufferOrParams;
        if (!this.bindOnUse) this._bindBuffer(location, buffer, byteOffset, byteSize);
        return this;
    }
    begin() {
        let primitiveMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        this.gl.bindTransformFeedback(36386, this.handle);
        this._bindBuffers();
        this.gl.beginTransformFeedback(primitiveMode);
        return this;
    }
    end() {
        this.gl.endTransformFeedback();
        this._unbindBuffers();
        this.gl.bindTransformFeedback(36386, null);
        return this;
    }
    _getBufferParams(bufferOrParams) {
        let byteOffset;
        let byteSize;
        let buffer;
        if (bufferOrParams instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039) === false) {
            buffer = bufferOrParams.buffer;
            byteSize = bufferOrParams.byteSize;
            byteOffset = bufferOrParams.byteOffset;
        } else buffer = bufferOrParams;
        if (byteOffset !== undefined || byteSize !== undefined) {
            byteOffset = byteOffset || 0;
            byteSize = byteSize || buffer.byteLength - byteOffset;
        }
        return {
            buffer: buffer,
            byteOffset: byteOffset,
            byteSize: byteSize
        };
    }
    _getVaryingInfo(locationOrName) {
        return this.configuration && this.configuration.getVaryingInfo(locationOrName);
    }
    _getVaryingIndex(locationOrName) {
        if (this.configuration) return this.configuration.getVaryingInfo(locationOrName).location;
        const location = Number(locationOrName);
        return Number.isFinite(location) ? location : -1;
    }
    _bindBuffers() {
        if (this.bindOnUse) for(const bufferIndex in this.buffers){
            const { buffer: buffer , byteSize: byteSize , byteOffset: byteOffset  } = this._getBufferParams(this.buffers[bufferIndex]);
            this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);
        }
    }
    _unbindBuffers() {
        if (this.bindOnUse) for(const bufferIndex in this.buffers)this._bindBuffer(bufferIndex, null);
    }
    _bindBuffer(index, buffer) {
        let byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        let byteSize = arguments.length > 3 ? arguments[3] : undefined;
        const handle = buffer && buffer.handle;
        if (!handle || byteSize === undefined) this.gl.bindBufferBase(35982, index, handle);
        else this.gl.bindBufferRange(35982, index, handle, byteOffset, byteSize);
        return this;
    }
    _createHandle() {
        return this.gl.createTransformFeedback();
    }
    _deleteHandle() {
        this.gl.deleteTransformFeedback(this.handle);
    }
    _bindHandle(handle) {
        this.gl.bindTransformFeedback(36386, this.handle);
    }
}







let $a28ad6f21f92ee46$var$arrayBuffer = null;
function $a28ad6f21f92ee46$export$2e3ce519f08759f7(byteLength) {
    if (!$a28ad6f21f92ee46$var$arrayBuffer || $a28ad6f21f92ee46$var$arrayBuffer.byteLength < byteLength) $a28ad6f21f92ee46$var$arrayBuffer = new ArrayBuffer(byteLength);
    return $a28ad6f21f92ee46$var$arrayBuffer;
}
function $a28ad6f21f92ee46$export$4c3ca7f6f110bd92(Type, length) {
    const scratchArrayBuffer = $a28ad6f21f92ee46$export$2e3ce519f08759f7(Type.BYTES_PER_ELEMENT * length);
    return new Type(scratchArrayBuffer, 0, length);
}
function $a28ad6f21f92ee46$export$57295b69bf9c5d15(_ref) {
    let { target: target , source: source , start: start = 0 , count: count = 1  } = _ref;
    const length = source.length;
    const total = count * length;
    let copied = 0;
    for(let i = start; copied < length; copied++)target[i++] = source[copied];
    while(copied < total)if (copied < total - copied) {
        target.copyWithin(start + copied, start, start + copied);
        copied *= 2;
    } else {
        target.copyWithin(start + copied, start, start + total - copied);
        copied = total;
    }
    return target;
}




const $585a766bd4af6d9f$var$ERR_ELEMENTS = "elements must be GL.ELEMENT_ARRAY_BUFFER";
class $585a766bd4af6d9f$export$2e2bcd8739ae039 extends (0, $dabe379caebdf3da$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "VertexArrayObject";
    }
    static isSupported(gl) {
        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if (options.constantAttributeZero) return (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) || (0, $ef7c7b0387e72f27$export$2e2bcd8739ae039)() === "Chrome";
        return true;
    }
    static getDefaultArray(gl) {
        gl.luma = gl.luma || {};
        if (!gl.luma.defaultVertexArray) gl.luma.defaultVertexArray = new $585a766bd4af6d9f$export$2e2bcd8739ae039(gl, {
            handle: null,
            isDefaultArray: true
        });
        return gl.luma.defaultVertexArray;
    }
    static getMaxAttributes(gl) {
        $585a766bd4af6d9f$export$2e2bcd8739ae039.MAX_ATTRIBUTES = $585a766bd4af6d9f$export$2e2bcd8739ae039.MAX_ATTRIBUTES || gl.getParameter(34921);
        return $585a766bd4af6d9f$export$2e2bcd8739ae039.MAX_ATTRIBUTES;
    }
    static setConstant(gl, location, array) {
        switch(array.constructor){
            case Float32Array:
                $585a766bd4af6d9f$export$2e2bcd8739ae039._setConstantFloatArray(gl, location, array);
                break;
            case Int32Array:
                $585a766bd4af6d9f$export$2e2bcd8739ae039._setConstantIntArray(gl, location, array);
                break;
            case Uint32Array:
                $585a766bd4af6d9f$export$2e2bcd8739ae039._setConstantUintArray(gl, location, array);
                break;
            default:
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
        }
    }
    constructor(gl){
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const id = opts.id || opts.program && opts.program.id;
        super(gl, Object.assign({}, opts, {
            id: id
        }));
        this.buffer = null;
        this.bufferValue = null;
        this.isDefaultArray = opts.isDefaultArray || false;
        this.gl2 = gl;
        this.initialize(opts);
        Object.seal(this);
    }
    delete() {
        super.delete();
        if (this.buffer) this.buffer.delete();
        return this;
    }
    get MAX_ATTRIBUTES() {
        return $585a766bd4af6d9f$export$2e2bcd8739ae039.getMaxAttributes(this.gl);
    }
    initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this.setProps(props);
    }
    setProps(props) {
        return this;
    }
    setElementBuffer() {
        let elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(!elementBuffer || elementBuffer.target === 34963, $585a766bd4af6d9f$var$ERR_ELEMENTS);
        this.bind(()=>{
            this.gl.bindBuffer(34963, elementBuffer ? elementBuffer.handle : null);
        });
        return this;
    }
    setBuffer(location, buffer, accessor) {
        if (buffer.target === 34963) return this.setElementBuffer(buffer, accessor);
        const { size: size , type: type , stride: stride , offset: offset , normalized: normalized , integer: integer , divisor: divisor  } = accessor;
        const { gl: gl , gl2: gl2  } = this;
        location = Number(location);
        this.bind(()=>{
            gl.bindBuffer(34962, buffer.handle);
            if (integer) {
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)((0, $325e733792a03f4e$export$e3518b1ac7891039)(gl));
                gl2.vertexAttribIPointer(location, size, type, stride, offset);
            } else gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
            gl.enableVertexAttribArray(location);
            gl2.vertexAttribDivisor(location, divisor || 0);
        });
        return this;
    }
    enable(location) {
        let enable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        const disablingAttributeZero = !enable && location === 0 && !$585a766bd4af6d9f$export$2e2bcd8739ae039.isSupported(this.gl, {
            constantAttributeZero: true
        });
        if (!disablingAttributeZero) {
            location = Number(location);
            this.bind(()=>enable ? this.gl.enableVertexAttribArray(location) : this.gl.disableVertexAttribArray(location));
        }
        return this;
    }
    getConstantBuffer(elementCount, value) {
        const constantValue = this._normalizeConstantArrayValue(value);
        const byteLength = constantValue.byteLength * elementCount;
        const length = constantValue.length * elementCount;
        let updateNeeded = !this.buffer;
        this.buffer = this.buffer || new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(this.gl, byteLength);
        updateNeeded = updateNeeded || this.buffer.reallocate(byteLength);
        updateNeeded = updateNeeded || !this._compareConstantArrayValues(constantValue, this.bufferValue);
        if (updateNeeded) {
            const typedArray = (0, $a28ad6f21f92ee46$export$4c3ca7f6f110bd92)(value.constructor, length);
            (0, $a28ad6f21f92ee46$export$57295b69bf9c5d15)({
                target: typedArray,
                source: constantValue,
                start: 0,
                count: length
            });
            this.buffer.subData(typedArray);
            this.bufferValue = value;
        }
        return this.buffer;
    }
    _normalizeConstantArrayValue(arrayValue) {
        if (Array.isArray(arrayValue)) return new Float32Array(arrayValue);
        return arrayValue;
    }
    _compareConstantArrayValues(v1, v2) {
        if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) return false;
        for(let i = 0; i < v1.length; ++i){
            if (v1[i] !== v2[i]) return false;
        }
        return true;
    }
    static _setConstantFloatArray(gl, location, array) {
        switch(array.length){
            case 1:
                gl.vertexAttrib1fv(location, array);
                break;
            case 2:
                gl.vertexAttrib2fv(location, array);
                break;
            case 3:
                gl.vertexAttrib3fv(location, array);
                break;
            case 4:
                gl.vertexAttrib4fv(location, array);
                break;
            default:
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
        }
    }
    static _setConstantIntArray(gl, location, array) {
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)((0, $325e733792a03f4e$export$e3518b1ac7891039)(gl));
        switch(array.length){
            case 1:
                gl.vertexAttribI1iv(location, array);
                break;
            case 2:
                gl.vertexAttribI2iv(location, array);
                break;
            case 3:
                gl.vertexAttribI3iv(location, array);
                break;
            case 4:
                gl.vertexAttribI4iv(location, array);
                break;
            default:
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
        }
    }
    static _setConstantUintArray(gl, location, array) {
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)((0, $325e733792a03f4e$export$e3518b1ac7891039)(gl));
        switch(array.length){
            case 1:
                gl.vertexAttribI1uiv(location, array);
                break;
            case 2:
                gl.vertexAttribI2uiv(location, array);
                break;
            case 3:
                gl.vertexAttribI3uiv(location, array);
                break;
            case 4:
                gl.vertexAttribI4uiv(location, array);
                break;
            default:
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
        }
    }
    _createHandle() {
        const gl2 = this.gl;
        return gl2.createVertexArray();
    }
    _deleteHandle(handle) {
        this.gl2.deleteVertexArray(handle);
        return [
            this.elements
        ];
    }
    _bindHandle(handle) {
        this.gl2.bindVertexArray(handle);
    }
    _getParameter(pname, _ref) {
        let { location: location  } = _ref;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(Number.isFinite(location));
        return this.bind(()=>{
            switch(pname){
                case 34373:
                    return this.gl.getVertexAttribOffset(location, pname);
                default:
                    return this.gl.getVertexAttrib(location, pname);
            }
        });
    }
}




const $012b7736d6299c03$var$ERR_ATTRIBUTE_TYPE = "VertexArray: attributes must be Buffers or constants (i.e. typed array)";
const $012b7736d6299c03$var$MULTI_LOCATION_ATTRIBUTE_REGEXP = /^(.+)__LOCATION_([0-9]+)$/;
const $012b7736d6299c03$var$DEPRECATIONS_V6 = [
    "setBuffers",
    "setGeneric",
    "clearBindings",
    "setLocations",
    "setGenericValues",
    "setDivisor",
    "enable",
    "disable"
];
class $012b7736d6299c03$export$2e2bcd8739ae039 {
    constructor(gl){
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const id = opts.id || opts.program && opts.program.id;
        this.id = id;
        this.gl = gl;
        this.configuration = null;
        this.elements = null;
        this.elementsAccessor = null;
        this.values = null;
        this.accessors = null;
        this.unused = null;
        this.drawParams = null;
        this.buffer = null;
        this.attributes = {};
        this.vertexArrayObject = new (0, $585a766bd4af6d9f$export$2e2bcd8739ae039)(gl);
        (0, $cd105bc7922a3ca2$export$5c9302507afeb7af)(this, "VertexArray", "v6.0", $012b7736d6299c03$var$DEPRECATIONS_V6);
        this.initialize(opts);
        Object.seal(this);
    }
    delete() {
        if (this.buffer) this.buffer.delete();
        this.vertexArrayObject.delete();
    }
    initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.reset();
        this.configuration = null;
        this.bindOnUse = false;
        return this.setProps(props);
    }
    reset() {
        this.elements = null;
        this.elementsAccessor = null;
        const { MAX_ATTRIBUTES: MAX_ATTRIBUTES  } = this.vertexArrayObject;
        this.values = new Array(MAX_ATTRIBUTES).fill(null);
        this.accessors = new Array(MAX_ATTRIBUTES).fill(null);
        this.unused = {};
        this.drawParams = null;
        return this;
    }
    setProps(props) {
        if ("program" in props) this.configuration = props.program && props.program.configuration;
        if ("configuration" in props) this.configuration = props.configuration;
        if ("attributes" in props) this.setAttributes(props.attributes);
        if ("elements" in props) this.setElementBuffer(props.elements);
        if ("bindOnUse" in props) props = props.bindOnUse;
        return this;
    }
    clearDrawParams() {
        this.drawParams = null;
    }
    getDrawParams() {
        this.drawParams = this.drawParams || this._updateDrawParams();
        return this.drawParams;
    }
    setAttributes(attributes) {
        Object.assign(this.attributes, attributes);
        this.vertexArrayObject.bind(()=>{
            for(const locationOrName in attributes){
                const value = attributes[locationOrName];
                this._setAttribute(locationOrName, value);
            }
            this.gl.bindBuffer(34962, null);
        });
        return this;
    }
    setElementBuffer() {
        let elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        let accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        this.elements = elementBuffer;
        this.elementsAccessor = accessor;
        this.clearDrawParams();
        this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);
        return this;
    }
    setBuffer(locationOrName, buffer) {
        let appAccessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        if (buffer.target === 34963) return this.setElementBuffer(buffer, appAccessor);
        const { location: location , accessor: accessor  } = this._resolveLocationAndAccessor(locationOrName, buffer, buffer.accessor, appAccessor);
        if (location >= 0) {
            this.values[location] = buffer;
            this.accessors[location] = accessor;
            this.clearDrawParams();
            this.vertexArrayObject.setBuffer(location, buffer, accessor);
        }
        return this;
    }
    setConstant(locationOrName, arrayValue) {
        let appAccessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        const { location: location , accessor: accessor  } = this._resolveLocationAndAccessor(locationOrName, arrayValue, Object.assign({
            size: arrayValue.length
        }, appAccessor));
        if (location >= 0) {
            arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue);
            this.values[location] = arrayValue;
            this.accessors[location] = accessor;
            this.clearDrawParams();
            this.vertexArrayObject.enable(location, false);
        }
        return this;
    }
    unbindBuffers() {
        this.vertexArrayObject.bind(()=>{
            if (this.elements) this.vertexArrayObject.setElementBuffer(null);
            this.buffer = this.buffer || new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(this.gl, {
                accessor: {
                    size: 4
                }
            });
            for(let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++)if (this.values[location] instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) {
                this.gl.disableVertexAttribArray(location);
                this.gl.bindBuffer(34962, this.buffer.handle);
                this.gl.vertexAttribPointer(location, 1, 5126, false, 0, 0);
            }
        });
        return this;
    }
    bindBuffers() {
        this.vertexArrayObject.bind(()=>{
            if (this.elements) this.setElementBuffer(this.elements);
            for(let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++){
                const buffer = this.values[location];
                if (buffer instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) this.setBuffer(location, buffer);
            }
        });
        return this;
    }
    bindForDraw(vertexCount, instanceCount, func) {
        let value;
        this.vertexArrayObject.bind(()=>{
            this._setConstantAttributes(vertexCount, instanceCount);
            value = func();
        });
        return value;
    }
    _resolveLocationAndAccessor(locationOrName, value, valueAccessor, appAccessor) {
        const INVALID_RESULT = {
            location: -1,
            accessor: null
        };
        const { location: location , name: name  } = this._getAttributeIndex(locationOrName);
        if (!Number.isFinite(location) || location < 0) {
            this.unused[locationOrName] = value;
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).once(3, ()=>"unused value ".concat(locationOrName, " in ").concat(this.id))();
            return INVALID_RESULT;
        }
        const accessInfo = this._getAttributeInfo(name || location);
        if (!accessInfo) return INVALID_RESULT;
        const currentAccessor = this.accessors[location] || {};
        const accessor = (0, $905df3b590d61c61$export$2e2bcd8739ae039).resolve(accessInfo.accessor, currentAccessor, valueAccessor, appAccessor);
        const { size: size , type: type  } = accessor;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(Number.isFinite(size) && Number.isFinite(type));
        return {
            location: location,
            accessor: accessor
        };
    }
    _getAttributeInfo(attributeName) {
        return this.configuration && this.configuration.getAttributeInfo(attributeName);
    }
    _getAttributeIndex(locationOrName) {
        const location = Number(locationOrName);
        if (Number.isFinite(location)) return {
            location: location
        };
        const multiLocation = $012b7736d6299c03$var$MULTI_LOCATION_ATTRIBUTE_REGEXP.exec(locationOrName);
        const name = multiLocation ? multiLocation[1] : locationOrName;
        const locationOffset = multiLocation ? Number(multiLocation[2]) : 0;
        if (this.configuration) return {
            location: this.configuration.getAttributeLocation(name) + locationOffset,
            name: name
        };
        return {
            location: -1
        };
    }
    _setAttribute(locationOrName, value) {
        if (value instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) this.setBuffer(locationOrName, value);
        else if (Array.isArray(value) && value.length && value[0] instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) {
            const buffer = value[0];
            const accessor = value[1];
            this.setBuffer(locationOrName, buffer, accessor);
        } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {
            const constant = value;
            this.setConstant(locationOrName, constant);
        } else if (value.buffer instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) {
            const accessor = value;
            this.setBuffer(locationOrName, accessor.buffer, accessor);
        } else throw new Error($012b7736d6299c03$var$ERR_ATTRIBUTE_TYPE);
    }
    _setConstantAttributes(vertexCount, instanceCount) {
        const elementCount = Math.max(vertexCount | 0, instanceCount | 0);
        let constant = this.values[0];
        if (ArrayBuffer.isView(constant)) this._setConstantAttributeZero(constant, elementCount);
        for(let location = 1; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++){
            constant = this.values[location];
            if (ArrayBuffer.isView(constant)) this._setConstantAttribute(location, constant);
        }
    }
    _setConstantAttributeZero(constant, elementCount) {
        if ((0, $585a766bd4af6d9f$export$2e2bcd8739ae039).isSupported(this.gl, {
            constantAttributeZero: true
        })) {
            this._setConstantAttribute(0, constant);
            return;
        }
        const buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant);
        this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);
    }
    _setConstantAttribute(location, constant) {
        (0, $585a766bd4af6d9f$export$2e2bcd8739ae039).setConstant(this.gl, location, constant);
    }
    _updateDrawParams() {
        const drawParams = {
            isIndexed: false,
            isInstanced: false,
            indexCount: Infinity,
            vertexCount: Infinity,
            instanceCount: Infinity
        };
        for(let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++)this._updateDrawParamsForLocation(drawParams, location);
        if (this.elements) {
            drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);
            drawParams.isIndexed = true;
            drawParams.indexType = this.elementsAccessor.type || this.elements.accessor.type;
            drawParams.indexOffset = this.elementsAccessor.offset || 0;
        }
        if (drawParams.indexCount === Infinity) drawParams.indexCount = 0;
        if (drawParams.vertexCount === Infinity) drawParams.vertexCount = 0;
        if (drawParams.instanceCount === Infinity) drawParams.instanceCount = 0;
        return drawParams;
    }
    _updateDrawParamsForLocation(drawParams, location) {
        const value = this.values[location];
        const accessor = this.accessors[location];
        if (!value) return;
        const { divisor: divisor  } = accessor;
        const isInstanced = divisor > 0;
        drawParams.isInstanced = drawParams.isInstanced || isInstanced;
        if (value instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) {
            const buffer = value;
            if (isInstanced) {
                const instanceCount = buffer.getVertexCount(accessor);
                drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);
            } else {
                const vertexCount = buffer.getVertexCount(accessor);
                drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);
            }
        }
    }
    setElements() {
        let elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        let accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).deprecated("setElements", "setElementBuffer")();
        return this.setElementBuffer(elementBuffer, accessor);
    }
}

function $5cc96d47f4335f1d$export$2e2bcd8739ae039(source) {
    let version = 100;
    const words = source.match(/[^\s]+/g);
    if (words.length >= 2 && words[0] === "#version") {
        const v = parseInt(words[1], 10);
        if (Number.isFinite(v)) version = v;
    }
    return version;
}


function $fe0b523f7d230853$var$formatArrayValue(v, opts) {
    const { maxElts: maxElts = 16 , size: size = 1  } = opts;
    let string = "[";
    for(let i = 0; i < v.length && i < maxElts; ++i){
        if (i > 0) string += ",".concat(i % size === 0 ? " " : "");
        string += $fe0b523f7d230853$export$7c4d25c0c3217d8c(v[i], opts);
    }
    const terminator = v.length > maxElts ? "..." : "]";
    return "".concat(string).concat(terminator);
}
function $fe0b523f7d230853$export$7c4d25c0c3217d8c(v) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const EPSILON = 1e-16;
    const { isInteger: isInteger = false  } = opts;
    if (Array.isArray(v) || ArrayBuffer.isView(v)) return $fe0b523f7d230853$var$formatArrayValue(v, opts);
    if (!Number.isFinite(v)) return String(v);
    if (Math.abs(v) < EPSILON) return isInteger ? "0" : "0.";
    if (isInteger) return v.toFixed(0);
    if (Math.abs(v) > 100 && Math.abs(v) < 10000) return v.toFixed(0);
    const string = v.toPrecision(2);
    const decimal = string.indexOf(".0");
    return decimal === string.length - 2 ? string.slice(0, -1) : string;
}


function $d325c11ca8c9db0d$export$72be64c472054e23(_ref) {
    let { header: header = "Uniforms" , program: program , uniforms: uniforms , undefinedOnly: undefinedOnly = false  } = _ref;
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(program);
    const SHADER_MODULE_UNIFORM_REGEXP = ".*_.*";
    const PROJECT_MODULE_UNIFORM_REGEXP = ".*Matrix";
    const uniformLocations = program._uniformSetters;
    const table = {};
    const uniformNames = Object.keys(uniformLocations).sort();
    let count = 0;
    for (const uniformName of uniformNames){
        if (!uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) && !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
            if ($d325c11ca8c9db0d$var$addUniformToTable({
                table: table,
                header: header,
                uniforms: uniforms,
                uniformName: uniformName,
                undefinedOnly: undefinedOnly
            })) count++;
        }
    }
    for (const uniformName1 of uniformNames){
        if (uniformName1.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
            if ($d325c11ca8c9db0d$var$addUniformToTable({
                table: table,
                header: header,
                uniforms: uniforms,
                uniformName: uniformName1,
                undefinedOnly: undefinedOnly
            })) count++;
        }
    }
    for (const uniformName2 of uniformNames){
        if (!table[uniformName2]) {
            if ($d325c11ca8c9db0d$var$addUniformToTable({
                table: table,
                header: header,
                uniforms: uniforms,
                uniformName: uniformName2,
                undefinedOnly: undefinedOnly
            })) count++;
        }
    }
    let unusedCount = 0;
    const unusedTable = {};
    if (!undefinedOnly) for(const uniformName3 in uniforms){
        const uniform = uniforms[uniformName3];
        if (!table[uniformName3]) {
            unusedCount++;
            unusedTable[uniformName3] = {
                Type: "NOT USED: ".concat(uniform),
                [header]: (0, $fe0b523f7d230853$export$7c4d25c0c3217d8c)(uniform)
            };
        }
    }
    return {
        table: table,
        count: count,
        unusedTable: unusedTable,
        unusedCount: unusedCount
    };
}
function $d325c11ca8c9db0d$var$addUniformToTable(_ref2) {
    let { table: table , header: header , uniforms: uniforms , uniformName: uniformName , undefinedOnly: undefinedOnly  } = _ref2;
    const value = uniforms[uniformName];
    const isDefined = $d325c11ca8c9db0d$var$isUniformDefined(value);
    if (!undefinedOnly || !isDefined) {
        table[uniformName] = {
            [header]: isDefined ? (0, $fe0b523f7d230853$export$7c4d25c0c3217d8c)(value) : "N/A",
            "Uniform Type": isDefined ? value : "NOT PROVIDED"
        };
        return true;
    }
    return false;
}
function $d325c11ca8c9db0d$var$isUniformDefined(value) {
    return value !== undefined && value !== null;
}





function $425f6c53ea308543$export$f05218eded921e71(_ref) {
    let { vertexArray: vertexArray , header: header = "Attributes"  } = _ref;
    if (!vertexArray.configuration) return {};
    const table = {};
    if (vertexArray.elements) table.ELEMENT_ARRAY_BUFFER = $425f6c53ea308543$var$getDebugTableRow(vertexArray, vertexArray.elements, null, header);
    const attributes = vertexArray.values;
    for(const attributeLocation in attributes){
        const info = vertexArray._getAttributeInfo(attributeLocation);
        if (info) {
            let rowHeader = "".concat(attributeLocation, ": ").concat(info.name);
            const accessor = vertexArray.accessors[info.location];
            if (accessor) rowHeader = "".concat(attributeLocation, ": ").concat($425f6c53ea308543$var$getGLSLDeclaration(info.name, accessor));
            table[rowHeader] = $425f6c53ea308543$var$getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);
        }
    }
    return table;
}
function $425f6c53ea308543$var$getDebugTableRow(vertexArray, attribute, accessor, header) {
    const { gl: gl  } = vertexArray;
    if (!attribute) return {
        [header]: "null",
        "Format ": "N/A"
    };
    let type = "NOT PROVIDED";
    let size = 1;
    let verts = 0;
    let bytes = 0;
    let isInteger;
    let marker;
    let value;
    if (accessor) {
        type = accessor.type;
        size = accessor.size;
        type = String(type).replace("Array", "");
        isInteger = type.indexOf("nt") !== -1;
    }
    if (attribute instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) {
        const buffer = attribute;
        const { data: data , changed: changed  } = buffer.getDebugData();
        marker = changed ? "*" : "";
        value = data;
        bytes = buffer.byteLength;
        verts = bytes / data.BYTES_PER_ELEMENT / size;
        let format;
        if (accessor) {
            const instanced = accessor.divisor > 0;
            format = "".concat(instanced ? "I " : "P ", " ").concat(verts, " (x").concat(size, "=").concat(bytes, " bytes ").concat((0, $d2f1571231f3f4d0$export$a47fb462a08de82f)(gl, type), ")");
        } else {
            isInteger = true;
            format = "".concat(bytes, " bytes");
        }
        return {
            [header]: "".concat(marker).concat((0, $fe0b523f7d230853$export$7c4d25c0c3217d8c)(value, {
                size: size,
                isInteger: isInteger
            })),
            "Format ": format
        };
    }
    value = attribute;
    size = attribute.length;
    type = String(attribute.constructor.name).replace("Array", "");
    isInteger = type.indexOf("nt") !== -1;
    return {
        [header]: "".concat((0, $fe0b523f7d230853$export$7c4d25c0c3217d8c)(value, {
            size: size,
            isInteger: isInteger
        }), " (constant)"),
        "Format ": "".concat(size, "x").concat(type, " (constant)")
    };
}
function $425f6c53ea308543$var$getGLSLDeclaration(name, accessor) {
    const { type: type , size: size  } = accessor;
    const typeAndName = (0, $dd1bd7730cbb49ac$export$508acc40581a1522)(type, size);
    return typeAndName ? "".concat(name, " (").concat(typeAndName.name, ")") : name;
}


function $d892712aaf8139ba$export$826103546372d55e(config) {
    const table = {};
    const header = "Accessors for ".concat(config.id);
    for (const attributeInfo of config.attributeInfos)if (attributeInfo) {
        const glslDeclaration = $d892712aaf8139ba$var$getGLSLDeclaration(attributeInfo);
        table["in ".concat(glslDeclaration)] = {
            [header]: JSON.stringify(attributeInfo.accessor)
        };
    }
    for (const varyingInfo of config.varyingInfos)if (varyingInfo) {
        const glslDeclaration = $d892712aaf8139ba$var$getGLSLDeclaration(varyingInfo);
        table["out ".concat(glslDeclaration)] = {
            [header]: JSON.stringify(varyingInfo.accessor)
        };
    }
    return table;
}
function $d892712aaf8139ba$var$getGLSLDeclaration(attributeInfo) {
    const { type: type , size: size  } = attributeInfo.accessor;
    const typeAndName = (0, $dd1bd7730cbb49ac$export$508acc40581a1522)(type, size);
    if (typeAndName) return "".concat(typeAndName.name, " ").concat(attributeInfo.name);
    return attributeInfo.name;
}





const $8a761c509fabf16c$var$isPage = (0, $58cc8c917413a7dc$export$2e2bcd8739ae039)() && typeof document !== "undefined";
let $8a761c509fabf16c$var$statIdCounter = 0;
class $8a761c509fabf16c$export$2e2bcd8739ae039 {
    constructor(){
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { onCreateContext: onCreateContext = (opts)=>(0, $f89b67ad8c6f5746$export$a32ea65c51ffebe7)(opts) , onAddHTML: onAddHTML = null , onInitialize: onInitialize = ()=>{} , onRender: onRender = ()=>{} , onFinalize: onFinalize = ()=>{} , onError: onError , gl: gl = null , glOptions: glOptions = {} , debug: debug = false , createFramebuffer: createFramebuffer = false , autoResizeViewport: autoResizeViewport = true , autoResizeDrawingBuffer: autoResizeDrawingBuffer = true , stats: stats = (0, $0a3fbec7776af5cb$export$fb95d6e12d0fb414).get("animation-loop-".concat($8a761c509fabf16c$var$statIdCounter++))  } = props;
        let { useDevicePixels: useDevicePixels = true  } = props;
        if ("useDevicePixelRatio" in props) {
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).deprecated("useDevicePixelRatio", "useDevicePixels")();
            useDevicePixels = props.useDevicePixelRatio;
        }
        this.props = {
            onCreateContext: onCreateContext,
            onAddHTML: onAddHTML,
            onInitialize: onInitialize,
            onRender: onRender,
            onFinalize: onFinalize,
            onError: onError,
            gl: gl,
            glOptions: glOptions,
            debug: debug,
            createFramebuffer: createFramebuffer
        };
        this.gl = gl;
        this.needsRedraw = null;
        this.timeline = null;
        this.stats = stats;
        this.cpuTime = this.stats.get("CPU Time");
        this.gpuTime = this.stats.get("GPU Time");
        this.frameRate = this.stats.get("Frame Rate");
        this._initialized = false;
        this._running = false;
        this._animationFrameId = null;
        this._nextFramePromise = null;
        this._resolveNextFrame = null;
        this._cpuStartTime = 0;
        this.setProps({
            autoResizeViewport: autoResizeViewport,
            autoResizeDrawingBuffer: autoResizeDrawingBuffer,
            useDevicePixels: useDevicePixels
        });
        this.start = this.start.bind(this);
        this.stop = this.stop.bind(this);
        this._pageLoadPromise = null;
        this._onMousemove = this._onMousemove.bind(this);
        this._onMouseleave = this._onMouseleave.bind(this);
    }
    delete() {
        this.stop();
        this._setDisplay(null);
    }
    setNeedsRedraw(reason) {
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(typeof reason === "string");
        this.needsRedraw = this.needsRedraw || reason;
        return this;
    }
    setProps(props) {
        if ("autoResizeViewport" in props) this.autoResizeViewport = props.autoResizeViewport;
        if ("autoResizeDrawingBuffer" in props) this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
        if ("useDevicePixels" in props) this.useDevicePixels = props.useDevicePixels;
        return this;
    }
    start() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (this._running) return this;
        this._running = true;
        const startPromise = this._getPageLoadPromise().then(()=>{
            if (!this._running || this._initialized) return null;
            this._createWebGLContext(opts);
            this._createFramebuffer();
            this._startEventHandling();
            this._initializeCallbackData();
            this._updateCallbackData();
            this._resizeCanvasDrawingBuffer();
            this._resizeViewport();
            this._gpuTimeQuery = (0, $6db1ae640aab9558$export$2e2bcd8739ae039).isSupported(this.gl, [
                "timers"
            ]) ? new (0, $6db1ae640aab9558$export$2e2bcd8739ae039)(this.gl) : null;
            this._initialized = true;
            return this.onInitialize(this.animationProps);
        }).then((appContext)=>{
            if (this._running) {
                this._addCallbackData(appContext || {});
                if (appContext !== false) this._startLoop();
            }
        });
        if (this.props.onError) startPromise.catch(this.props.onError);
        return this;
    }
    redraw() {
        if (this.isContextLost()) return this;
        this._beginTimers();
        this._setupFrame();
        this._updateCallbackData();
        this._renderFrame(this.animationProps);
        this._clearNeedsRedraw();
        if (this.offScreen && this.gl.commit) this.gl.commit();
        if (this._resolveNextFrame) {
            this._resolveNextFrame(this);
            this._nextFramePromise = null;
            this._resolveNextFrame = null;
        }
        this._endTimers();
        return this;
    }
    stop() {
        if (this._running) {
            this._finalizeCallbackData();
            this._cancelAnimationFrame(this._animationFrameId);
            this._nextFramePromise = null;
            this._resolveNextFrame = null;
            this._animationFrameId = null;
            this._running = false;
        }
        return this;
    }
    attachTimeline(timeline) {
        this.timeline = timeline;
        return this.timeline;
    }
    detachTimeline() {
        this.timeline = null;
    }
    waitForRender() {
        this.setNeedsRedraw("waitForRender");
        if (!this._nextFramePromise) this._nextFramePromise = new Promise((resolve)=>{
            this._resolveNextFrame = resolve;
        });
        return this._nextFramePromise;
    }
    async toDataURL() {
        this.setNeedsRedraw("toDataURL");
        await this.waitForRender();
        return this.gl.canvas.toDataURL();
    }
    isContextLost() {
        return this.gl.isContextLost();
    }
    onCreateContext() {
        return this.props.onCreateContext(...arguments);
    }
    onInitialize() {
        return this.props.onInitialize(...arguments);
    }
    onRender() {
        return this.props.onRender(...arguments);
    }
    onFinalize() {
        return this.props.onFinalize(...arguments);
    }
    getHTMLControlValue(id) {
        let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        const element = document.getElementById(id);
        return element ? Number(element.value) : defaultValue;
    }
    setViewParameters() {
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).removed("AnimationLoop.setViewParameters", "AnimationLoop.setProps")();
        return this;
    }
    _startLoop() {
        const renderFrame = ()=>{
            if (!this._running) return;
            this.redraw();
            this._animationFrameId = this._requestAnimationFrame(renderFrame);
        };
        this._cancelAnimationFrame(this._animationFrameId);
        this._animationFrameId = this._requestAnimationFrame(renderFrame);
    }
    _getPageLoadPromise() {
        if (!this._pageLoadPromise) this._pageLoadPromise = $8a761c509fabf16c$var$isPage ? new Promise((resolve, reject)=>{
            if ($8a761c509fabf16c$var$isPage && document.readyState === "complete") {
                resolve(document);
                return;
            }
            window.addEventListener("load", ()=>{
                resolve(document);
            });
        }) : Promise.resolve({});
        return this._pageLoadPromise;
    }
    _setDisplay(display) {
        if (this.display) {
            this.display.delete();
            this.display.animationLoop = null;
        }
        if (display) display.animationLoop = this;
        this.display = display;
    }
    _cancelAnimationFrame(animationFrameId) {
        if (this.display && this.display.cancelAnimationFrame) return this.display.cancelAnimationFrame(animationFrameId);
        return (0, $cb3c1c602b31e96d$export$e00521de187a817a)(animationFrameId);
    }
    _requestAnimationFrame(renderFrameCallback) {
        if (this._running) {
            if (this.display && this.display.requestAnimationFrame) return this.display.requestAnimationFrame(renderFrameCallback);
            return (0, $cb3c1c602b31e96d$export$6cb2c4c0a22909c0)(renderFrameCallback);
        }
        return undefined;
    }
    _renderFrame() {
        if (this.display) {
            this.display._renderFrame(...arguments);
            return;
        }
        this.onRender(...arguments);
    }
    _clearNeedsRedraw() {
        this.needsRedraw = null;
    }
    _setupFrame() {
        this._resizeCanvasDrawingBuffer();
        this._resizeViewport();
        this._resizeFramebuffer();
    }
    _initializeCallbackData() {
        this.animationProps = {
            gl: this.gl,
            stop: this.stop,
            canvas: this.gl.canvas,
            framebuffer: this.framebuffer,
            useDevicePixels: this.useDevicePixels,
            needsRedraw: null,
            startTime: Date.now(),
            engineTime: 0,
            tick: 0,
            tock: 0,
            time: 0,
            _timeline: this.timeline,
            _loop: this,
            _animationLoop: this,
            _mousePosition: null
        };
    }
    _updateCallbackData() {
        const { width: width , height: height , aspect: aspect  } = this._getSizeAndAspect();
        if (width !== this.animationProps.width || height !== this.animationProps.height) this.setNeedsRedraw("drawing buffer resized");
        if (aspect !== this.animationProps.aspect) this.setNeedsRedraw("drawing buffer aspect changed");
        this.animationProps.width = width;
        this.animationProps.height = height;
        this.animationProps.aspect = aspect;
        this.animationProps.needsRedraw = this.needsRedraw;
        this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
        if (this.timeline) this.timeline.update(this.animationProps.engineTime);
        this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);
        this.animationProps.tock++;
        this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
        this.animationProps._offScreen = this.offScreen;
    }
    _finalizeCallbackData() {
        this.onFinalize(this.animationProps);
    }
    _addCallbackData(appContext) {
        if (typeof appContext === "object" && appContext !== null) this.animationProps = Object.assign({}, this.animationProps, appContext);
    }
    _createWebGLContext(opts) {
        this.offScreen = opts.canvas && typeof OffscreenCanvas !== "undefined" && opts.canvas instanceof OffscreenCanvas;
        opts = Object.assign({}, opts, this.props.glOptions);
        this.gl = this.props.gl ? (0, $f89b67ad8c6f5746$export$6b6cef073fe6a207)(this.props.gl, opts) : this.onCreateContext(opts);
        if (!(0, $325e733792a03f4e$export$3a471d0dd6792be6)(this.gl)) throw new Error("AnimationLoop.onCreateContext - illegal context returned");
        (0, $54220aa8b6471f1a$export$2ee1427ea70eaaab)(this.gl);
        this._createInfoDiv();
    }
    _createInfoDiv() {
        if (this.gl.canvas && this.props.onAddHTML) {
            const wrapperDiv = document.createElement("div");
            document.body.appendChild(wrapperDiv);
            wrapperDiv.style.position = "relative";
            const div = document.createElement("div");
            div.style.position = "absolute";
            div.style.left = "10px";
            div.style.bottom = "10px";
            div.style.width = "300px";
            div.style.background = "white";
            wrapperDiv.appendChild(this.gl.canvas);
            wrapperDiv.appendChild(div);
            const html = this.props.onAddHTML(div);
            if (html) div.innerHTML = html;
        }
    }
    _getSizeAndAspect() {
        const width = this.gl.drawingBufferWidth;
        const height = this.gl.drawingBufferHeight;
        let aspect = 1;
        const { canvas: canvas  } = this.gl;
        if (canvas && canvas.clientHeight) aspect = canvas.clientWidth / canvas.clientHeight;
        else if (width > 0 && height > 0) aspect = width / height;
        return {
            width: width,
            height: height,
            aspect: aspect
        };
    }
    _resizeViewport() {
        if (this.autoResizeViewport) this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
    }
    _resizeCanvasDrawingBuffer() {
        if (this.autoResizeDrawingBuffer) (0, $f89b67ad8c6f5746$export$4ed444b69b8944fd)(this.gl, {
            useDevicePixels: this.useDevicePixels
        });
    }
    _createFramebuffer() {
        if (this.props.createFramebuffer) this.framebuffer = new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(this.gl);
    }
    _resizeFramebuffer() {
        if (this.framebuffer) this.framebuffer.resize({
            width: this.gl.drawingBufferWidth,
            height: this.gl.drawingBufferHeight
        });
    }
    _beginTimers() {
        this.frameRate.timeEnd();
        this.frameRate.timeStart();
        if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) this.stats.get("GPU Time").addTime(this._gpuTimeQuery.getTimerMilliseconds());
        if (this._gpuTimeQuery) this._gpuTimeQuery.beginTimeElapsedQuery();
        this.cpuTime.timeStart();
    }
    _endTimers() {
        this.cpuTime.timeEnd();
        if (this._gpuTimeQuery) this._gpuTimeQuery.end();
    }
    _startEventHandling() {
        const { canvas: canvas  } = this.gl;
        if (canvas) {
            canvas.addEventListener("mousemove", this._onMousemove);
            canvas.addEventListener("mouseleave", this._onMouseleave);
        }
    }
    _onMousemove(e) {
        this.animationProps._mousePosition = [
            e.offsetX,
            e.offsetY
        ];
    }
    _onMouseleave(e) {
        this.animationProps._mousePosition = null;
    }
}


const $23d7a12f17d9f134$export$9abae82e87f5416d = "vs";
const $23d7a12f17d9f134$export$71cb6c7fe82525af = "fs";


function $72fc9985edf189bb$export$2e2bcd8739ae039(condition, message) {
    if (!condition) throw new Error(message || "shadertools: assertion failed.");
}



const $2692d3bb490bbb66$var$TYPE_DEFINITIONS = {
    number: {
        validate (value, propType) {
            return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
        }
    },
    array: {
        validate (value, propType) {
            return Array.isArray(value) || ArrayBuffer.isView(value);
        }
    }
};
function $2692d3bb490bbb66$export$6335b16489944934(propDefs) {
    const propTypes = {};
    for(const propName in propDefs){
        const propDef = propDefs[propName];
        const propType = $2692d3bb490bbb66$var$parsePropType(propDef);
        propTypes[propName] = propType;
    }
    return propTypes;
}
function $2692d3bb490bbb66$var$parsePropType(propDef) {
    let type = $2692d3bb490bbb66$var$getTypeOf(propDef);
    if (type === "object") {
        if (!propDef) return {
            type: "object",
            value: null
        };
        if ("type" in propDef) return Object.assign({}, propDef, $2692d3bb490bbb66$var$TYPE_DEFINITIONS[propDef.type]);
        if (!("value" in propDef)) return {
            type: "object",
            value: propDef
        };
        type = $2692d3bb490bbb66$var$getTypeOf(propDef.value);
        return Object.assign({
            type: type
        }, propDef, $2692d3bb490bbb66$var$TYPE_DEFINITIONS[type]);
    }
    return Object.assign({
        type: type,
        value: propDef
    }, $2692d3bb490bbb66$var$TYPE_DEFINITIONS[type]);
}
function $2692d3bb490bbb66$var$getTypeOf(value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) return "array";
    return typeof value;
}


const $f3f714d708c06682$var$VERTEX_SHADER = "vs";
const $f3f714d708c06682$var$FRAGMENT_SHADER = "fs";
class $f3f714d708c06682$export$2e2bcd8739ae039 {
    constructor(_ref){
        let { name: name , vs: vs , fs: fs , dependencies: dependencies = [] , uniforms: uniforms , getUniforms: getUniforms , deprecations: deprecations = [] , defines: defines = {} , inject: inject = {} , vertexShader: vertexShader , fragmentShader: fragmentShader  } = _ref;
        (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(typeof name === "string");
        this.name = name;
        this.vs = vs || vertexShader;
        this.fs = fs || fragmentShader;
        this.getModuleUniforms = getUniforms;
        this.dependencies = dependencies;
        this.deprecations = this._parseDeprecationDefinitions(deprecations);
        this.defines = defines;
        this.injections = $f3f714d708c06682$var$normalizeInjections(inject);
        if (uniforms) this.uniforms = (0, $2692d3bb490bbb66$export$6335b16489944934)(uniforms);
    }
    getModuleSource(type) {
        let moduleSource;
        switch(type){
            case $f3f714d708c06682$var$VERTEX_SHADER:
                moduleSource = this.vs || "";
                break;
            case $f3f714d708c06682$var$FRAGMENT_SHADER:
                moduleSource = this.fs || "";
                break;
            default:
                (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(false);
        }
        return "#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_"), "\n").concat(moduleSource, "// END MODULE_").concat(this.name, "\n\n");
    }
    getUniforms(opts, uniforms) {
        if (this.getModuleUniforms) return this.getModuleUniforms(opts, uniforms);
        if (this.uniforms) return this._defaultGetUniforms(opts);
        return {};
    }
    getDefines() {
        return this.defines;
    }
    checkDeprecations(shaderSource, log) {
        this.deprecations.forEach((def)=>{
            if (def.regex.test(shaderSource)) {
                if (def.deprecated) log.deprecated(def.old, def.new)();
                else log.removed(def.old, def.new)();
            }
        });
    }
    _parseDeprecationDefinitions(deprecations) {
        deprecations.forEach((def)=>{
            switch(def.type){
                case "function":
                    def.regex = new RegExp("\\b".concat(def.old, "\\("));
                    break;
                default:
                    def.regex = new RegExp("".concat(def.type, " ").concat(def.old, ";"));
            }
        });
        return deprecations;
    }
    _defaultGetUniforms() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const uniforms = {};
        const propTypes = this.uniforms;
        for(const key in propTypes){
            const propDef = propTypes[key];
            if (key in opts && !propDef.private) {
                if (propDef.validate) (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(propDef.validate(opts[key], propDef), "".concat(this.name, ": invalid ").concat(key));
                uniforms[key] = opts[key];
            } else uniforms[key] = propDef.value;
        }
        return uniforms;
    }
}
function $f3f714d708c06682$export$68c1c1f4f5c924cc(module) {
    if (!module.normalized) {
        module.normalized = true;
        if (module.uniforms && !module.getUniforms) {
            const shaderModule = new $f3f714d708c06682$export$2e2bcd8739ae039(module);
            module.getUniforms = shaderModule.getUniforms.bind(shaderModule);
        }
    }
    return module;
}
function $f3f714d708c06682$var$normalizeInjections(injections) {
    const result = {
        vs: {},
        fs: {}
    };
    for(const hook in injections){
        let injection = injections[hook];
        const stage = hook.slice(0, 2);
        if (typeof injection === "string") injection = {
            order: 0,
            injection: injection
        };
        result[stage][hook] = injection;
    }
    return result;
}



function $b48d7b90009bb09d$export$85f943437bcc1df(modules) {
    return $b48d7b90009bb09d$var$getShaderDependencies($b48d7b90009bb09d$var$instantiateModules(modules));
}
function $b48d7b90009bb09d$var$getShaderDependencies(modules) {
    const moduleMap = {};
    const moduleDepth = {};
    $b48d7b90009bb09d$var$getDependencyGraph({
        modules: modules,
        level: 0,
        moduleMap: moduleMap,
        moduleDepth: moduleDepth
    });
    return Object.keys(moduleDepth).sort((a, b)=>moduleDepth[b] - moduleDepth[a]).map((name)=>moduleMap[name]);
}
function $b48d7b90009bb09d$var$getDependencyGraph(_ref) {
    let { modules: modules , level: level , moduleMap: moduleMap , moduleDepth: moduleDepth  } = _ref;
    if (level >= 5) throw new Error("Possible loop in shader dependency graph");
    for (const module of modules){
        moduleMap[module.name] = module;
        if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) moduleDepth[module.name] = level;
    }
    for (const module1 of modules)if (module1.dependencies) $b48d7b90009bb09d$var$getDependencyGraph({
        modules: module1.dependencies,
        level: level + 1,
        moduleMap: moduleMap,
        moduleDepth: moduleDepth
    });
}
function $b48d7b90009bb09d$var$instantiateModules(modules, seen) {
    return modules.map((module)=>{
        if (module instanceof (0, $f3f714d708c06682$export$2e2bcd8739ae039)) return module;
        (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(typeof module !== "string", "Shader module use by name is deprecated. Import shader module '".concat(module, "' and use it directly."));
        (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(module.name, "shader module has no name");
        module = new (0, $f3f714d708c06682$export$2e2bcd8739ae039)(module);
        module.dependencies = $b48d7b90009bb09d$var$instantiateModules(module.dependencies);
        return module;
    });
}
const $b48d7b90009bb09d$export$b63c82f0e67dfc21 = {
    getShaderDependencies: $b48d7b90009bb09d$var$getShaderDependencies,
    getDependencyGraph: $b48d7b90009bb09d$var$getDependencyGraph
};


function $3020e6049f10c7c7$export$2e2bcd8739ae039() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const navigator = typeof window !== "undefined" ? window.navigator || {} : {};
    const userAgent = opts.userAgent || navigator.userAgent || "";
    const isMSIE = userAgent.indexOf("MSIE ") !== -1;
    const isTrident = userAgent.indexOf("Trident/") !== -1;
    return isMSIE || isTrident;
}



const $56722cd4a954f9d7$var$GL_VENDOR = 0x1f00;
const $56722cd4a954f9d7$var$GL_RENDERER = 0x1f01;
const $56722cd4a954f9d7$var$GL_VERSION = 0x1f02;
const $56722cd4a954f9d7$var$GL_SHADING_LANGUAGE_VERSION = 0x8b8c;
const $56722cd4a954f9d7$var$WEBGL_FEATURES = {
    GLSL_FRAG_DATA: [
        "WEBGL_draw_buffers",
        true
    ],
    GLSL_FRAG_DEPTH: [
        "EXT_frag_depth",
        true
    ],
    GLSL_DERIVATIVES: [
        "OES_standard_derivatives",
        true
    ],
    GLSL_TEXTURE_LOD: [
        "EXT_shader_texture_lod",
        true
    ]
};
const $56722cd4a954f9d7$export$d6a5c11f04f75862 = {};
Object.keys($56722cd4a954f9d7$var$WEBGL_FEATURES).forEach((key)=>{
    $56722cd4a954f9d7$export$d6a5c11f04f75862[key] = key;
});
function $56722cd4a954f9d7$var$isWebGL2(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) return true;
    return Boolean(gl && gl._version === 2);
}
function $56722cd4a954f9d7$export$906f0ebe0848c767(gl) {
    const info = gl.getExtension("WEBGL_debug_renderer_info");
    const vendor = gl.getParameter(info && info.UNMASKED_VENDOR_WEBGL || $56722cd4a954f9d7$var$GL_VENDOR);
    const renderer = gl.getParameter(info && info.UNMASKED_RENDERER_WEBGL || $56722cd4a954f9d7$var$GL_RENDERER);
    const gpuVendor = $56722cd4a954f9d7$var$identifyGPUVendor(vendor, renderer);
    const gpuInfo = {
        gpuVendor: gpuVendor,
        vendor: vendor,
        renderer: renderer,
        version: gl.getParameter($56722cd4a954f9d7$var$GL_VERSION),
        shadingLanguageVersion: gl.getParameter($56722cd4a954f9d7$var$GL_SHADING_LANGUAGE_VERSION)
    };
    return gpuInfo;
}
function $56722cd4a954f9d7$var$identifyGPUVendor(vendor, renderer) {
    if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) return "NVIDIA";
    if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) return "INTEL";
    if (vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i)) return "AMD";
    return "UNKNOWN GPU";
}
const $56722cd4a954f9d7$var$compiledGlslExtensions = {};
function $56722cd4a954f9d7$export$e5033c6f31304d8c(gl, cap) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const feature = $56722cd4a954f9d7$var$WEBGL_FEATURES[cap];
    (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(feature, cap);
    if (!(0, $3020e6049f10c7c7$export$2e2bcd8739ae039)(opts)) return true;
    if (cap in $56722cd4a954f9d7$var$compiledGlslExtensions) return $56722cd4a954f9d7$var$compiledGlslExtensions[cap];
    const extensionName = feature[0];
    const behavior = opts.behavior || "enable";
    const source = "#extension GL_".concat(extensionName, " : ").concat(behavior, "\nvoid main(void) {}");
    const shader = gl.createShader(35633);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    const canCompile = gl.getShaderParameter(shader, 35713);
    gl.deleteShader(shader);
    $56722cd4a954f9d7$var$compiledGlslExtensions[cap] = canCompile;
    return canCompile;
}
function $56722cd4a954f9d7$var$getFeature(gl, cap) {
    const feature = $56722cd4a954f9d7$var$WEBGL_FEATURES[cap];
    (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(feature, cap);
    const extensionName = $56722cd4a954f9d7$var$isWebGL2(gl) ? feature[1] || feature[0] : feature[0];
    const value = typeof extensionName === "string" ? Boolean(gl.getExtension(extensionName)) : extensionName;
    (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(value === false || value === true);
    return value;
}
function $56722cd4a954f9d7$export$990fdf4f5aca9ddb(gl, features) {
    features = Array.isArray(features) ? features : [
        features
    ];
    return features.every((feature)=>$56722cd4a954f9d7$var$getFeature(gl, feature));
}


function $2fbefa35cddc42a2$export$2c56069b1b5c9cc2(gl) {
    const debugInfo = (0, $56722cd4a954f9d7$export$906f0ebe0848c767)(gl);
    switch(debugInfo.gpuVendor.toLowerCase()){
        case "nvidia":
            return "#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";
        case "intel":
            return "#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
        case "amd":
            return "#define AMD_GPU\n";
        default:
            return "#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
    }
}
function $2fbefa35cddc42a2$export$e7726ded64e86312(gl, glslVersion, isFragment) {
    let versionDefines = "#if (__VERSION__ > 120)\n\n# define FEATURE_GLSL_DERIVATIVES\n# define FEATURE_GLSL_DRAW_BUFFERS\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FEATURE_GLSL_TEXTURE_LOD\n\n// DEPRECATED FLAGS, remove in v9\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";
    if ((0, $56722cd4a954f9d7$export$990fdf4f5aca9ddb)(gl, (0, $56722cd4a954f9d7$export$d6a5c11f04f75862).GLSL_FRAG_DEPTH)) versionDefines += "\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n";
    if ((0, $56722cd4a954f9d7$export$990fdf4f5aca9ddb)(gl, (0, $56722cd4a954f9d7$export$d6a5c11f04f75862).GLSL_DERIVATIVES) && (0, $56722cd4a954f9d7$export$e5033c6f31304d8c)(gl, (0, $56722cd4a954f9d7$export$d6a5c11f04f75862).GLSL_DERIVATIVES)) versionDefines += "\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n";
    if ((0, $56722cd4a954f9d7$export$990fdf4f5aca9ddb)(gl, (0, $56722cd4a954f9d7$export$d6a5c11f04f75862).GLSL_FRAG_DATA) && (0, $56722cd4a954f9d7$export$e5033c6f31304d8c)(gl, (0, $56722cd4a954f9d7$export$d6a5c11f04f75862).GLSL_FRAG_DATA, {
        behavior: "require"
    })) versionDefines += "\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n";
    if ((0, $56722cd4a954f9d7$export$990fdf4f5aca9ddb)(gl, (0, $56722cd4a954f9d7$export$d6a5c11f04f75862).GLSL_TEXTURE_LOD)) versionDefines += "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n";
    return versionDefines;
}


const $06b8554819c1cfcf$export$1c7c27df7700ab1e = "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n";
const $06b8554819c1cfcf$export$eb0c6f0420228c53 = "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n";




const $e03481e8f5a496cf$var$MODULE_INJECTORS = {
    [(0, $23d7a12f17d9f134$export$9abae82e87f5416d)]: (0, $06b8554819c1cfcf$export$1c7c27df7700ab1e),
    [(0, $23d7a12f17d9f134$export$71cb6c7fe82525af)]: (0, $06b8554819c1cfcf$export$eb0c6f0420228c53)
};
const $e03481e8f5a496cf$export$62f6e317489649e6 = "__LUMA_INJECT_DECLARATIONS__";
const $e03481e8f5a496cf$var$REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
const $e03481e8f5a496cf$var$REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
const $e03481e8f5a496cf$var$fragments = [];
function $e03481e8f5a496cf$export$2e2bcd8739ae039(source, type, inject) {
    let injectStandardStubs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    const isVertex = type === (0, $23d7a12f17d9f134$export$9abae82e87f5416d);
    for(const key in inject){
        const fragmentData = inject[key];
        fragmentData.sort((a, b)=>a.order - b.order);
        $e03481e8f5a496cf$var$fragments.length = fragmentData.length;
        for(let i = 0, len = fragmentData.length; i < len; ++i)$e03481e8f5a496cf$var$fragments[i] = fragmentData[i].injection;
        const fragmentString = "".concat($e03481e8f5a496cf$var$fragments.join("\n"), "\n");
        switch(key){
            case "vs:#decl":
                if (isVertex) source = source.replace($e03481e8f5a496cf$export$62f6e317489649e6, fragmentString);
                break;
            case "vs:#main-start":
                if (isVertex) source = source.replace($e03481e8f5a496cf$var$REGEX_START_OF_MAIN, (match)=>match + fragmentString);
                break;
            case "vs:#main-end":
                if (isVertex) source = source.replace($e03481e8f5a496cf$var$REGEX_END_OF_MAIN, (match)=>fragmentString + match);
                break;
            case "fs:#decl":
                if (!isVertex) source = source.replace($e03481e8f5a496cf$export$62f6e317489649e6, fragmentString);
                break;
            case "fs:#main-start":
                if (!isVertex) source = source.replace($e03481e8f5a496cf$var$REGEX_START_OF_MAIN, (match)=>match + fragmentString);
                break;
            case "fs:#main-end":
                if (!isVertex) source = source.replace($e03481e8f5a496cf$var$REGEX_END_OF_MAIN, (match)=>fragmentString + match);
                break;
            default:
                source = source.replace(key, (match)=>match + fragmentString);
        }
    }
    source = source.replace($e03481e8f5a496cf$export$62f6e317489649e6, "");
    if (injectStandardStubs) source = source.replace(/\}\s*$/, (match)=>match + $e03481e8f5a496cf$var$MODULE_INJECTORS[type]);
    return source;
}
function $e03481e8f5a496cf$export$cef13ee8fb8f32f3(injects) {
    const result = {};
    (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(Array.isArray(injects) && injects.length > 1);
    injects.forEach((inject)=>{
        for(const key in inject)result[key] = result[key] ? "".concat(result[key], "\n").concat(inject[key]) : inject[key];
    });
    return result;
}


function $0a454f71c6acc901$var$testVariable(qualifier) {
    return new RegExp("\\b".concat(qualifier, "[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)"), "g");
}
const $0a454f71c6acc901$var$ES300_REPLACEMENTS = [
    [
        /^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/,
        "#version 300 es\n"
    ],
    [
        /\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g,
        "textureLod("
    ],
    [
        /\btexture(2D|2DProj|Cube)(EXT)?\(/g,
        "texture("
    ]
];
const $0a454f71c6acc901$var$ES300_VERTEX_REPLACEMENTS = [
    ...$0a454f71c6acc901$var$ES300_REPLACEMENTS,
    [
        $0a454f71c6acc901$var$testVariable("attribute"),
        "in $1"
    ],
    [
        $0a454f71c6acc901$var$testVariable("varying"),
        "out $1"
    ]
];
const $0a454f71c6acc901$var$ES300_FRAGMENT_REPLACEMENTS = [
    ...$0a454f71c6acc901$var$ES300_REPLACEMENTS,
    [
        $0a454f71c6acc901$var$testVariable("varying"),
        "in $1"
    ]
];
const $0a454f71c6acc901$var$ES100_REPLACEMENTS = [
    [
        /^#version[ \t]+300[ \t]+es/,
        "#version 100"
    ],
    [
        /\btexture(2D|2DProj|Cube)Lod\(/g,
        "texture$1LodEXT("
    ],
    [
        /\btexture\(/g,
        "texture2D("
    ],
    [
        /\btextureLod\(/g,
        "texture2DLodEXT("
    ]
];
const $0a454f71c6acc901$var$ES100_VERTEX_REPLACEMENTS = [
    ...$0a454f71c6acc901$var$ES100_REPLACEMENTS,
    [
        $0a454f71c6acc901$var$testVariable("in"),
        "attribute $1"
    ],
    [
        $0a454f71c6acc901$var$testVariable("out"),
        "varying $1"
    ]
];
const $0a454f71c6acc901$var$ES100_FRAGMENT_REPLACEMENTS = [
    ...$0a454f71c6acc901$var$ES100_REPLACEMENTS,
    [
        $0a454f71c6acc901$var$testVariable("in"),
        "varying $1"
    ]
];
const $0a454f71c6acc901$var$ES100_FRAGMENT_OUTPUT_NAME = "gl_FragColor";
const $0a454f71c6acc901$var$ES300_FRAGMENT_OUTPUT_REGEX = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/;
const $0a454f71c6acc901$var$REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
function $0a454f71c6acc901$export$2e2bcd8739ae039(source, targetGLSLVersion, isVertex) {
    switch(targetGLSLVersion){
        case 300:
            return isVertex ? $0a454f71c6acc901$var$convertShader(source, $0a454f71c6acc901$var$ES300_VERTEX_REPLACEMENTS) : $0a454f71c6acc901$var$convertFragmentShaderTo300(source);
        case 100:
            return isVertex ? $0a454f71c6acc901$var$convertShader(source, $0a454f71c6acc901$var$ES100_VERTEX_REPLACEMENTS) : $0a454f71c6acc901$var$convertFragmentShaderTo100(source);
        default:
            throw new Error("unknown GLSL version ".concat(targetGLSLVersion));
    }
}
function $0a454f71c6acc901$var$convertShader(source, replacements) {
    for (const [pattern, replacement] of replacements)source = source.replace(pattern, replacement);
    return source;
}
function $0a454f71c6acc901$var$convertFragmentShaderTo300(source) {
    source = $0a454f71c6acc901$var$convertShader(source, $0a454f71c6acc901$var$ES300_FRAGMENT_REPLACEMENTS);
    const outputMatch = source.match($0a454f71c6acc901$var$ES300_FRAGMENT_OUTPUT_REGEX);
    if (outputMatch) {
        const outputName = outputMatch[1];
        source = source.replace(new RegExp("\\b".concat($0a454f71c6acc901$var$ES100_FRAGMENT_OUTPUT_NAME, "\\b"), "g"), outputName);
    } else {
        const outputName = "fragmentColor";
        source = source.replace($0a454f71c6acc901$var$REGEX_START_OF_MAIN, (match)=>"out vec4 ".concat(outputName, ";\n").concat(match)).replace(new RegExp("\\b".concat($0a454f71c6acc901$var$ES100_FRAGMENT_OUTPUT_NAME, "\\b"), "g"), outputName);
    }
    return source;
}
function $0a454f71c6acc901$var$convertFragmentShaderTo100(source) {
    source = $0a454f71c6acc901$var$convertShader(source, $0a454f71c6acc901$var$ES100_FRAGMENT_REPLACEMENTS);
    const outputMatch = source.match($0a454f71c6acc901$var$ES300_FRAGMENT_OUTPUT_REGEX);
    if (outputMatch) {
        const outputName = outputMatch[1];
        source = source.replace($0a454f71c6acc901$var$ES300_FRAGMENT_OUTPUT_REGEX, "").replace(new RegExp("\\b".concat(outputName, "\\b"), "g"), $0a454f71c6acc901$var$ES100_FRAGMENT_OUTPUT_NAME);
    }
    return source;
}



const $aefa4a4b3d440d18$var$INJECT_SHADER_DECLARATIONS = "\n\n".concat((0, $e03481e8f5a496cf$export$62f6e317489649e6), "\n\n");
const $aefa4a4b3d440d18$var$SHADER_TYPE = {
    [(0, $23d7a12f17d9f134$export$9abae82e87f5416d)]: "vertex",
    [(0, $23d7a12f17d9f134$export$71cb6c7fe82525af)]: "fragment"
};
const $aefa4a4b3d440d18$var$FRAGMENT_SHADER_PROLOGUE = "precision highp float;\n\n";
function $aefa4a4b3d440d18$export$284ff2a142913562(gl, opts) {
    const { vs: vs , fs: fs  } = opts;
    const modules = (0, $b48d7b90009bb09d$export$85f943437bcc1df)(opts.modules || []);
    return {
        gl: gl,
        vs: $aefa4a4b3d440d18$var$assembleShader(gl, Object.assign({}, opts, {
            source: vs,
            type: (0, $23d7a12f17d9f134$export$9abae82e87f5416d),
            modules: modules
        })),
        fs: $aefa4a4b3d440d18$var$assembleShader(gl, Object.assign({}, opts, {
            source: fs,
            type: (0, $23d7a12f17d9f134$export$71cb6c7fe82525af),
            modules: modules
        })),
        getUniforms: $aefa4a4b3d440d18$var$assembleGetUniforms(modules)
    };
}
function $aefa4a4b3d440d18$var$assembleShader(gl, _ref) {
    let { id: id , source: source , type: type , modules: modules , defines: defines = {} , hookFunctions: hookFunctions = [] , inject: inject = {} , transpileToGLSL100: transpileToGLSL100 = false , prologue: prologue = true , log: log  } = _ref;
    (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(typeof source === "string", "shader source must be a string");
    const isVertex = type === (0, $23d7a12f17d9f134$export$9abae82e87f5416d);
    const sourceLines = source.split("\n");
    let glslVersion = 100;
    let versionLine = "";
    let coreSource = source;
    if (sourceLines[0].indexOf("#version ") === 0) {
        glslVersion = 300;
        versionLine = sourceLines[0];
        coreSource = sourceLines.slice(1).join("\n");
    } else versionLine = "#version ".concat(glslVersion);
    const allDefines = {};
    modules.forEach((module)=>{
        Object.assign(allDefines, module.getDefines());
    });
    Object.assign(allDefines, defines);
    let assembledSource = prologue ? "".concat(versionLine, "\n").concat($aefa4a4b3d440d18$var$getShaderName({
        id: id,
        source: source,
        type: type
    }), "\n").concat($aefa4a4b3d440d18$var$getShaderType({
        type: type
    }), "\n").concat((0, $2fbefa35cddc42a2$export$2c56069b1b5c9cc2)(gl), "\n").concat((0, $2fbefa35cddc42a2$export$e7726ded64e86312)(gl, glslVersion, !isVertex), "\n").concat($aefa4a4b3d440d18$var$getApplicationDefines(allDefines), "\n").concat(isVertex ? "" : $aefa4a4b3d440d18$var$FRAGMENT_SHADER_PROLOGUE, "\n") : "".concat(versionLine, "\n");
    const hookFunctionMap = $aefa4a4b3d440d18$var$normalizeHookFunctions(hookFunctions);
    const hookInjections = {};
    const declInjections = {};
    const mainInjections = {};
    for(const key in inject){
        const injection = typeof inject[key] === "string" ? {
            injection: inject[key],
            order: 0
        } : inject[key];
        const match = key.match(/^(v|f)s:(#)?([\w-]+)$/);
        if (match) {
            const hash = match[2];
            const name = match[3];
            if (hash) {
                if (name === "decl") declInjections[key] = [
                    injection
                ];
                else mainInjections[key] = [
                    injection
                ];
            } else hookInjections[key] = [
                injection
            ];
        } else mainInjections[key] = [
            injection
        ];
    }
    for (const module1 of modules){
        if (log) module1.checkDeprecations(coreSource, log);
        const moduleSource = module1.getModuleSource(type, glslVersion);
        assembledSource += moduleSource;
        const injections = module1.injections[type];
        for(const key in injections){
            const match = key.match(/^(v|f)s:#([\w-]+)$/);
            if (match) {
                const name = match[2];
                const injectionType = name === "decl" ? declInjections : mainInjections;
                injectionType[key] = injectionType[key] || [];
                injectionType[key].push(injections[key]);
            } else {
                hookInjections[key] = hookInjections[key] || [];
                hookInjections[key].push(injections[key]);
            }
        }
    }
    assembledSource += $aefa4a4b3d440d18$var$INJECT_SHADER_DECLARATIONS;
    assembledSource = (0, $e03481e8f5a496cf$export$2e2bcd8739ae039)(assembledSource, type, declInjections);
    assembledSource += $aefa4a4b3d440d18$var$getHookFunctions(hookFunctionMap[type], hookInjections);
    assembledSource += coreSource;
    assembledSource = (0, $e03481e8f5a496cf$export$2e2bcd8739ae039)(assembledSource, type, mainInjections);
    assembledSource = (0, $0a454f71c6acc901$export$2e2bcd8739ae039)(assembledSource, transpileToGLSL100 ? 100 : glslVersion, isVertex);
    return assembledSource;
}
function $aefa4a4b3d440d18$var$assembleGetUniforms(modules) {
    return function getUniforms(opts) {
        const uniforms = {};
        for (const module of modules){
            const moduleUniforms = module.getUniforms(opts, uniforms);
            Object.assign(uniforms, moduleUniforms);
        }
        return uniforms;
    };
}
function $aefa4a4b3d440d18$var$getShaderType(_ref2) {
    let { type: type  } = _ref2;
    return "\n#define SHADER_TYPE_".concat($aefa4a4b3d440d18$var$SHADER_TYPE[type].toUpperCase(), "\n");
}
function $aefa4a4b3d440d18$var$getShaderName(_ref3) {
    let { id: id , source: source , type: type  } = _ref3;
    const injectShaderName = id && typeof id === "string" && source.indexOf("SHADER_NAME") === -1;
    return injectShaderName ? "\n#define SHADER_NAME ".concat(id, "_").concat($aefa4a4b3d440d18$var$SHADER_TYPE[type], "\n\n") : "";
}
function $aefa4a4b3d440d18$var$getApplicationDefines() {
    let defines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let count = 0;
    let sourceText = "";
    for(const define in defines){
        if (count === 0) sourceText += "\n// APPLICATION DEFINES\n";
        count++;
        const value = defines[define];
        if (value || Number.isFinite(value)) sourceText += "#define ".concat(define.toUpperCase(), " ").concat(defines[define], "\n");
    }
    if (count === 0) sourceText += "\n";
    return sourceText;
}
function $aefa4a4b3d440d18$var$getHookFunctions(hookFunctions, hookInjections) {
    let result = "";
    for(const hookName in hookFunctions){
        const hookFunction = hookFunctions[hookName];
        result += "void ".concat(hookFunction.signature, " {\n");
        if (hookFunction.header) result += "  ".concat(hookFunction.header);
        if (hookInjections[hookName]) {
            const injections = hookInjections[hookName];
            injections.sort((a, b)=>a.order - b.order);
            for (const injection of injections)result += "  ".concat(injection.injection, "\n");
        }
        if (hookFunction.footer) result += "  ".concat(hookFunction.footer);
        result += "}\n";
    }
    return result;
}
function $aefa4a4b3d440d18$var$normalizeHookFunctions(hookFunctions) {
    const result = {
        vs: {},
        fs: {}
    };
    hookFunctions.forEach((hook)=>{
        let opts;
        if (typeof hook !== "string") {
            opts = hook;
            hook = opts.hook;
        } else opts = {};
        hook = hook.trim();
        const [stage, signature] = hook.split(":");
        const name = hook.replace(/\(.+/, "");
        result[stage][name] = Object.assign(opts, {
            signature: signature
        });
    });
    return result;
}


const $b14a5ab92b562947$var$FS100 = "void main() {gl_FragColor = vec4(0);}";
const $b14a5ab92b562947$var$FS_GLES = "out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}";
const $b14a5ab92b562947$var$FS300 = "#version 300 es\n".concat($b14a5ab92b562947$var$FS_GLES);
function $b14a5ab92b562947$export$ca11e09347dd6309(line, qualifiers) {
    qualifiers = Array.isArray(qualifiers) ? qualifiers : [
        qualifiers
    ];
    const words = line.replace(/^\s+/, "").split(/\s+/);
    const [qualifier, type, definition] = words;
    if (!qualifiers.includes(qualifier) || !type || !definition) return null;
    const name = definition.split(";")[0];
    return {
        qualifier: qualifier,
        type: type,
        name: name
    };
}
function $b14a5ab92b562947$export$523a4d4d9f32ef9e() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const { version: version = 100 , input: input , inputType: inputType , output: output  } = options;
    if (!input) {
        if (version === 300) return $b14a5ab92b562947$var$FS300;
        else if (version > 300) return "#version ".concat(version, "\n").concat($b14a5ab92b562947$var$FS_GLES);
        return $b14a5ab92b562947$var$FS100;
    }
    const outputValue = $b14a5ab92b562947$export$5616b9a44ef98392(input, inputType);
    if (version >= 300) return "#version ".concat(version, " ").concat(version === 300 ? "es" : "", "\nin ").concat(inputType, " ").concat(input, ";\nout vec4 ").concat(output, ";\nvoid main() {\n  ").concat(output, " = ").concat(outputValue, ";\n}");
    return "varying ".concat(inputType, " ").concat(input, ";\nvoid main() {\n  gl_FragColor = ").concat(outputValue, ";\n}");
}
function $b14a5ab92b562947$export$7c9d09032d11b05d(type) {
    switch(type){
        case "float":
            return "x";
        case "vec2":
            return "xy";
        case "vec3":
            return "xyz";
        case "vec4":
            return "xyzw";
        default:
            (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(false);
            return null;
    }
}
function $b14a5ab92b562947$export$7d9650494fc7500d(type) {
    switch(type){
        case "float":
            return 1;
        case "vec2":
            return 2;
        case "vec3":
            return 3;
        case "vec4":
            return 4;
        default:
            (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(false);
            return null;
    }
}
function $b14a5ab92b562947$export$5616b9a44ef98392(variable, type) {
    switch(type){
        case "float":
            return "vec4(".concat(variable, ", 0.0, 0.0, 1.0)");
        case "vec2":
            return "vec4(".concat(variable, ", 0.0, 1.0)");
        case "vec3":
            return "vec4(".concat(variable, ", 1.0)");
        case "vec4":
            return variable;
        default:
            (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(false);
            return null;
    }
}

const $65fa5645ea84a164$var$fp32shader = "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n";
const $65fa5645ea84a164$export$d4bf4ab3180407a1 = {
    name: "fp32",
    vs: $65fa5645ea84a164$var$fp32shader,
    fs: null
};

const $7e9d081b840cbf62$var$DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([
    0,
    255,
    255,
    255
]);
const $7e9d081b840cbf62$var$DEFAULT_MODULE_OPTIONS = {
    pickingSelectedColor: null,
    pickingHighlightColor: $7e9d081b840cbf62$var$DEFAULT_HIGHLIGHT_COLOR,
    pickingActive: false,
    pickingAttribute: false
};
function $7e9d081b840cbf62$var$getUniforms() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : $7e9d081b840cbf62$var$DEFAULT_MODULE_OPTIONS;
    const uniforms = {};
    if (opts.pickingSelectedColor !== undefined) {
        if (!opts.pickingSelectedColor) uniforms.picking_uSelectedColorValid = 0;
        else {
            const selectedColor = opts.pickingSelectedColor.slice(0, 3);
            uniforms.picking_uSelectedColorValid = 1;
            uniforms.picking_uSelectedColor = selectedColor;
        }
    }
    if (opts.pickingHighlightColor) {
        const color = Array.from(opts.pickingHighlightColor, (x)=>x / 255);
        if (!Number.isFinite(color[3])) color[3] = 1;
        uniforms.picking_uHighlightColor = color;
    }
    if (opts.pickingActive !== undefined) {
        uniforms.picking_uActive = Boolean(opts.pickingActive);
        uniforms.picking_uAttribute = Boolean(opts.pickingAttribute);
    }
    return uniforms;
}
const $7e9d081b840cbf62$var$vs = "uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n";
const $7e9d081b840cbf62$var$fs = "uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n";
const $7e9d081b840cbf62$export$1f1790962c6071cf = {
    name: "picking",
    vs: $7e9d081b840cbf62$var$vs,
    fs: $7e9d081b840cbf62$var$fs,
    getUniforms: $7e9d081b840cbf62$var$getUniforms
};

const $3812d8ee6528adfc$var$vs = "attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n";
const $3812d8ee6528adfc$export$51186ad6e864892a = {
    name: "transform",
    vs: $3812d8ee6528adfc$var$vs,
    fs: null
};





class $389aec4f13e2bfb5$export$2e2bcd8739ae039 {
    static getDefaultProgramManager(gl) {
        gl.luma = gl.luma || {};
        gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new $389aec4f13e2bfb5$export$2e2bcd8739ae039(gl);
        return gl.luma.defaultProgramManager;
    }
    constructor(gl){
        this.gl = gl;
        this._programCache = {};
        this._getUniforms = {};
        this._registeredModules = {};
        this._hookFunctions = [];
        this._defaultModules = [];
        this._hashes = {};
        this._hashCounter = 0;
        this.stateHash = 0;
        this._useCounts = {};
    }
    addDefaultModule(module) {
        if (!this._defaultModules.find((m)=>m.name === module.name)) this._defaultModules.push(module);
        this.stateHash++;
    }
    removeDefaultModule(module) {
        const moduleName = typeof module === "string" ? module : module.name;
        this._defaultModules = this._defaultModules.filter((m)=>m.name !== moduleName);
        this.stateHash++;
    }
    addShaderHook(hook, opts) {
        if (opts) hook = Object.assign(opts, {
            hook: hook
        });
        this._hookFunctions.push(hook);
        this.stateHash++;
    }
    get() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { vs: vs = "" , fs: fs = "" , defines: defines = {} , inject: inject = {} , varyings: varyings = [] , bufferMode: bufferMode = 0x8c8d , transpileToGLSL100: transpileToGLSL100 = false  } = props;
        const modules = this._getModuleList(props.modules);
        const vsHash = this._getHash(vs);
        const fsHash = this._getHash(fs);
        const moduleHashes = modules.map((m)=>this._getHash(m.name)).sort();
        const varyingHashes = varyings.map((v)=>this._getHash(v));
        const defineKeys = Object.keys(defines).sort();
        const injectKeys = Object.keys(inject).sort();
        const defineHashes = [];
        const injectHashes = [];
        for (const key of defineKeys){
            defineHashes.push(this._getHash(key));
            defineHashes.push(this._getHash(defines[key]));
        }
        for (const key1 of injectKeys){
            injectHashes.push(this._getHash(key1));
            injectHashes.push(this._getHash(inject[key1]));
        }
        const hash = "".concat(vsHash, "/").concat(fsHash, "D").concat(defineHashes.join("/"), "M").concat(moduleHashes.join("/"), "I").concat(injectHashes.join("/"), "V").concat(varyingHashes.join("/"), "H").concat(this.stateHash, "B").concat(bufferMode).concat(transpileToGLSL100 ? "T" : "");
        if (!this._programCache[hash]) {
            const assembled = (0, $aefa4a4b3d440d18$export$284ff2a142913562)(this.gl, {
                vs: vs,
                fs: fs,
                modules: modules,
                inject: inject,
                defines: defines,
                hookFunctions: this._hookFunctions,
                transpileToGLSL100: transpileToGLSL100
            });
            this._programCache[hash] = new (0, $6fea3ad8e77f174f$export$2e2bcd8739ae039)(this.gl, {
                hash: hash,
                vs: assembled.vs,
                fs: assembled.fs,
                varyings: varyings,
                bufferMode: bufferMode
            });
            this._getUniforms[hash] = assembled.getUniforms || ((x)=>{});
            this._useCounts[hash] = 0;
        }
        this._useCounts[hash]++;
        return this._programCache[hash];
    }
    getUniforms(program) {
        return this._getUniforms[program.hash] || null;
    }
    release(program) {
        const hash = program.hash;
        this._useCounts[hash]--;
        if (this._useCounts[hash] === 0) {
            this._programCache[hash].delete();
            delete this._programCache[hash];
            delete this._getUniforms[hash];
            delete this._useCounts[hash];
        }
    }
    _getHash(key) {
        if (this._hashes[key] === undefined) this._hashes[key] = this._hashCounter++;
        return this._hashes[key];
    }
    _getModuleList() {
        let appModules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        const modules = new Array(this._defaultModules.length + appModules.length);
        const seen = {};
        let count = 0;
        for(let i = 0, len = this._defaultModules.length; i < len; ++i){
            const module = this._defaultModules[i];
            const name = module.name;
            modules[count++] = module;
            seen[name] = true;
        }
        for(let i1 = 0, len1 = appModules.length; i1 < len1; ++i1){
            const module = appModules[i1];
            const name = module.name;
            if (!seen[name]) {
                modules[count++] = module;
                seen[name] = true;
            }
        }
        modules.length = count;
        return modules;
    }
}





const $bb5aa92f5c43a56c$var$GLTF_TO_LUMA_ATTRIBUTE_MAP = {
    POSITION: "positions",
    NORMAL: "normals",
    COLOR_0: "colors",
    TEXCOORD_0: "texCoords",
    TEXCOORD_1: "texCoords1",
    TEXCOORD_2: "texCoords2"
};
function $bb5aa92f5c43a56c$export$7e4fab05163ba2d1(gl, geometry, options) {
    const buffers = {};
    let indices = geometry.indices;
    for(const name in geometry.attributes){
        const attribute = geometry.attributes[name];
        const remappedName = $bb5aa92f5c43a56c$var$mapAttributeName(name, options);
        if (name === "indices") indices = attribute;
        else if (attribute.constant) buffers[remappedName] = attribute.value;
        else {
            const typedArray = attribute.value;
            const accessor = {
                ...attribute
            };
            delete accessor.value;
            buffers[remappedName] = [
                new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(gl, typedArray),
                accessor
            ];
            $bb5aa92f5c43a56c$export$3f504f33778aed92(name, accessor);
        }
    }
    if (indices) {
        const data = indices.value || indices;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(data instanceof Uint16Array || data instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
        const accessor = {
            size: 1,
            isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed
        };
        buffers.indices = [
            new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(gl, {
                data: data,
                target: 34963
            }),
            accessor
        ];
    }
    return buffers;
}
function $bb5aa92f5c43a56c$var$mapAttributeName(name, options) {
    const { attributeMap: attributeMap = $bb5aa92f5c43a56c$var$GLTF_TO_LUMA_ATTRIBUTE_MAP  } = options || {};
    return attributeMap && attributeMap[name] || name;
}
function $bb5aa92f5c43a56c$export$3f504f33778aed92(attributeName, attribute) {
    let category;
    switch(attributeName){
        case "texCoords":
        case "texCoord1":
        case "texCoord2":
        case "texCoord3":
            category = "uvs";
            break;
        case "vertices":
        case "positions":
        case "normals":
        case "pickingColors":
            category = "vectors";
            break;
        default:
    }
    switch(category){
        case "vectors":
            attribute.size = attribute.size || 3;
            break;
        case "uvs":
            attribute.size = attribute.size || 2;
            break;
        default:
    }
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(Number.isFinite(attribute.size), "attribute ".concat(attributeName, " needs size"));
}


const $d4b5fa431316d551$var$LOG_DRAW_PRIORITY = 2;
const $d4b5fa431316d551$var$LOG_DRAW_TIMEOUT = 10000;
const $d4b5fa431316d551$var$ERR_MODEL_PARAMS = "Model needs drawMode and vertexCount";
const $d4b5fa431316d551$var$NOOP = ()=>{};
const $d4b5fa431316d551$var$DRAW_PARAMS = {};
class $d4b5fa431316d551$export$2e2bcd8739ae039 {
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const { id: id = (0, $757dc76705f498e6$export$e2a22331486dcca0)("model")  } = props;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)((0, $325e733792a03f4e$export$3a471d0dd6792be6)(gl));
        this.id = id;
        this.gl = gl;
        this.id = props.id || (0, $757dc76705f498e6$export$e2a22331486dcca0)("Model");
        this.lastLogTime = 0;
        this.animated = false;
        this.initialize(props);
    }
    initialize(props) {
        this.props = {};
        this.programManager = props.programManager || (0, $389aec4f13e2bfb5$export$2e2bcd8739ae039).getDefaultProgramManager(this.gl);
        this._programManagerState = -1;
        this._managedProgram = false;
        const { program: program = null , vs: vs , fs: fs , modules: modules , defines: defines , inject: inject , varyings: varyings , bufferMode: bufferMode , transpileToGLSL100: transpileToGLSL100  } = props;
        this.programProps = {
            program: program,
            vs: vs,
            fs: fs,
            modules: modules,
            defines: defines,
            inject: inject,
            varyings: varyings,
            bufferMode: bufferMode,
            transpileToGLSL100: transpileToGLSL100
        };
        this.program = null;
        this.vertexArray = null;
        this._programDirty = true;
        this.userData = {};
        this.needsRedraw = true;
        this._attributes = {};
        this.attributes = {};
        this.uniforms = {};
        this.pickable = true;
        this._checkProgram();
        this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));
        this.drawMode = props.drawMode !== undefined ? props.drawMode : 4;
        this.vertexCount = props.vertexCount || 0;
        this.geometryBuffers = {};
        this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;
        this._setModelProps(props);
        this.geometry = {};
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(this.drawMode !== undefined && Number.isFinite(this.vertexCount), $d4b5fa431316d551$var$ERR_MODEL_PARAMS);
    }
    setProps(props) {
        this._setModelProps(props);
    }
    delete() {
        for(const key in this._attributes)if (this._attributes[key] !== this.attributes[key]) this._attributes[key].delete();
        if (this._managedProgram) {
            this.programManager.release(this.program);
            this._managedProgram = false;
        }
        this.vertexArray.delete();
        this._deleteGeometryBuffers();
    }
    getDrawMode() {
        return this.drawMode;
    }
    getVertexCount() {
        return this.vertexCount;
    }
    getInstanceCount() {
        return this.instanceCount;
    }
    getAttributes() {
        return this.attributes;
    }
    getProgram() {
        return this.program;
    }
    setProgram(props) {
        const { program: program , vs: vs , fs: fs , modules: modules , defines: defines , inject: inject , varyings: varyings , bufferMode: bufferMode , transpileToGLSL100: transpileToGLSL100  } = props;
        this.programProps = {
            program: program,
            vs: vs,
            fs: fs,
            modules: modules,
            defines: defines,
            inject: inject,
            varyings: varyings,
            bufferMode: bufferMode,
            transpileToGLSL100: transpileToGLSL100
        };
        this._programDirty = true;
    }
    getUniforms() {
        return this.uniforms;
    }
    setDrawMode(drawMode) {
        this.drawMode = drawMode;
        return this;
    }
    setVertexCount(vertexCount) {
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(Number.isFinite(vertexCount));
        this.vertexCount = vertexCount;
        return this;
    }
    setInstanceCount(instanceCount) {
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(Number.isFinite(instanceCount));
        this.instanceCount = instanceCount;
        return this;
    }
    setGeometry(geometry) {
        this.drawMode = geometry.drawMode;
        this.vertexCount = geometry.getVertexCount();
        this._deleteGeometryBuffers();
        this.geometryBuffers = (0, $bb5aa92f5c43a56c$export$7e4fab05163ba2d1)(this.gl, geometry);
        this.vertexArray.setAttributes(this.geometryBuffers);
        return this;
    }
    setAttributes() {
        let attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if ((0, $757dc76705f498e6$export$23cfe696632d10f4)(attributes)) return this;
        const normalizedAttributes = {};
        for(const name in attributes){
            const attribute = attributes[name];
            normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;
        }
        this.vertexArray.setAttributes(normalizedAttributes);
        return this;
    }
    setUniforms() {
        let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        Object.assign(this.uniforms, uniforms);
        return this;
    }
    getModuleUniforms(opts) {
        this._checkProgram();
        const getUniforms = this.programManager.getUniforms(this.program);
        if (getUniforms) return getUniforms(opts);
        return {};
    }
    updateModuleSettings(opts) {
        const uniforms = this.getModuleUniforms(opts || {});
        return this.setUniforms(uniforms);
    }
    clear(opts) {
        (0, $9d2da77370080708$export$42ffd38884aecdac)(this.program.gl, opts);
        return this;
    }
    draw() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this._checkProgram();
        const { moduleSettings: moduleSettings = null , framebuffer: framebuffer , uniforms: uniforms = {} , attributes: attributes = {} , transformFeedback: transformFeedback = this.transformFeedback , parameters: parameters = {} , vertexArray: vertexArray = this.vertexArray  } = opts;
        this.setAttributes(attributes);
        this.updateModuleSettings(moduleSettings);
        this.setUniforms(uniforms);
        let logPriority;
        if ((0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).priority >= $d4b5fa431316d551$var$LOG_DRAW_PRIORITY) logPriority = this._logDrawCallStart($d4b5fa431316d551$var$LOG_DRAW_PRIORITY);
        const drawParams = this.vertexArray.getDrawParams();
        const { isIndexed: isIndexed = drawParams.isIndexed , indexType: indexType = drawParams.indexType , indexOffset: indexOffset = drawParams.indexOffset , vertexArrayInstanced: vertexArrayInstanced = drawParams.isInstanced  } = this.props;
        if (vertexArrayInstanced && !this.isInstanced) (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("Found instanced attributes on non-instanced model", this.id)();
        const { isInstanced: isInstanced , instanceCount: instanceCount  } = this;
        const { onBeforeRender: onBeforeRender = $d4b5fa431316d551$var$NOOP , onAfterRender: onAfterRender = $d4b5fa431316d551$var$NOOP  } = this.props;
        onBeforeRender();
        this.program.setUniforms(this.uniforms);
        const didDraw = this.program.draw(Object.assign($d4b5fa431316d551$var$DRAW_PARAMS, opts, {
            logPriority: logPriority,
            uniforms: null,
            framebuffer: framebuffer,
            parameters: parameters,
            drawMode: this.getDrawMode(),
            vertexCount: this.getVertexCount(),
            vertexArray: vertexArray,
            transformFeedback: transformFeedback,
            isIndexed: isIndexed,
            indexType: indexType,
            isInstanced: isInstanced,
            instanceCount: instanceCount,
            offset: isIndexed ? indexOffset : 0
        }));
        onAfterRender();
        if ((0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).priority >= $d4b5fa431316d551$var$LOG_DRAW_PRIORITY) this._logDrawCallEnd(logPriority, vertexArray, framebuffer);
        return didDraw;
    }
    transform() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { discard: discard = true , feedbackBuffers: feedbackBuffers , unbindModels: unbindModels = []  } = opts;
        let { parameters: parameters  } = opts;
        if (feedbackBuffers) this._setFeedbackBuffers(feedbackBuffers);
        if (discard) parameters = Object.assign({}, parameters, {
            [35977]: discard
        });
        unbindModels.forEach((model)=>model.vertexArray.unbindBuffers());
        try {
            this.draw(Object.assign({}, opts, {
                parameters: parameters
            }));
        } finally{
            unbindModels.forEach((model)=>model.vertexArray.bindBuffers());
        }
        return this;
    }
    render() {
        let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("Model.render() is deprecated. Use Model.setUniforms() and Model.draw()")();
        return this.setUniforms(uniforms).draw();
    }
    _setModelProps(props) {
        Object.assign(this.props, props);
        if ("uniforms" in props) this.setUniforms(props.uniforms);
        if ("pickable" in props) this.pickable = props.pickable;
        if ("instanceCount" in props) this.instanceCount = props.instanceCount;
        if ("geometry" in props) this.setGeometry(props.geometry);
        if ("attributes" in props) this.setAttributes(props.attributes);
        if ("_feedbackBuffers" in props) this._setFeedbackBuffers(props._feedbackBuffers);
    }
    _checkProgram() {
        const needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;
        if (!needsUpdate) return;
        let { program: program  } = this.programProps;
        if (program) this._managedProgram = false;
        else {
            const { vs: vs , fs: fs , modules: modules , inject: inject , defines: defines , varyings: varyings , bufferMode: bufferMode , transpileToGLSL100: transpileToGLSL100  } = this.programProps;
            program = this.programManager.get({
                vs: vs,
                fs: fs,
                modules: modules,
                inject: inject,
                defines: defines,
                varyings: varyings,
                bufferMode: bufferMode,
                transpileToGLSL100: transpileToGLSL100
            });
            if (this.program && this._managedProgram) this.programManager.release(this.program);
            this._programManagerState = this.programManager.stateHash;
            this._managedProgram = true;
        }
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(program instanceof (0, $6fea3ad8e77f174f$export$2e2bcd8739ae039), "Model needs a program");
        this._programDirty = false;
        if (program === this.program) return;
        this.program = program;
        if (this.vertexArray) this.vertexArray.setProps({
            program: this.program,
            attributes: this.vertexArray.attributes
        });
        else this.vertexArray = new (0, $012b7736d6299c03$export$2e2bcd8739ae039)(this.gl, {
            program: this.program
        });
        this.setUniforms(Object.assign({}, this.getModuleUniforms()));
    }
    _deleteGeometryBuffers() {
        for(const name in this.geometryBuffers){
            const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];
            if (buffer instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) buffer.delete();
        }
    }
    _setAnimationProps(animationProps) {
        if (this.animated) (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(animationProps, "Model.draw(): animated uniforms but no animationProps");
    }
    _setFeedbackBuffers() {
        let feedbackBuffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if ((0, $757dc76705f498e6$export$23cfe696632d10f4)(feedbackBuffers)) return this;
        const { gl: gl  } = this.program;
        this.transformFeedback = this.transformFeedback || new (0, $feb45ae040c88295$export$2e2bcd8739ae039)(gl, {
            program: this.program
        });
        this.transformFeedback.setBuffers(feedbackBuffers);
        return this;
    }
    _logDrawCallStart(logLevel) {
        const logDrawTimeout = logLevel > 3 ? 0 : $d4b5fa431316d551$var$LOG_DRAW_TIMEOUT;
        if (Date.now() - this.lastLogTime < logDrawTimeout) return undefined;
        this.lastLogTime = Date.now();
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).group($d4b5fa431316d551$var$LOG_DRAW_PRIORITY, ">>> DRAWING MODEL ".concat(this.id), {
            collapsed: (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).level <= 2
        })();
        return logLevel;
    }
    _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {
        if (logLevel === undefined) return;
        const attributeTable = (0, $425f6c53ea308543$export$f05218eded921e71)({
            vertexArray: vertexArray,
            header: "".concat(this.id, " attributes"),
            attributes: this._attributes
        });
        const { table: uniformTable , unusedTable: unusedTable , unusedCount: unusedCount  } = (0, $d325c11ca8c9db0d$export$72be64c472054e23)({
            header: "".concat(this.id, " uniforms"),
            program: this.program,
            uniforms: Object.assign({}, this.program.uniforms, uniforms)
        });
        const { table: missingTable , count: missingCount  } = (0, $d325c11ca8c9db0d$export$72be64c472054e23)({
            header: "".concat(this.id, " uniforms"),
            program: this.program,
            uniforms: Object.assign({}, this.program.uniforms, uniforms),
            undefinedOnly: true
        });
        if (missingCount > 0) (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).log("MISSING UNIFORMS", Object.keys(missingTable))();
        if (unusedCount > 0) (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).log("UNUSED UNIFORMS", Object.keys(unusedTable))();
        const configTable = (0, $d892712aaf8139ba$export$826103546372d55e)(this.vertexArray.configuration);
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).table(logLevel, attributeTable)();
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).table(logLevel, uniformTable)();
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).table(logLevel + 1, configTable)();
        if (framebuffer) framebuffer.log({
            logLevel: $d4b5fa431316d551$var$LOG_DRAW_PRIORITY,
            message: "Rendered to ".concat(framebuffer.id)
        });
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).groupEnd($d4b5fa431316d551$var$LOG_DRAW_PRIORITY)();
    }
}





class $75029039b1643eaf$export$2e2bcd8739ae039 {
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        this.gl = gl;
        this.currentIndex = 0;
        this.feedbackMap = {};
        this.varyings = null;
        this.bindings = [];
        this.resources = {};
        this._initialize(props);
        Object.seal(this);
    }
    setupResources(opts) {
        for (const binding of this.bindings)this._setupTransformFeedback(binding, opts);
    }
    updateModelProps() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { varyings: varyings  } = this;
        if (varyings.length > 0) props = Object.assign({}, props, {
            varyings: varyings
        });
        return props;
    }
    getDrawOptions() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const binding = this.bindings[this.currentIndex];
        const { sourceBuffers: sourceBuffers , transformFeedback: transformFeedback  } = binding;
        const attributes = Object.assign({}, sourceBuffers, opts.attributes);
        return {
            attributes: attributes,
            transformFeedback: transformFeedback
        };
    }
    swap() {
        if (this.feedbackMap) {
            this.currentIndex = this._getNextIndex();
            return true;
        }
        return false;
    }
    update() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this._setupBuffers(opts);
    }
    getBuffer(varyingName) {
        const { feedbackBuffers: feedbackBuffers  } = this.bindings[this.currentIndex];
        const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;
        if (!bufferOrParams) return null;
        return bufferOrParams instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039) ? bufferOrParams : bufferOrParams.buffer;
    }
    getData() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { varyingName: varyingName  } = options;
        const buffer = this.getBuffer(varyingName);
        if (buffer) return buffer.getData();
        return null;
    }
    delete() {
        for(const name in this.resources)this.resources[name].delete();
    }
    _initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this._setupBuffers(props);
        this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);
        if (this.varyings.length > 0) (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)((0, $325e733792a03f4e$export$e3518b1ac7891039)(this.gl));
    }
    _getFeedbackBuffers(props) {
        const { sourceBuffers: sourceBuffers = {}  } = props;
        const feedbackBuffers = {};
        if (this.bindings[this.currentIndex]) Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);
        if (this.feedbackMap) for(const sourceName in this.feedbackMap){
            const feedbackName = this.feedbackMap[sourceName];
            if (sourceName in sourceBuffers) feedbackBuffers[feedbackName] = sourceName;
        }
        Object.assign(feedbackBuffers, props.feedbackBuffers);
        for(const bufferName in feedbackBuffers){
            const bufferOrRef = feedbackBuffers[bufferName];
            if (typeof bufferOrRef === "string") {
                const sourceBuffer = sourceBuffers[bufferOrRef];
                const { byteLength: byteLength , usage: usage , accessor: accessor  } = sourceBuffer;
                feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {
                    byteLength: byteLength,
                    usage: usage,
                    accessor: accessor
                });
            }
        }
        return feedbackBuffers;
    }
    _setupBuffers() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { sourceBuffers: sourceBuffers = null  } = props;
        Object.assign(this.feedbackMap, props.feedbackMap);
        const feedbackBuffers = this._getFeedbackBuffers(props);
        this._updateBindings({
            sourceBuffers: sourceBuffers,
            feedbackBuffers: feedbackBuffers
        });
    }
    _setupTransformFeedback(binding, _ref) {
        let { model: model  } = _ref;
        const { program: program  } = model;
        binding.transformFeedback = new (0, $feb45ae040c88295$export$2e2bcd8739ae039)(this.gl, {
            program: program,
            buffers: binding.feedbackBuffers
        });
    }
    _updateBindings(opts) {
        this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
        if (this.feedbackMap) {
            const { sourceBuffers: sourceBuffers , feedbackBuffers: feedbackBuffers  } = this._swapBuffers(this.bindings[this.currentIndex]);
            const nextIndex = this._getNextIndex();
            this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
                sourceBuffers: sourceBuffers,
                feedbackBuffers: feedbackBuffers
            });
        }
    }
    _updateBinding(binding, opts) {
        if (!binding) return {
            sourceBuffers: Object.assign({}, opts.sourceBuffers),
            feedbackBuffers: Object.assign({}, opts.feedbackBuffers)
        };
        Object.assign(binding.sourceBuffers, opts.sourceBuffers);
        Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);
        if (binding.transformFeedback) binding.transformFeedback.setBuffers(binding.feedbackBuffers);
        return binding;
    }
    _swapBuffers(opts) {
        if (!this.feedbackMap) return null;
        const sourceBuffers = Object.assign({}, opts.sourceBuffers);
        const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);
        for(const srcName in this.feedbackMap){
            const dstName = this.feedbackMap[srcName];
            sourceBuffers[srcName] = opts.feedbackBuffers[dstName];
            feedbackBuffers[dstName] = opts.sourceBuffers[srcName];
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(feedbackBuffers[dstName] instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039));
        }
        return {
            sourceBuffers: sourceBuffers,
            feedbackBuffers: feedbackBuffers
        };
    }
    _createNewBuffer(name, opts) {
        const buffer = new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(this.gl, opts);
        if (this.resources[name]) this.resources[name].delete();
        this.resources[name] = buffer;
        return buffer;
    }
    _getNextIndex() {
        return (this.currentIndex + 1) % 2;
    }
}






const $dffd16a246e7d0e0$var$SAMPLER_UNIFORM_PREFIX = "transform_uSampler_";
const $dffd16a246e7d0e0$var$SIZE_UNIFORM_PREFIX = "transform_uSize_";
const $dffd16a246e7d0e0$var$VS_POS_VARIABLE = "transform_position";
function $dffd16a246e7d0e0$export$5a059e62d0049ef0(_ref) {
    let { vs: vs , sourceTextureMap: sourceTextureMap , targetTextureVarying: targetTextureVarying , targetTexture: targetTexture  } = _ref;
    const texAttributeNames = Object.keys(sourceTextureMap);
    let sourceCount = texAttributeNames.length;
    let targetTextureType = null;
    const samplerTextureMap = {};
    let updatedVs = vs;
    let finalInject = {};
    if (sourceCount > 0 || targetTextureVarying) {
        const vsLines = updatedVs.split("\n");
        const updateVsLines = vsLines.slice();
        vsLines.forEach((line, index, lines)=>{
            if (sourceCount > 0) {
                const updated = $dffd16a246e7d0e0$export$b3d21cd7dabd1c6(line, sourceTextureMap);
                if (updated) {
                    const { updatedLine: updatedLine , inject: inject  } = updated;
                    updateVsLines[index] = updatedLine;
                    finalInject = (0, $e03481e8f5a496cf$export$cef13ee8fb8f32f3)([
                        finalInject,
                        inject
                    ]);
                    Object.assign(samplerTextureMap, updated.samplerTextureMap);
                    sourceCount--;
                }
            }
            if (targetTextureVarying && !targetTextureType) targetTextureType = $dffd16a246e7d0e0$export$997a69001b588146(line, targetTextureVarying);
        });
        if (targetTextureVarying) {
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(targetTexture);
            const sizeName = "".concat($dffd16a246e7d0e0$var$SIZE_UNIFORM_PREFIX).concat(targetTextureVarying);
            const uniformDeclaration = "uniform vec2 ".concat(sizeName, ";\n");
            const posInstructions = "     vec2 ".concat($dffd16a246e7d0e0$var$VS_POS_VARIABLE, " = transform_getPos(").concat(sizeName, ");\n     gl_Position = vec4(").concat($dffd16a246e7d0e0$var$VS_POS_VARIABLE, ", 0, 1.);\n");
            const inject = {
                "vs:#decl": uniformDeclaration,
                "vs:#main-start": posInstructions
            };
            finalInject = (0, $e03481e8f5a496cf$export$cef13ee8fb8f32f3)([
                finalInject,
                inject
            ]);
        }
        updatedVs = updateVsLines.join("\n");
    }
    return {
        vs: updatedVs,
        targetTextureType: targetTextureType,
        inject: finalInject,
        samplerTextureMap: samplerTextureMap
    };
}
function $dffd16a246e7d0e0$export$9265f23b64eee61d(_ref2) {
    let { sourceTextureMap: sourceTextureMap , targetTextureVarying: targetTextureVarying , targetTexture: targetTexture  } = _ref2;
    const uniforms = {};
    let width;
    let height;
    if (targetTextureVarying) {
        ({ width: width , height: height  } = targetTexture);
        uniforms["".concat($dffd16a246e7d0e0$var$SIZE_UNIFORM_PREFIX).concat(targetTextureVarying)] = [
            width,
            height
        ];
    }
    for(const textureName in sourceTextureMap){
        ({ width: width , height: height  } = sourceTextureMap[textureName]);
        uniforms["".concat($dffd16a246e7d0e0$var$SIZE_UNIFORM_PREFIX).concat(textureName)] = [
            width,
            height
        ];
    }
    return uniforms;
}
function $dffd16a246e7d0e0$var$getAttributeDefinition(line) {
    return (0, $b14a5ab92b562947$export$ca11e09347dd6309)(line, [
        "attribute",
        "in"
    ]);
}
function $dffd16a246e7d0e0$var$getSamplerDeclerations(textureName) {
    const samplerName = "".concat($dffd16a246e7d0e0$var$SAMPLER_UNIFORM_PREFIX).concat(textureName);
    const sizeName = "".concat($dffd16a246e7d0e0$var$SIZE_UNIFORM_PREFIX).concat(textureName);
    const uniformDeclerations = "  uniform sampler2D ".concat(samplerName, ";\n  uniform vec2 ").concat(sizeName, ";");
    return {
        samplerName: samplerName,
        sizeName: sizeName,
        uniformDeclerations: uniformDeclerations
    };
}
function $dffd16a246e7d0e0$export$997a69001b588146(line, varying) {
    const qualaiferDetails = (0, $b14a5ab92b562947$export$ca11e09347dd6309)(line, [
        "varying",
        "out"
    ]);
    if (!qualaiferDetails) return null;
    return qualaiferDetails.name === varying ? qualaiferDetails.type : null;
}
function $dffd16a246e7d0e0$export$b3d21cd7dabd1c6(line, textureMap) {
    const samplerTextureMap = {};
    const attributeData = $dffd16a246e7d0e0$var$getAttributeDefinition(line);
    if (!attributeData) return null;
    const { type: type , name: name  } = attributeData;
    if (name && textureMap[name]) {
        const updatedLine = "// ".concat(line, " => Replaced by Transform with a sampler");
        const { samplerName: samplerName , sizeName: sizeName , uniformDeclerations: uniformDeclerations  } = $dffd16a246e7d0e0$var$getSamplerDeclerations(name);
        const channels = (0, $b14a5ab92b562947$export$7c9d09032d11b05d)(type);
        const sampleInstruction = "  ".concat(type, " ").concat(name, " = transform_getInput(").concat(samplerName, ", ").concat(sizeName, ").").concat(channels, ";\n");
        samplerTextureMap[samplerName] = name;
        const inject = {
            "vs:#decl": uniformDeclerations,
            "vs:#main-start": sampleInstruction
        };
        return {
            updatedLine: updatedLine,
            inject: inject,
            samplerTextureMap: samplerTextureMap
        };
    }
    return null;
}


const $30acc33c414d48f4$var$SRC_TEX_PARAMETER_OVERRIDES = {
    [10241]: 9728,
    [10240]: 9728,
    [10242]: 33071,
    [10243]: 33071
};
const $30acc33c414d48f4$var$FS_OUTPUT_VARIABLE = "transform_output";
class $30acc33c414d48f4$export$2e2bcd8739ae039 {
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        this.gl = gl;
        this.id = this.currentIndex = 0;
        this._swapTexture = null;
        this.targetTextureVarying = null;
        this.targetTextureType = null;
        this.samplerTextureMap = null;
        this.bindings = [];
        this.resources = {};
        this._initialize(props);
        Object.seal(this);
    }
    updateModelProps() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const updatedModelProps = this._processVertexShader(props);
        return Object.assign({}, props, updatedModelProps);
    }
    getDrawOptions() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { sourceBuffers: sourceBuffers , sourceTextures: sourceTextures , framebuffer: framebuffer , targetTexture: targetTexture  } = this.bindings[this.currentIndex];
        const attributes = Object.assign({}, sourceBuffers, opts.attributes);
        const uniforms = Object.assign({}, opts.uniforms);
        const parameters = Object.assign({}, opts.parameters);
        let discard = opts.discard;
        if (this.hasSourceTextures || this.hasTargetTexture) {
            attributes.transform_elementID = this.elementIDBuffer;
            for(const sampler in this.samplerTextureMap){
                const textureName = this.samplerTextureMap[sampler];
                uniforms[sampler] = sourceTextures[textureName];
            }
            this._setSourceTextureParameters();
            const sizeUniforms = (0, $dffd16a246e7d0e0$export$9265f23b64eee61d)({
                sourceTextureMap: sourceTextures,
                targetTextureVarying: this.targetTextureVarying,
                targetTexture: targetTexture
            });
            Object.assign(uniforms, sizeUniforms);
        }
        if (this.hasTargetTexture) {
            discard = false;
            parameters.viewport = [
                0,
                0,
                framebuffer.width,
                framebuffer.height
            ];
        }
        return {
            attributes: attributes,
            framebuffer: framebuffer,
            uniforms: uniforms,
            discard: discard,
            parameters: parameters
        };
    }
    swap() {
        if (this._swapTexture) {
            this.currentIndex = this._getNextIndex();
            return true;
        }
        return false;
    }
    update() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this._setupTextures(opts);
    }
    getTargetTexture() {
        const { targetTexture: targetTexture  } = this.bindings[this.currentIndex];
        return targetTexture;
    }
    getData() {
        let { packed: packed = false  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { framebuffer: framebuffer  } = this.bindings[this.currentIndex];
        const pixels = (0, $c192e756436d1779$export$f9f2f48e7f9faaa5)(framebuffer);
        if (!packed) return pixels;
        const ArrayType = pixels.constructor;
        const channelCount = (0, $b14a5ab92b562947$export$7d9650494fc7500d)(this.targetTextureType);
        const packedPixels = new ArrayType(pixels.length * channelCount / 4);
        let packCount = 0;
        for(let i = 0; i < pixels.length; i += 4)for(let j = 0; j < channelCount; j++)packedPixels[packCount++] = pixels[i + j];
        return packedPixels;
    }
    getFramebuffer() {
        const currentResources = this.bindings[this.currentIndex];
        return currentResources.framebuffer;
    }
    delete() {
        if (this.ownTexture) this.ownTexture.delete();
        if (this.elementIDBuffer) this.elementIDBuffer.delete();
    }
    _initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { _targetTextureVarying: _targetTextureVarying , _swapTexture: _swapTexture  } = props;
        this._swapTexture = _swapTexture;
        this.targetTextureVarying = _targetTextureVarying;
        this.hasTargetTexture = _targetTextureVarying;
        this._setupTextures(props);
    }
    _createTargetTexture(props) {
        const { sourceTextures: sourceTextures , textureOrReference: textureOrReference  } = props;
        if (textureOrReference instanceof (0, $df31c887249e3faa$export$2e2bcd8739ae039)) return textureOrReference;
        const refTexture = sourceTextures[textureOrReference];
        if (!refTexture) return null;
        this._targetRefTexName = textureOrReference;
        return this._createNewTexture(refTexture);
    }
    _setupTextures() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { sourceBuffers: sourceBuffers , _sourceTextures: _sourceTextures = {} , _targetTexture: _targetTexture  } = props;
        const targetTexture = this._createTargetTexture({
            sourceTextures: _sourceTextures,
            textureOrReference: _targetTexture
        });
        this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;
        this._updateBindings({
            sourceBuffers: sourceBuffers,
            sourceTextures: _sourceTextures,
            targetTexture: targetTexture
        });
        if ("elementCount" in props) this._updateElementIDBuffer(props.elementCount);
    }
    _updateElementIDBuffer(elementCount) {
        if (typeof elementCount !== "number" || this.elementCount >= elementCount) return;
        const elementIds = new Float32Array(elementCount);
        elementIds.forEach((_, index, array)=>{
            array[index] = index;
        });
        if (!this.elementIDBuffer) this.elementIDBuffer = new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(this.gl, {
            data: elementIds,
            accessor: {
                size: 1
            }
        });
        else this.elementIDBuffer.setData({
            data: elementIds
        });
        this.elementCount = elementCount;
    }
    _updateBindings(opts) {
        this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
        if (this._swapTexture) {
            const { sourceTextures: sourceTextures , targetTexture: targetTexture  } = this._swapTextures(this.bindings[this.currentIndex]);
            const nextIndex = this._getNextIndex();
            this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
                sourceTextures: sourceTextures,
                targetTexture: targetTexture
            });
        }
    }
    _updateBinding(binding, opts) {
        const { sourceBuffers: sourceBuffers , sourceTextures: sourceTextures , targetTexture: targetTexture  } = opts;
        if (!binding) binding = {
            sourceBuffers: {},
            sourceTextures: {},
            targetTexture: null
        };
        Object.assign(binding.sourceTextures, sourceTextures);
        Object.assign(binding.sourceBuffers, sourceBuffers);
        if (targetTexture) {
            binding.targetTexture = targetTexture;
            const { width: width , height: height  } = targetTexture;
            const { framebuffer: framebuffer  } = binding;
            if (framebuffer) {
                framebuffer.update({
                    attachments: {
                        [36064]: targetTexture
                    },
                    resizeAttachments: false
                });
                framebuffer.resize({
                    width: width,
                    height: height
                });
            } else binding.framebuffer = new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(this.gl, {
                id: "transform-framebuffer",
                width: width,
                height: height,
                attachments: {
                    [36064]: targetTexture
                }
            });
        }
        return binding;
    }
    _setSourceTextureParameters() {
        const index = this.currentIndex;
        const { sourceTextures: sourceTextures  } = this.bindings[index];
        for(const name in sourceTextures)sourceTextures[name].setParameters($30acc33c414d48f4$var$SRC_TEX_PARAMETER_OVERRIDES);
    }
    _swapTextures(opts) {
        if (!this._swapTexture) return null;
        const sourceTextures = Object.assign({}, opts.sourceTextures);
        sourceTextures[this._swapTexture] = opts.targetTexture;
        const targetTexture = opts.sourceTextures[this._swapTexture];
        return {
            sourceTextures: sourceTextures,
            targetTexture: targetTexture
        };
    }
    _createNewTexture(refTexture) {
        const texture = (0, $379077f7c038ee76$export$a502ec217e00cfb1)(refTexture, {
            parameters: {
                [10241]: 9728,
                [10240]: 9728,
                [10242]: 33071,
                [10243]: 33071
            },
            pixelStore: {
                [37440]: false
            }
        });
        if (this.ownTexture) this.ownTexture.delete();
        this.ownTexture = texture;
        return texture;
    }
    _getNextIndex() {
        return (this.currentIndex + 1) % 2;
    }
    _processVertexShader() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { sourceTextures: sourceTextures , targetTexture: targetTexture  } = this.bindings[this.currentIndex];
        const { vs: vs , uniforms: uniforms , targetTextureType: targetTextureType , inject: inject , samplerTextureMap: samplerTextureMap  } = (0, $dffd16a246e7d0e0$export$5a059e62d0049ef0)({
            vs: props.vs,
            sourceTextureMap: sourceTextures,
            targetTextureVarying: this.targetTextureVarying,
            targetTexture: targetTexture
        });
        const combinedInject = (0, $e03481e8f5a496cf$export$cef13ee8fb8f32f3)([
            props.inject || {},
            inject
        ]);
        this.targetTextureType = targetTextureType;
        this.samplerTextureMap = samplerTextureMap;
        const fs = props._fs || (0, $b14a5ab92b562947$export$523a4d4d9f32ef9e)({
            version: (0, $5cc96d47f4335f1d$export$2e2bcd8739ae039)(vs),
            input: this.targetTextureVarying,
            inputType: targetTextureType,
            output: $30acc33c414d48f4$var$FS_OUTPUT_VARIABLE
        });
        const modules = this.hasSourceTextures || this.targetTextureVarying ? [
            (0, $3812d8ee6528adfc$export$51186ad6e864892a)
        ].concat(props.modules || []) : props.modules;
        return {
            vs: vs,
            fs: fs,
            modules: modules,
            uniforms: uniforms,
            inject: combinedInject
        };
    }
}





class $00030bb52e16e5ae$export$2e2bcd8739ae039 {
    static isSupported(gl) {
        return (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl);
    }
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        this.gl = gl;
        this.model = null;
        this.elementCount = 0;
        this.bufferTransform = null;
        this.textureTransform = null;
        this.elementIDBuffer = null;
        this._initialize(props);
        Object.seal(this);
    }
    delete() {
        const { model: model , bufferTransform: bufferTransform , textureTransform: textureTransform  } = this;
        if (model) model.delete();
        if (bufferTransform) bufferTransform.delete();
        if (textureTransform) textureTransform.delete();
    }
    run() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { clearRenderTarget: clearRenderTarget = true  } = opts;
        const updatedOpts = this._updateDrawOptions(opts);
        if (clearRenderTarget && updatedOpts.framebuffer) updatedOpts.framebuffer.clear({
            color: true
        });
        this.model.transform(updatedOpts);
    }
    swap() {
        let swapped = false;
        const resourceTransforms = [
            this.bufferTransform,
            this.textureTransform
        ].filter(Boolean);
        for (const resourceTransform of resourceTransforms)swapped = swapped || resourceTransform.swap();
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(swapped, "Nothing to swap");
    }
    getBuffer() {
        let varyingName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);
    }
    getData() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const resourceTransforms = [
            this.bufferTransform,
            this.textureTransform
        ].filter(Boolean);
        for (const resourceTransform of resourceTransforms){
            const data = resourceTransform.getData(opts);
            if (data) return data;
        }
        return null;
    }
    getFramebuffer() {
        return this.textureTransform && this.textureTransform.getFramebuffer();
    }
    update() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if ("elementCount" in opts) this.model.setVertexCount(opts.elementCount);
        const resourceTransforms = [
            this.bufferTransform,
            this.textureTransform
        ].filter(Boolean);
        for (const resourceTransform of resourceTransforms)resourceTransform.update(opts);
    }
    _initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { gl: gl  } = this;
        this._buildResourceTransforms(gl, props);
        props = this._updateModelProps(props);
        this.model = new (0, $d4b5fa431316d551$export$2e2bcd8739ae039)(gl, Object.assign({}, props, {
            fs: props.fs || (0, $b14a5ab92b562947$export$523a4d4d9f32ef9e)({
                version: (0, $5cc96d47f4335f1d$export$2e2bcd8739ae039)(props.vs)
            }),
            id: props.id || "transform-model",
            drawMode: props.drawMode || 0,
            vertexCount: props.elementCount
        }));
        this.bufferTransform && this.bufferTransform.setupResources({
            model: this.model
        });
    }
    _updateModelProps(props) {
        let updatedProps = Object.assign({}, props);
        const resourceTransforms = [
            this.bufferTransform,
            this.textureTransform
        ].filter(Boolean);
        for (const resourceTransform of resourceTransforms)updatedProps = resourceTransform.updateModelProps(updatedProps);
        return updatedProps;
    }
    _buildResourceTransforms(gl, props) {
        if ($00030bb52e16e5ae$var$canCreateBufferTransform(props)) this.bufferTransform = new (0, $75029039b1643eaf$export$2e2bcd8739ae039)(gl, props);
        if ($00030bb52e16e5ae$var$canCreateTextureTransform(props)) this.textureTransform = new (0, $30acc33c414d48f4$export$2e2bcd8739ae039)(gl, props);
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(this.bufferTransform || this.textureTransform, "must provide source/feedback buffers or source/target textures");
    }
    _updateDrawOptions(opts) {
        let updatedOpts = Object.assign({}, opts);
        const resourceTransforms = [
            this.bufferTransform,
            this.textureTransform
        ].filter(Boolean);
        for (const resourceTransform of resourceTransforms)updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));
        return updatedOpts;
    }
}
function $00030bb52e16e5ae$var$canCreateBufferTransform(props) {
    if (!(0, $757dc76705f498e6$export$23cfe696632d10f4)(props.feedbackBuffers) || !(0, $757dc76705f498e6$export$23cfe696632d10f4)(props.feedbackMap) || props.varyings && props.varyings.length > 0) return true;
    return false;
}
function $00030bb52e16e5ae$var$canCreateTextureTransform(props) {
    if (!(0, $757dc76705f498e6$export$23cfe696632d10f4)(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) return true;
    return false;
}


const $71650ad4c5341938$export$7bd2e4b5b3cb4007 = {
    POINTS: 0x0000,
    LINES: 0x0001,
    LINE_LOOP: 0x0002,
    LINE_STRIP: 0x0003,
    TRIANGLES: 0x0004,
    TRIANGLE_STRIP: 0x0005,
    TRIANGLE_FAN: 0x0006
};
class $71650ad4c5341938$export$2e2bcd8739ae039 {
    static get DRAW_MODE() {
        return $71650ad4c5341938$export$7bd2e4b5b3cb4007;
    }
    constructor(){
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { id: id = (0, $757dc76705f498e6$export$e2a22331486dcca0)("geometry") , drawMode: drawMode = $71650ad4c5341938$export$7bd2e4b5b3cb4007.TRIANGLES , attributes: attributes = {} , indices: indices = null , vertexCount: vertexCount = null  } = props;
        this.id = id;
        this.drawMode = drawMode | 0;
        this.attributes = {};
        this.userData = {};
        this._setAttributes(attributes, indices);
        this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
    }
    get mode() {
        return this.drawMode;
    }
    getVertexCount() {
        return this.vertexCount;
    }
    getAttributes() {
        return this.indices ? {
            indices: this.indices,
            ...this.attributes
        } : this.attributes;
    }
    _print(attributeName) {
        return "Geometry ".concat(this.id, " attribute ").concat(attributeName);
    }
    _setAttributes(attributes, indices) {
        if (indices) this.indices = ArrayBuffer.isView(indices) ? {
            value: indices,
            size: 1
        } : indices;
        for(const attributeName in attributes){
            let attribute = attributes[attributeName];
            attribute = ArrayBuffer.isView(attribute) ? {
                value: attribute
            } : attribute;
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(ArrayBuffer.isView(attribute.value), "".concat(this._print(attributeName), ": must be typed array or object with value as typed array"));
            if ((attributeName === "POSITION" || attributeName === "positions") && !attribute.size) attribute.size = 3;
            if (attributeName === "indices") {
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(!this.indices);
                this.indices = attribute;
            } else this.attributes[attributeName] = attribute;
        }
        if (this.indices && this.indices.isIndexed !== undefined) {
            this.indices = Object.assign({}, this.indices);
            delete this.indices.isIndexed;
        }
        return this;
    }
    _calculateVertexCount(attributes, indices) {
        if (indices) return indices.value.length;
        let vertexCount = Infinity;
        for(const attributeName in attributes){
            const attribute = attributes[attributeName];
            const { value: value , size: size , constant: constant  } = attribute;
            if (!constant && value && size >= 1) vertexCount = Math.min(vertexCount, value.length / size);
        }
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(Number.isFinite(vertexCount));
        return vertexCount;
    }
}

let $bc7bc101e53b8e33$var$channelHandles = 1;
let $bc7bc101e53b8e33$var$animationHandles = 1;
class $bc7bc101e53b8e33$export$e6a97ba2cae5bb94 {
    constructor(){
        this.time = 0;
        this.channels = new Map();
        this.animations = new Map();
        this.playing = false;
        this.lastEngineTime = -1;
    }
    addChannel(props) {
        const { delay: delay = 0 , duration: duration = Number.POSITIVE_INFINITY , rate: rate = 1 , repeat: repeat = 1  } = props;
        const handle = $bc7bc101e53b8e33$var$channelHandles++;
        const channel = {
            time: 0,
            delay: delay,
            duration: duration,
            rate: rate,
            repeat: repeat
        };
        this._setChannelTime(channel, this.time);
        this.channels.set(handle, channel);
        return handle;
    }
    removeChannel(handle) {
        this.channels.delete(handle);
        for (const [animationHandle, animation] of this.animations)if (animation.channel === handle) this.detachAnimation(animationHandle);
    }
    isFinished(handle) {
        const channel = this.channels.get(handle);
        if (channel === undefined) return false;
        return this.time >= channel.delay + channel.duration * channel.repeat;
    }
    getTime(handle) {
        if (handle === undefined) return this.time;
        const channel = this.channels.get(handle);
        if (channel === undefined) return -1;
        return channel.time;
    }
    setTime(time) {
        this.time = Math.max(0, time);
        const channels = this.channels.values();
        for (const channel of channels)this._setChannelTime(channel, this.time);
        const animations = this.animations.values();
        for (const animationData of animations){
            const { animation: animation , channel: channel  } = animationData;
            animation.setTime(this.getTime(channel));
        }
    }
    play() {
        this.playing = true;
    }
    pause() {
        this.playing = false;
        this.lastEngineTime = -1;
    }
    reset() {
        this.setTime(0);
    }
    attachAnimation(animation, channelHandle) {
        const animationHandle = $bc7bc101e53b8e33$var$animationHandles++;
        this.animations.set(animationHandle, {
            animation: animation,
            channel: channelHandle
        });
        animation.setTime(this.getTime(channelHandle));
        return animationHandle;
    }
    detachAnimation(handle) {
        this.animations.delete(handle);
    }
    update(engineTime) {
        if (this.playing) {
            if (this.lastEngineTime === -1) this.lastEngineTime = engineTime;
            this.setTime(this.time + (engineTime - this.lastEngineTime));
            this.lastEngineTime = engineTime;
        }
    }
    _setChannelTime(channel, time) {
        const offsetTime = time - channel.delay;
        const totalDuration = channel.duration * channel.repeat;
        if (offsetTime >= totalDuration) channel.time = channel.duration * channel.rate;
        else {
            channel.time = Math.max(0, offsetTime) % channel.duration;
            channel.time *= channel.rate;
        }
    }
}






const $b87e42640c31b733$var$defines = "#define SMOOTH_EDGE_RADIUS 0.5";
const $b87e42640c31b733$var$vs = "\n".concat($b87e42640c31b733$var$defines, "\n\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry = VertexGeometry(\n  vec4(0.0, 0.0, 1.0, 0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec2(0.0),\n  vec3(0.0)\n);\n");
const $b87e42640c31b733$var$fs = "\n".concat($b87e42640c31b733$var$defines, "\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n");
var $b87e42640c31b733$export$2e2bcd8739ae039 = {
    name: "geometry",
    vs: $b87e42640c31b733$var$vs,
    fs: $b87e42640c31b733$var$fs
};



var $146cba582e8c799f$export$2e2bcd8739ae039 = new (0, $88fdfccabe5e323d$export$2e2bcd8739ae039)({
    id: "deck"
});


const $b42a5b9aa3b1a41f$export$e4ccd0285368e485 = {
    DEFAULT: -1,
    LNGLAT: 1,
    METER_OFFSETS: 2,
    LNGLAT_OFFSETS: 3,
    CARTESIAN: 0
};
Object.defineProperty($b42a5b9aa3b1a41f$export$e4ccd0285368e485, "IDENTITY", {
    get: ()=>{
        (0, $146cba582e8c799f$export$2e2bcd8739ae039).deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")();
        return 0;
    }
});
const $b42a5b9aa3b1a41f$export$3697aaebd269a548 = {
    WEB_MERCATOR: 1,
    GLOBE: 2,
    WEB_MERCATOR_AUTO_OFFSET: 4,
    IDENTITY: 0
};
const $b42a5b9aa3b1a41f$export$97361b7a0c542045 = {
    common: 0,
    meters: 1,
    pixels: 2
};
const $b42a5b9aa3b1a41f$export$fa3d5b535a2458a1 = {
    click: {
        handler: "onClick"
    },
    panstart: {
        handler: "onDragStart"
    },
    panmove: {
        handler: "onDrag"
    },
    panend: {
        handler: "onDragEnd"
    }
};
const $b42a5b9aa3b1a41f$export$b56168d831461ce2 = {
    DRAW: "draw",
    MASK: "mask"
};


const $b243d162a86ca83c$var$COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys((0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485)).map((key)=>"const int COORDINATE_SYSTEM_".concat(key, " = ").concat((0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485)[key], ";")).join("");
const $b243d162a86ca83c$var$PROJECTION_MODE_GLSL_CONSTANTS = Object.keys((0, $b42a5b9aa3b1a41f$export$3697aaebd269a548)).map((key)=>"const int PROJECTION_MODE_".concat(key, " = ").concat((0, $b42a5b9aa3b1a41f$export$3697aaebd269a548)[key], ";")).join("");
const $b243d162a86ca83c$var$UNIT_GLSL_CONSTANTS = Object.keys((0, $b42a5b9aa3b1a41f$export$97361b7a0c542045)).map((key)=>"const int UNIT_".concat(key.toUpperCase(), " = ").concat((0, $b42a5b9aa3b1a41f$export$97361b7a0c542045)[key], ";")).join("");
var $b243d162a86ca83c$export$2e2bcd8739ae039 = "".concat($b243d162a86ca83c$var$COORDINATE_SYSTEM_GLSL_CONSTANTS, "\n").concat($b243d162a86ca83c$var$PROJECTION_MODE_GLSL_CONSTANTS, "\n").concat($b243d162a86ca83c$var$UNIT_GLSL_CONSTANTS, '\n\nuniform int project_uCoordinateSystem;\nuniform int project_uProjectionMode;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\nuniform vec3 project_uCommonOrigin;\nuniform bool project_uPseudoMeters;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0; // meters\nconst float GLOBE_RADIUS = 256.0;\n\n// returns an adjustment factor for uCommonUnitsPerMeter\nfloat project_size() {\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\n    project_uPseudoMeters == false) {\n\n    // uCommonUnitsPerMeter in low-zoom Web Mercator is non-linear\n    // Adjust by 1 / cos(latitude)\n    // If geometry.position (vertex in common space) is populated, use it\n    // Otherwise use geometry.worldPosition (anchor in world space)\n    \n    if (geometry.position.w == 0.0) {\n      float y = clamp(geometry.worldPosition.y, -89.9, 89.9);\n      return 1.0 / cos(radians(y));\n    }\n\n    // latitude from common y: 2.0 * (atan(exp(y / TILE_SIZE * 2.0 * PI - PI)) - PI / 4.0)\n    // Taylor series of 1 / cos(latitude)\n    // Max error < 0.003\n  \n    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\n    float y2 = y * y;\n    float y4 = y2 * y2;\n    float y6 = y4 * y2;\n    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n  }\n  return 1.0;\n}\n//\n// Scaling offsets - scales meters to "world distance"\n// Note the scalar version of project_size is for scaling the z component only\n//\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size();\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy * project_size();\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter * project_size();\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\n\n// Get rotation matrix that aligns the z axis with the given up vector\n// Find 3 unit vectors ux, uy, uz that are perpendicular to each other and uz == up\nmat3 project_get_orientation_matrix(vec3 up) {\n  vec3 uz = normalize(up);\n  // Tangent on XY plane\n  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\n  vec3 uy = cross(uz, ux);\n  return mat3(ux, uy, uz);\n}\n\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    transform = project_get_orientation_matrix(commonPosition);\n    return true;\n  }\n  return false;\n}\n\n//\n// Projecting normal - transform deltas from current coordinate system to\n// normals in the worldspace\n//\nvec3 project_normal(vec3 vector) {\n  // Apply model matrix\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n  mat3 rotation;\n  if (project_needs_rotation(geometry.position.xyz, rotation)) {\n    n = rotation * n;\n  }\n  return n;\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\n\n//\n// Projecting positions - non-linear projection: lnglats => unit tile [0-1, 0-1]\n//\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x + 180., 360.0) - 180.;\n  }\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\nvec3 project_globe_(vec3 lnglatz) {\n  float lambda = radians(lnglatz.x);\n  float phi = radians(lnglatz.y);\n  float cosPhi = cos(phi);\n  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n\n  return vec3(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\n\n//\n// Projects positions (defined by project_uCoordinateSystem) to common space (defined by project_uProjectionMode)\n//\nvec4 project_position(vec4 position, vec3 position64Low) {\n  vec4 position_world = project_uModelMatrix * position;\n\n  // Work around for a Mac+NVIDIA bug https://github.com/visgl/deck.gl/issues/4145\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_mercator_(position_world.xy),\n        project_size(position_world.z),\n        position_world.w\n      );\n    }\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world.xyz += project_uCoordinateOrigin;\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {\n        // Too far from the projection center for offset mode to be accurate\n        // Only use high parts\n        return vec4(\n          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,\n          project_size(position_world.z),\n          position_world.w\n        );\n      }\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||\n    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    // Subtract high part of 64 bit value. Convert remainder to float32, preserving precision.\n    position_world.xyz -= project_uCoordinateOrigin;\n  }\n\n  // Translation is already added to the high parts\n  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_LOW);\n}\n\nvec3 project_position(vec3 position, vec3 position64Low) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  return viewProjectionMatrix * position + center;\n}\n\n//\n// Projects from common space coordinates to clip space.\n// Uses project_uViewProjectionMatrix\n//\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\n\n// Returns a clip space offset that corresponds to a given number of screen pixels\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters) * project_uScale;\n}\nfloat project_size_to_pixel(float size, int unit) {\n  if (unit == UNIT_METERS) return project_size_to_pixel(size);\n  if (unit == UNIT_COMMON) return size * project_uScale;\n  // UNIT_PIXELS\n  return size;\n}\nfloat project_pixel_size(float pixels) {\n  return pixels / project_uScale;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels / project_uScale;\n}\n');


var $90626a8105199b14$export$fd293b15f47e270 = 0.000001;
var $90626a8105199b14$export$b67359430d3b1b2 = typeof Float32Array !== "undefined" ? Float32Array : Array;
var $90626a8105199b14$export$5ada478c8a628231 = Math.random;
function $90626a8105199b14$export$cb2c0eb57f5e532c(type) {
    $90626a8105199b14$export$b67359430d3b1b2 = type;
}
var $90626a8105199b14$var$degree = Math.PI / 180;
function $90626a8105199b14$export$408b8ee5959eefd5(a) {
    return a * $90626a8105199b14$var$degree;
}
function $90626a8105199b14$export$e9bab7fafb253603(a, b) {
    return Math.abs(a - b) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function() {
    var y = 0, i = arguments.length;
    while(i--)y += arguments[i] * arguments[i];
    return Math.sqrt(y);
};


function $46ec5f9ed0e75076$export$185802fd694ee1f5() {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(16);
    if ($90626a8105199b14$export$b67359430d3b1b2 != Float32Array) {
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
    }
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$9cd59f9826255e47(a) {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function $46ec5f9ed0e75076$export$784d13d8ee351f07(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function $46ec5f9ed0e75076$export$a82be99ed2a44a7d(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
}
function $46ec5f9ed0e75076$export$adaa4cf7ef1b65be(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
}
function $46ec5f9ed0e75076$export$f0954fd7d5368655(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$9cb09a71b7d66923(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3];
        var a12 = a[6], a13 = a[7];
        var a23 = a[11];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    return out;
}
function $46ec5f9ed0e75076$export$6897c284b6f9f4dc(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) return null;
    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
}
function $46ec5f9ed0e75076$export$33f3c024b4ae00a1(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
}
function $46ec5f9ed0e75076$export$a04698f914c55ed9(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function $46ec5f9ed0e75076$export$2060d2db72cce88f(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15]; // Cache only the current line of the second matrix
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
}
function $46ec5f9ed0e75076$export$d73ee8ef04f5226a(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0];
        a01 = a[1];
        a02 = a[2];
        a03 = a[3];
        a10 = a[4];
        a11 = a[5];
        a12 = a[6];
        a13 = a[7];
        a20 = a[8];
        a21 = a[9];
        a22 = a[10];
        a23 = a[11];
        out[0] = a00;
        out[1] = a01;
        out[2] = a02;
        out[3] = a03;
        out[4] = a10;
        out[5] = a11;
        out[6] = a12;
        out[7] = a13;
        out[8] = a20;
        out[9] = a21;
        out[10] = a22;
        out[11] = a23;
        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
}
function $46ec5f9ed0e75076$export$dcdf75081b88279d(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function $46ec5f9ed0e75076$export$bb628a54ab399bc9(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;
    if (len < $90626a8105199b14$export$fd293b15f47e270) return null;
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11]; // Construct the elements of the rotation matrix
    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c; // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a !== out) {
        // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
}
function $46ec5f9ed0e75076$export$a59c8716592e09af(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    } // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
}
function $46ec5f9ed0e75076$export$cf71e4d4ca4d1cfd(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    } // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
}
function $46ec5f9ed0e75076$export$ea6eae3365de5b9c(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged last row
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    } // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
}
function $46ec5f9ed0e75076$export$bc9e79e74e9fddf6(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$832ca188ffb1955d(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$926fc125ff3c666c(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;
    if (len < $90626a8105199b14$export$fd293b15f47e270) return null;
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c; // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$dd47cc2f828c32ef(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$7dc997d67d2b7f33(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication
    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$ad5ddaedc8f405df(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$9545ac307f2a256b(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$ff497f2be31cc6a(out, a) {
    var translation = new $90626a8105199b14$export$b67359430d3b1b2(3);
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
    var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense
    if (magnitude > 0) {
        translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
        translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
        translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
        translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
        translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
        translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    $46ec5f9ed0e75076$export$9545ac307f2a256b(out, a, translation);
    return out;
}
function $46ec5f9ed0e75076$export$202e99f82f7f0395(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
}
function $46ec5f9ed0e75076$export$71dc54d92bd04b57(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.hypot(m11, m12, m13);
    out[1] = Math.hypot(m21, m22, m23);
    out[2] = Math.hypot(m31, m32, m33);
    return out;
}
function $46ec5f9ed0e75076$export$df3937d3b537df0a(out, mat) {
    var scaling = new $90626a8105199b14$export$b67359430d3b1b2(3);
    $46ec5f9ed0e75076$export$71dc54d92bd04b57(scaling, mat);
    var is1 = 1 / scaling[0];
    var is2 = 1 / scaling[1];
    var is3 = 1 / scaling[2];
    var sm11 = mat[0] * is1;
    var sm12 = mat[1] * is2;
    var sm13 = mat[2] * is3;
    var sm21 = mat[4] * is1;
    var sm22 = mat[5] * is2;
    var sm23 = mat[6] * is3;
    var sm31 = mat[8] * is1;
    var sm32 = mat[9] * is2;
    var sm33 = mat[10] * is3;
    var trace = sm11 + sm22 + sm33;
    var S = 0;
    if (trace > 0) {
        S = Math.sqrt(trace + 1.0) * 2;
        out[3] = 0.25 * S;
        out[0] = (sm23 - sm32) / S;
        out[1] = (sm31 - sm13) / S;
        out[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
        S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
        out[3] = (sm23 - sm32) / S;
        out[0] = 0.25 * S;
        out[1] = (sm12 + sm21) / S;
        out[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
        S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
        out[3] = (sm31 - sm13) / S;
        out[0] = (sm12 + sm21) / S;
        out[1] = 0.25 * S;
        out[2] = (sm23 + sm32) / S;
    } else {
        S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
        out[3] = (sm12 - sm21) / S;
        out[0] = (sm31 + sm13) / S;
        out[1] = (sm23 + sm32) / S;
        out[2] = 0.25 * S;
    }
    return out;
}
function $46ec5f9ed0e75076$export$ddf9c55c9f2be172(out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$1def1f860edc4b1f(out, q, v, s, o) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    var ox = o[0];
    var oy = o[1];
    var oz = o[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$2ff2bbe382249af7(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$89b5708c387cac6c(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
}
function $46ec5f9ed0e75076$export$4cf19729ec9a96b8(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2), nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
        nf = 1 / (near - far);
        out[10] = (far + near) * nf;
        out[14] = 2 * far * near * nf;
    } else {
        out[10] = -1;
        out[14] = -2 * near;
    }
    return out;
}
var $46ec5f9ed0e75076$export$541149539f3a4684 = $46ec5f9ed0e75076$export$4cf19729ec9a96b8;
function $46ec5f9ed0e75076$export$294bba99a6af0c0c(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2), nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
        nf = 1 / (near - far);
        out[10] = far * nf;
        out[14] = far * near * nf;
    } else {
        out[10] = -1;
        out[14] = -near;
    }
    return out;
}
function $46ec5f9ed0e75076$export$58ae211c788e338f(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
    var xScale = 2.0 / (leftTan + rightTan);
    var yScale = 2.0 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = far * near / (near - far);
    out[15] = 0.0;
    return out;
}
function $46ec5f9ed0e75076$export$c5f65ef3eb668f27(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
}
var $46ec5f9ed0e75076$export$4f2167e613cfc87b = $46ec5f9ed0e75076$export$c5f65ef3eb668f27;
function $46ec5f9ed0e75076$export$b1d31ea7b4d854e(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = near * nf;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$d924e14fd6d9aa66(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];
    if (Math.abs(eyex - centerx) < $90626a8105199b14$export$fd293b15f47e270 && Math.abs(eyey - centery) < $90626a8105199b14$export$fd293b15f47e270 && Math.abs(eyez - centerz) < $90626a8105199b14$export$fd293b15f47e270) return $46ec5f9ed0e75076$export$f0954fd7d5368655(out);
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.hypot(z0, z1, z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.hypot(x0, x1, x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.hypot(y0, y1, y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$aa67782f4dc9e52c(out, eye, target, up) {
    var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
    var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
    var len = z0 * z0 + z1 * z1 + z2 * z2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        z0 *= len;
        z1 *= len;
        z2 *= len;
    }
    var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$42d51816ce590c93(a) {
    return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
function $46ec5f9ed0e75076$export$326827e8268e9cdb(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
function $46ec5f9ed0e75076$export$e16d8520af44a096(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
}
function $46ec5f9ed0e75076$export$4e2d2ead65e5f7e3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
}
function $46ec5f9ed0e75076$export$c697bed75648cdb7(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
}
function $46ec5f9ed0e75076$export$553579f63bdd7137(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    out[4] = a[4] + b[4] * scale1;
    out[5] = a[5] + b[5] * scale1;
    out[6] = a[6] + b[6] * scale1;
    out[7] = a[7] + b[7] * scale1;
    out[8] = a[8] + b[8] * scale1;
    out[9] = a[9] + b[9] * scale1;
    out[10] = a[10] + b[10] * scale1;
    out[11] = a[11] + b[11] * scale1;
    out[12] = a[12] + b[12] * scale1;
    out[13] = a[13] + b[13] * scale1;
    out[14] = a[14] + b[14] * scale1;
    out[15] = a[15] + b[15] * scale1;
    return out;
}
function $46ec5f9ed0e75076$export$f2599a5cf1109d8(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
function $46ec5f9ed0e75076$export$e9bab7fafb253603(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
    var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
    var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
    var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
    var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    return Math.abs(a0 - b0) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
var $46ec5f9ed0e75076$export$6e3a27864ab166fe = $46ec5f9ed0e75076$export$2060d2db72cce88f;
var $46ec5f9ed0e75076$export$f93b5905241a7cca = $46ec5f9ed0e75076$export$4e2d2ead65e5f7e3;



function $bd1e837fe7e33410$export$185802fd694ee1f5() {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(4);
    if ($90626a8105199b14$export$b67359430d3b1b2 != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
    }
    return out;
}
function $bd1e837fe7e33410$export$9cd59f9826255e47(a) {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function $bd1e837fe7e33410$export$a82be99ed2a44a7d(x, y, z, w) {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
}
function $bd1e837fe7e33410$export$784d13d8ee351f07(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function $bd1e837fe7e33410$export$adaa4cf7ef1b65be(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
}
function $bd1e837fe7e33410$export$e16d8520af44a096(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
}
function $bd1e837fe7e33410$export$4e2d2ead65e5f7e3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
}
function $bd1e837fe7e33410$export$2060d2db72cce88f(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
}
function $bd1e837fe7e33410$export$cd007d971a5a2143(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
}
function $bd1e837fe7e33410$export$803ce6b71a0a94b2(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
}
function $bd1e837fe7e33410$export$a3fe094919f356fd(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
}
function $bd1e837fe7e33410$export$96ec731ed4dcb222(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
}
function $bd1e837fe7e33410$export$8960430cfd85939f(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
}
function $bd1e837fe7e33410$export$2077e0241d6afd3c(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
}
function $bd1e837fe7e33410$export$dcdf75081b88279d(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
}
function $bd1e837fe7e33410$export$19cedf1da84ba854(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    return out;
}
function $bd1e837fe7e33410$export$9f17032d917177de(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return Math.hypot(x, y, z, w);
}
function $bd1e837fe7e33410$export$88e6ebb4fe54f538(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return x * x + y * y + z * z + w * w;
}
function $bd1e837fe7e33410$export$f24224f1c91d8156(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return Math.hypot(x, y, z, w);
}
function $bd1e837fe7e33410$export$ab44e1323ffc8376(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return x * x + y * y + z * z + w * w;
}
function $bd1e837fe7e33410$export$aef51622e549b8b0(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
}
function $bd1e837fe7e33410$export$70ae2c07e401031b(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    out[2] = 1.0 / a[2];
    out[3] = 1.0 / a[3];
    return out;
}
function $bd1e837fe7e33410$export$a3295358bff77e(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len1 = x * x + y * y + z * z + w * w;
    if (len1 > 0) len1 = 1 / Math.sqrt(len1);
    out[0] = x * len1;
    out[1] = y * len1;
    out[2] = z * len1;
    out[3] = w * len1;
    return out;
}
function $bd1e837fe7e33410$export$94132a0e348806d4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
function $bd1e837fe7e33410$export$bb646b20bb93d339(out, u, v, w) {
    var A = v[0] * w[1] - v[1] * w[0], B = v[0] * w[2] - v[2] * w[0], C = v[0] * w[3] - v[3] * w[0], D = v[1] * w[2] - v[2] * w[1], E = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
    var G = u[0];
    var H = u[1];
    var I = u[2];
    var J = u[3];
    out[0] = H * F - I * E + J * D;
    out[1] = -(G * F) + I * C - J * B;
    out[2] = G * E - H * C + J * A;
    out[3] = -(G * D) + H * B - I * A;
    return out;
}
function $bd1e837fe7e33410$export$3a89f8d6f6bf6c9f(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
}
function $bd1e837fe7e33410$export$4385e60b38654f68(out, scale2) {
    scale2 = scale2 || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
    // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
    // http://projecteuclid.org/euclid.aoms/1177692644;
    var v1, v2, v3, v4;
    var s1, s2;
    do {
        v1 = $90626a8105199b14$export$5ada478c8a628231() * 2 - 1;
        v2 = $90626a8105199b14$export$5ada478c8a628231() * 2 - 1;
        s1 = v1 * v1 + v2 * v2;
    }while (s1 >= 1);
    do {
        v3 = $90626a8105199b14$export$5ada478c8a628231() * 2 - 1;
        v4 = $90626a8105199b14$export$5ada478c8a628231() * 2 - 1;
        s2 = v3 * v3 + v4 * v4;
    }while (s2 >= 1);
    var d = Math.sqrt((1 - s1) / s2);
    out[0] = scale2 * v1;
    out[1] = scale2 * v2;
    out[2] = scale2 * v3 * d;
    out[3] = scale2 * v4 * d;
    return out;
}
function $bd1e837fe7e33410$export$5ffbd13800309d59(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
}
function $bd1e837fe7e33410$export$c32adef9e939ce85(out, a, q) {
    var x = a[0], y = a[1], z = a[2];
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3]; // calculate quat * vec
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
}
function $bd1e837fe7e33410$export$7f9972325ebfd559(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    return out;
}
function $bd1e837fe7e33410$export$42d51816ce590c93(a) {
    return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
function $bd1e837fe7e33410$export$f2599a5cf1109d8(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function $bd1e837fe7e33410$export$e9bab7fafb253603(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return Math.abs(a0 - b0) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
var $bd1e837fe7e33410$export$f93b5905241a7cca = $bd1e837fe7e33410$export$4e2d2ead65e5f7e3;
var $bd1e837fe7e33410$export$6e3a27864ab166fe = $bd1e837fe7e33410$export$2060d2db72cce88f;
var $bd1e837fe7e33410$export$159d9494db57879b = $bd1e837fe7e33410$export$cd007d971a5a2143;
var $bd1e837fe7e33410$export$6c4a311cc157c764 = $bd1e837fe7e33410$export$9f17032d917177de;
var $bd1e837fe7e33410$export$2422cd6c492a8b3a = $bd1e837fe7e33410$export$88e6ebb4fe54f538;
var $bd1e837fe7e33410$export$fc1400facf92c78 = $bd1e837fe7e33410$export$f24224f1c91d8156;
var $bd1e837fe7e33410$export$99d8dd3f32a3435 = $bd1e837fe7e33410$export$ab44e1323ffc8376;
var $bd1e837fe7e33410$export$4b80e395e36b5a56 = function() {
    var vec = $bd1e837fe7e33410$export$185802fd694ee1f5();
    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if (!stride) stride = 4;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            vec[2] = a[i + 2];
            vec[3] = a[i + 3];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
            a[i + 2] = vec[2];
            a[i + 3] = vec[3];
        }
        return a;
    };
}();



function $1ccdae01919b6bce$var$isEqual(a, b) {
    if (a === b) return true;
    if (Array.isArray(a)) {
        const len = a.length;
        if (!b || b.length !== len) return false;
        for(let i = 0; i < len; i++){
            if (a[i] !== b[i]) return false;
        }
        return true;
    }
    return false;
}
function $1ccdae01919b6bce$export$2e2bcd8739ae039(compute) {
    let cachedArgs = {};
    let cachedResult;
    return (args)=>{
        for(const key in args)if (!$1ccdae01919b6bce$var$isEqual(args[key], cachedArgs[key])) {
            cachedResult = compute(args);
            cachedArgs = args;
            break;
        }
        return cachedResult;
    };
}


const $072d6f1b352f2883$var$ZERO_VECTOR = [
    0,
    0,
    0,
    0
];
const $072d6f1b352f2883$var$VECTOR_TO_POINT_MATRIX = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0
];
const $072d6f1b352f2883$var$IDENTITY_MATRIX = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
];
const $072d6f1b352f2883$var$DEFAULT_PIXELS_PER_UNIT2 = [
    0,
    0,
    0
];
const $072d6f1b352f2883$var$DEFAULT_COORDINATE_ORIGIN = [
    0,
    0,
    0
];
const $072d6f1b352f2883$var$getMemoizedViewportUniforms = (0, $1ccdae01919b6bce$export$2e2bcd8739ae039)($072d6f1b352f2883$var$calculateViewportUniforms);
function $072d6f1b352f2883$export$20f9eb1a42fcd22d(viewport, coordinateSystem, coordinateOrigin = $072d6f1b352f2883$var$DEFAULT_COORDINATE_ORIGIN) {
    if (coordinateOrigin.length < 3) coordinateOrigin = [
        coordinateOrigin[0],
        coordinateOrigin[1],
        0
    ];
    let shaderCoordinateOrigin = coordinateOrigin;
    let geospatialOrigin;
    let offsetMode = true;
    if (coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT_OFFSETS || coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).METER_OFFSETS) geospatialOrigin = coordinateOrigin;
    else geospatialOrigin = viewport.isGeospatial ? [
        Math.fround(viewport.longitude),
        Math.fround(viewport.latitude),
        0
    ] : null;
    switch(viewport.projectionMode){
        case (0, $b42a5b9aa3b1a41f$export$3697aaebd269a548).WEB_MERCATOR:
            if (coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT || coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).CARTESIAN) {
                geospatialOrigin = [
                    0,
                    0,
                    0
                ];
                offsetMode = false;
            }
            break;
        case (0, $b42a5b9aa3b1a41f$export$3697aaebd269a548).WEB_MERCATOR_AUTO_OFFSET:
            if (coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT) shaderCoordinateOrigin = geospatialOrigin;
            else if (coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).CARTESIAN) {
                shaderCoordinateOrigin = [
                    Math.fround(viewport.center[0]),
                    Math.fround(viewport.center[1]),
                    0
                ];
                geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);
                shaderCoordinateOrigin[0] -= coordinateOrigin[0];
                shaderCoordinateOrigin[1] -= coordinateOrigin[1];
                shaderCoordinateOrigin[2] -= coordinateOrigin[2];
            }
            break;
        case (0, $b42a5b9aa3b1a41f$export$3697aaebd269a548).IDENTITY:
            shaderCoordinateOrigin = viewport.position.map(Math.fround);
            shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
            break;
        case (0, $b42a5b9aa3b1a41f$export$3697aaebd269a548).GLOBE:
            offsetMode = false;
            geospatialOrigin = null;
            break;
        default:
            offsetMode = false;
    }
    return {
        geospatialOrigin: geospatialOrigin,
        shaderCoordinateOrigin: shaderCoordinateOrigin,
        offsetMode: offsetMode
    };
}
function $072d6f1b352f2883$var$calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {
    const { viewMatrixUncentered: viewMatrixUncentered , projectionMatrix: projectionMatrix  } = viewport;
    let { viewMatrix: viewMatrix , viewProjectionMatrix: viewProjectionMatrix  } = viewport;
    let projectionCenter = $072d6f1b352f2883$var$ZERO_VECTOR;
    let originCommon = $072d6f1b352f2883$var$ZERO_VECTOR;
    let cameraPosCommon = viewport.cameraPosition;
    const { geospatialOrigin: geospatialOrigin , shaderCoordinateOrigin: shaderCoordinateOrigin , offsetMode: offsetMode  } = $072d6f1b352f2883$export$20f9eb1a42fcd22d(viewport, coordinateSystem, coordinateOrigin);
    if (offsetMode) {
        originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
        cameraPosCommon = [
            cameraPosCommon[0] - originCommon[0],
            cameraPosCommon[1] - originCommon[1],
            cameraPosCommon[2] - originCommon[2]
        ];
        originCommon[3] = 1;
        projectionCenter = $bd1e837fe7e33410$export$5ffbd13800309d59([], originCommon, viewProjectionMatrix);
        viewMatrix = viewMatrixUncentered || viewMatrix;
        viewProjectionMatrix = $46ec5f9ed0e75076$export$2060d2db72cce88f([], projectionMatrix, viewMatrix);
        viewProjectionMatrix = $46ec5f9ed0e75076$export$2060d2db72cce88f([], viewProjectionMatrix, $072d6f1b352f2883$var$VECTOR_TO_POINT_MATRIX);
    }
    return {
        viewMatrix: viewMatrix,
        viewProjectionMatrix: viewProjectionMatrix,
        projectionCenter: projectionCenter,
        originCommon: originCommon,
        cameraPosCommon: cameraPosCommon,
        shaderCoordinateOrigin: shaderCoordinateOrigin,
        geospatialOrigin: geospatialOrigin
    };
}
function $072d6f1b352f2883$export$31173c1846951f93({ viewport: viewport , devicePixelRatio: devicePixelRatio = 1 , modelMatrix: modelMatrix = null , coordinateSystem: coordinateSystem = (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).DEFAULT , coordinateOrigin: coordinateOrigin = $072d6f1b352f2883$var$DEFAULT_COORDINATE_ORIGIN , autoWrapLongitude: autoWrapLongitude = false  }) {
    if (coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).DEFAULT) coordinateSystem = viewport.isGeospatial ? (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT : (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).CARTESIAN;
    const uniforms = $072d6f1b352f2883$var$getMemoizedViewportUniforms({
        viewport: viewport,
        devicePixelRatio: devicePixelRatio,
        coordinateSystem: coordinateSystem,
        coordinateOrigin: coordinateOrigin
    });
    uniforms.project_uWrapLongitude = autoWrapLongitude;
    uniforms.project_uModelMatrix = modelMatrix || $072d6f1b352f2883$var$IDENTITY_MATRIX;
    return uniforms;
}
function $072d6f1b352f2883$var$calculateViewportUniforms({ viewport: viewport , devicePixelRatio: devicePixelRatio , coordinateSystem: coordinateSystem , coordinateOrigin: coordinateOrigin  }) {
    const { projectionCenter: projectionCenter , viewProjectionMatrix: viewProjectionMatrix , originCommon: originCommon , cameraPosCommon: cameraPosCommon , shaderCoordinateOrigin: shaderCoordinateOrigin , geospatialOrigin: geospatialOrigin  } = $072d6f1b352f2883$var$calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);
    const distanceScales = viewport.getDistanceScales();
    const viewportSize = [
        viewport.width * devicePixelRatio,
        viewport.height * devicePixelRatio
    ];
    const focalDistance = $bd1e837fe7e33410$export$5ffbd13800309d59([], [
        0,
        0,
        -viewport.focalDistance,
        1
    ], viewport.projectionMatrix)[3] || 1;
    const uniforms = {
        project_uCoordinateSystem: coordinateSystem,
        project_uProjectionMode: viewport.projectionMode,
        project_uCoordinateOrigin: shaderCoordinateOrigin,
        project_uCommonOrigin: originCommon.slice(0, 3),
        project_uCenter: projectionCenter,
        project_uPseudoMeters: Boolean(viewport._pseudoMeters),
        project_uViewportSize: viewportSize,
        project_uDevicePixelRatio: devicePixelRatio,
        project_uFocalDistance: focalDistance,
        project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,
        project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
        project_uCommonUnitsPerWorldUnit2: $072d6f1b352f2883$var$DEFAULT_PIXELS_PER_UNIT2,
        project_uScale: viewport.scale,
        project_uWrapLongitude: false,
        project_uViewProjectionMatrix: viewProjectionMatrix,
        project_uModelMatrix: $072d6f1b352f2883$var$IDENTITY_MATRIX,
        project_uCameraPosition: cameraPosCommon
    };
    if (geospatialOrigin) {
        const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);
        switch(coordinateSystem){
            case (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).METER_OFFSETS:
                uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
                uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
                break;
            case (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT:
            case (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT_OFFSETS:
                if (!viewport._pseudoMeters) uniforms.project_uCommonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;
                uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
                uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
                break;
            case (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).CARTESIAN:
                uniforms.project_uCommonUnitsPerWorldUnit = [
                    1,
                    1,
                    distanceScalesAtOrigin.unitsPerMeter[2]
                ];
                uniforms.project_uCommonUnitsPerWorldUnit2 = [
                    0,
                    0,
                    distanceScalesAtOrigin.unitsPerMeter2[2]
                ];
                break;
            default:
                break;
        }
    }
    return uniforms;
}


const $669f9ad1259ddfee$var$INITIAL_MODULE_OPTIONS = {};
function $669f9ad1259ddfee$var$getUniforms(opts = $669f9ad1259ddfee$var$INITIAL_MODULE_OPTIONS) {
    if ("viewport" in opts) return (0, $072d6f1b352f2883$export$31173c1846951f93)(opts);
    return {};
}
var $669f9ad1259ddfee$export$2e2bcd8739ae039 = {
    name: "project",
    dependencies: [
        (0, $65fa5645ea84a164$export$d4bf4ab3180407a1),
        (0, $b87e42640c31b733$export$2e2bcd8739ae039)
    ],
    vs: (0, $b243d162a86ca83c$export$2e2bcd8739ae039),
    getUniforms: $669f9ad1259ddfee$var$getUniforms
};



const $fbfc65ad8db06720$var$vs = "\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  mat3 rotation;\n  if (project_needs_rotation(projectedPosition, rotation)) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n";
var $fbfc65ad8db06720$export$2e2bcd8739ae039 = {
    name: "project32",
    dependencies: [
        (0, $669f9ad1259ddfee$export$2e2bcd8739ae039)
    ],
    vs: $fbfc65ad8db06720$var$vs
};




var $1c9ba1aa9caca970$export$2e2bcd8739ae039 = {
    inject: {
        "vs:DECKGL_FILTER_GL_POSITION": "\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  ",
        "vs:DECKGL_FILTER_COLOR": "\n  picking_setPickingColor(geometry.pickingColor);\n  ",
        "fs:DECKGL_FILTER_COLOR": {
            order: 99,
            injection: "\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    "
        }
    },
    ...(0, $7e9d081b840cbf62$export$1f1790962c6071cf)
};


const $c6e8420d48e336f1$var$DEFAULT_MODULES = [
    (0, $669f9ad1259ddfee$export$2e2bcd8739ae039)
];
const $c6e8420d48e336f1$var$SHADER_HOOKS = [
    "vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)",
    "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)",
    "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)",
    "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"
];
function $c6e8420d48e336f1$export$249fec8be25f60d5(gl) {
    const programManager = (0, $389aec4f13e2bfb5$export$2e2bcd8739ae039).getDefaultProgramManager(gl);
    for (const shaderModule of $c6e8420d48e336f1$var$DEFAULT_MODULES)programManager.addDefaultModule(shaderModule);
    for (const shaderHook of $c6e8420d48e336f1$var$SHADER_HOOKS)programManager.addShaderHook(shaderHook);
    return programManager;
}




const $434611e3e90ee53e$export$2cb9787dd463cbf4 = {
    NO_STATE: "Awaiting state",
    MATCHED: "Matched. State transferred from previous layer",
    INITIALIZED: "Initialized",
    AWAITING_GC: "Discarded. Awaiting garbage collection",
    AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
    FINALIZED: "Finalized! Awaiting garbage collection"
};
const $434611e3e90ee53e$export$47f4402f338dd1fc = Symbol.for("component");
const $434611e3e90ee53e$export$23f7c42255df7b05 = Symbol.for("asyncPropDefaults");
const $434611e3e90ee53e$export$c313d789070da88c = Symbol.for("asyncPropOriginal");
const $434611e3e90ee53e$export$40aefa3472633071 = Symbol.for("asyncPropResolved");





let $e34c41f170d77ab6$var$loggers = {};
function $e34c41f170d77ab6$export$6503ec6e8aabbaf(handlers) {
    $e34c41f170d77ab6$var$loggers = handlers;
}
function $e34c41f170d77ab6$export$2e2bcd8739ae039(eventType, arg1, arg2, arg3) {
    if ((0, $146cba582e8c799f$export$2e2bcd8739ae039).level > 0 && $e34c41f170d77ab6$var$loggers[eventType]) $e34c41f170d77ab6$var$loggers[eventType].call(null, arg1, arg2, arg3);
}


function $755f3c37a143f46e$export$bffa455ba8c619a6(array, filter = ()=>true) {
    if (!Array.isArray(array)) return filter(array) ? [
        array
    ] : [];
    return $755f3c37a143f46e$var$flattenArray(array, filter, []);
}
function $755f3c37a143f46e$var$flattenArray(array, filter, result) {
    let index = -1;
    while(++index < array.length){
        const value = array[index];
        if (Array.isArray(value)) $755f3c37a143f46e$var$flattenArray(value, filter, result);
        else if (filter(value)) result.push(value);
    }
    return result;
}
function $755f3c37a143f46e$export$57295b69bf9c5d15({ target: target , source: source , start: start = 0 , count: count = 1  }) {
    const length = source.length;
    const total = count * length;
    let copied = 0;
    for(let i = start; copied < length; copied++)target[i++] = source[copied];
    while(copied < total)if (copied < total - copied) {
        target.copyWithin(start + copied, start, start + copied);
        copied *= 2;
    } else {
        target.copyWithin(start + copied, start, start + total - copied);
        copied = total;
    }
    return target;
}





var $51a006089e505849$exports = {};

$parcel$export($51a006089e505849$exports, "filename", () => $51a006089e505849$export$f9107b66120eb036);
$parcel$export($51a006089e505849$exports, "dirname", () => $51a006089e505849$export$7f7b8152cc673abe);
$parcel$export($51a006089e505849$exports, "join", () => $51a006089e505849$export$f7e2c8231c57a8bd);
function $51a006089e505849$export$f9107b66120eb036(url) {
    const slashIndex = url && url.lastIndexOf("/");
    return slashIndex >= 0 ? url.substr(slashIndex + 1) : "";
}
function $51a006089e505849$export$7f7b8152cc673abe(url) {
    const slashIndex = url && url.lastIndexOf("/");
    return slashIndex >= 0 ? url.substr(0, slashIndex) : "";
}
function $51a006089e505849$export$f7e2c8231c57a8bd(...parts) {
    const separator = "/";
    parts = parts.map((part, index)=>{
        if (index) part = part.replace(new RegExp("^".concat(separator)), "");
        if (index !== parts.length - 1) part = part.replace(new RegExp("".concat(separator, "$")), "");
        return part;
    });
    return parts.join(separator);
}

function $e2d3345494943a51$export$a7a9523472993e97(condition, message) {
    if (!condition) throw new Error(message || "loader assertion failed.");
}


const $4684b3280a916bc3$var$globals = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof $parcel$global !== "undefined" && $parcel$global,
    document: typeof document !== "undefined" && document
};
const $4684b3280a916bc3$export$82c2e460fb230c2a = $4684b3280a916bc3$var$globals.self || $4684b3280a916bc3$var$globals.window || $4684b3280a916bc3$var$globals.global || {};
const $4684b3280a916bc3$export$8291e5b88f90ce4 = $4684b3280a916bc3$var$globals.window || $4684b3280a916bc3$var$globals.self || $4684b3280a916bc3$var$globals.global || {};
const $4684b3280a916bc3$export$90b4d2ff6acb88af = $4684b3280a916bc3$var$globals.global || $4684b3280a916bc3$var$globals.self || $4684b3280a916bc3$var$globals.window || {};
const $4684b3280a916bc3$export$5a7bfc01df82fcd1 = $4684b3280a916bc3$var$globals.document || {};
const $4684b3280a916bc3$export$4e09c449d6c407f7 = Boolean(typeof $7jljs$process !== "object" || String($7jljs$process) !== "[object process]" || true);
const $4684b3280a916bc3$export$3c901a5f01941a06 = typeof importScripts === "function";
const $4684b3280a916bc3$var$matches = typeof $7jljs$process !== "undefined" && $7jljs$process.version && /v([0-9]*)/.exec($7jljs$process.version);
const $4684b3280a916bc3$export$168db21d314844a8 = $4684b3280a916bc3$var$matches && parseFloat($4684b3280a916bc3$var$matches[1]) || 0;

const $1481083a7d4a8836$var$DEFAULT_VERSION = "latest";
const $1481083a7d4a8836$export$a4ad2735b021c132 = "3.2.5";

function $621b2e4491178cd2$export$a7a9523472993e97(condition, message) {
    if (!condition) throw new Error(message || "loaders.gl assertion failed.");
}


const $9f49355659a4ee10$var$globals = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof $parcel$global !== "undefined" && $parcel$global,
    document: typeof document !== "undefined" && document
};
const $9f49355659a4ee10$export$82c2e460fb230c2a = $9f49355659a4ee10$var$globals.self || $9f49355659a4ee10$var$globals.window || $9f49355659a4ee10$var$globals.global || {};
const $9f49355659a4ee10$export$8291e5b88f90ce4 = $9f49355659a4ee10$var$globals.window || $9f49355659a4ee10$var$globals.self || $9f49355659a4ee10$var$globals.global || {};
const $9f49355659a4ee10$export$90b4d2ff6acb88af = $9f49355659a4ee10$var$globals.global || $9f49355659a4ee10$var$globals.self || $9f49355659a4ee10$var$globals.window || {};
const $9f49355659a4ee10$export$5a7bfc01df82fcd1 = $9f49355659a4ee10$var$globals.document || {};
const $9f49355659a4ee10$export$4e09c449d6c407f7 = typeof $7jljs$process !== "object" || String($7jljs$process) !== "[object process]" || true;
const $9f49355659a4ee10$export$3c901a5f01941a06 = typeof importScripts === "function";
const $9f49355659a4ee10$export$d0a8044dce8ff2fc = typeof window !== "undefined" && typeof window.orientation !== "undefined";
const $9f49355659a4ee10$var$matches = typeof $7jljs$process !== "undefined" && $7jljs$process.version && /v([0-9]*)/.exec($7jljs$process.version);
const $9f49355659a4ee10$export$168db21d314844a8 = $9f49355659a4ee10$var$matches && parseFloat($9f49355659a4ee10$var$matches[1]) || 0;





class $6ea85628f397e045$export$5ff70a18b7b7760a {
}
const $6ea85628f397e045$export$cf4063c86d516c29 = null;





const $5b51d9ab3b26ead8$var$workerURLCache = new Map();
function $5b51d9ab3b26ead8$export$fb15ef3d6a383f22(props) {
    (0, $621b2e4491178cd2$export$a7a9523472993e97)(props.source && !props.url || !props.source && props.url);
    let workerURL = $5b51d9ab3b26ead8$var$workerURLCache.get(props.source || props.url);
    if (!workerURL) {
        if (props.url) {
            workerURL = $5b51d9ab3b26ead8$var$getLoadableWorkerURLFromURL(props.url);
            $5b51d9ab3b26ead8$var$workerURLCache.set(props.url, workerURL);
        }
        if (props.source) {
            workerURL = $5b51d9ab3b26ead8$var$getLoadableWorkerURLFromSource(props.source);
            $5b51d9ab3b26ead8$var$workerURLCache.set(props.source, workerURL);
        }
    }
    (0, $621b2e4491178cd2$export$a7a9523472993e97)(workerURL);
    return workerURL;
}
function $5b51d9ab3b26ead8$var$getLoadableWorkerURLFromURL(url) {
    if (!url.startsWith("http")) return url;
    const workerSource = $5b51d9ab3b26ead8$var$buildScriptSource(url);
    return $5b51d9ab3b26ead8$var$getLoadableWorkerURLFromSource(workerSource);
}
function $5b51d9ab3b26ead8$var$getLoadableWorkerURLFromSource(workerSource) {
    const blob = new Blob([
        workerSource
    ], {
        type: "application/javascript"
    });
    return URL.createObjectURL(blob);
}
function $5b51d9ab3b26ead8$var$buildScriptSource(workerUrl) {
    return "try {\n  importScripts('".concat(workerUrl, "');\n} catch (error) {\n  console.error(error);\n  throw error;\n}");
}


function $a9fcc58052559e9e$export$6464150b0a96b310(object, recursive = true, transfers) {
    const transfersSet = transfers || new Set();
    if (!object) ;
    else if ($a9fcc58052559e9e$var$isTransferable(object)) transfersSet.add(object);
    else if ($a9fcc58052559e9e$var$isTransferable(object.buffer)) transfersSet.add(object.buffer);
    else if (ArrayBuffer.isView(object)) ;
    else if (recursive && typeof object === "object") for(const key in object)$a9fcc58052559e9e$export$6464150b0a96b310(object[key], recursive, transfersSet);
    return transfers === undefined ? Array.from(transfersSet) : [];
}
function $a9fcc58052559e9e$var$isTransferable(object) {
    if (!object) return false;
    if (object instanceof ArrayBuffer) return true;
    if (typeof MessagePort !== "undefined" && object instanceof MessagePort) return true;
    if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) return true;
    if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) return true;
    return false;
}


const $d527c87c76e6f620$var$NOOP = ()=>{};
class $d527c87c76e6f620$export$2e2bcd8739ae039 {
    static isSupported() {
        return typeof Worker !== "undefined" && (0, $9f49355659a4ee10$export$4e09c449d6c407f7) || true;
    }
    constructor(props){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "name", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "source", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "url", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "terminated", false);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "worker", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "onMessage", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "onError", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_loadableURL", "");
        const { name: name , source: source , url: url  } = props;
        (0, $621b2e4491178cd2$export$a7a9523472993e97)(source || url);
        this.name = name;
        this.source = source;
        this.url = url;
        this.onMessage = $d527c87c76e6f620$var$NOOP;
        this.onError = (error)=>console.log(error);
        this.worker = (0, $9f49355659a4ee10$export$4e09c449d6c407f7) ? this._createBrowserWorker() : this._createNodeWorker();
    }
    destroy() {
        this.onMessage = $d527c87c76e6f620$var$NOOP;
        this.onError = $d527c87c76e6f620$var$NOOP;
        this.worker.terminate();
        this.terminated = true;
    }
    get isRunning() {
        return Boolean(this.onMessage);
    }
    postMessage(data, transferList) {
        transferList = transferList || (0, $a9fcc58052559e9e$export$6464150b0a96b310)(data);
        this.worker.postMessage(data, transferList);
    }
    _getErrorFromErrorEvent(event) {
        let message = "Failed to load ";
        message += "worker ".concat(this.name, " from ").concat(this.url, ". ");
        if (event.message) message += "".concat(event.message, " in ");
        if (event.lineno) message += ":".concat(event.lineno, ":").concat(event.colno);
        return new Error(message);
    }
    _createBrowserWorker() {
        this._loadableURL = (0, $5b51d9ab3b26ead8$export$fb15ef3d6a383f22)({
            source: this.source,
            url: this.url
        });
        const worker = new Worker(this._loadableURL, {
            name: this.name
        });
        worker.onmessage = (event)=>{
            if (!event.data) this.onError(new Error("No data received"));
            else this.onMessage(event.data);
        };
        worker.onerror = (error)=>{
            this.onError(this._getErrorFromErrorEvent(error));
            this.terminated = true;
        };
        worker.onmessageerror = (event)=>console.error(event);
        return worker;
    }
    _createNodeWorker() {
        let worker;
        if (this.url) {
            const absolute = this.url.includes(":/") || this.url.startsWith("/");
            const url = absolute ? this.url : "./".concat(this.url);
            worker = new (0, $6ea85628f397e045$export$5ff70a18b7b7760a)(url, {
                eval: false
            });
        } else if (this.source) worker = new (0, $6ea85628f397e045$export$5ff70a18b7b7760a)(this.source, {
            eval: true
        });
        else throw new Error("no worker");
        worker.on("message", (data)=>{
            this.onMessage(data);
        });
        worker.on("error", (error)=>{
            this.onError(error);
        });
        worker.on("exit", (code)=>{});
        return worker;
    }
}




class $b84e2d4d6c6f643a$export$2e2bcd8739ae039 {
    constructor(jobName, workerThread){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "name", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "workerThread", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "isRunning", true);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "result", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_resolve", ()=>{});
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_reject", ()=>{});
        this.name = jobName;
        this.workerThread = workerThread;
        this.result = new Promise((resolve, reject)=>{
            this._resolve = resolve;
            this._reject = reject;
        });
    }
    postMessage(type, payload) {
        this.workerThread.postMessage({
            source: "loaders.gl",
            type: type,
            payload: payload
        });
    }
    done(value) {
        (0, $621b2e4491178cd2$export$a7a9523472993e97)(this.isRunning);
        this.isRunning = false;
        this._resolve(value);
    }
    error(error) {
        (0, $621b2e4491178cd2$export$a7a9523472993e97)(this.isRunning);
        this.isRunning = false;
        this._reject(error);
    }
}


class $ac896f592bed4531$export$2e2bcd8739ae039 {
    static isSupported() {
        return (0, $d527c87c76e6f620$export$2e2bcd8739ae039).isSupported();
    }
    constructor(props){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "name", "unnamed");
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "source", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "url", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "maxConcurrency", 1);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "maxMobileConcurrency", 1);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "onDebug", ()=>{});
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "reuseWorkers", true);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", {});
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "jobQueue", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "idleQueue", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "count", 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "isDestroyed", false);
        this.source = props.source;
        this.url = props.url;
        this.setProps(props);
    }
    destroy() {
        this.idleQueue.forEach((worker)=>worker.destroy());
        this.isDestroyed = true;
    }
    setProps(props) {
        this.props = {
            ...this.props,
            ...props
        };
        if (props.name !== undefined) this.name = props.name;
        if (props.maxConcurrency !== undefined) this.maxConcurrency = props.maxConcurrency;
        if (props.maxMobileConcurrency !== undefined) this.maxMobileConcurrency = props.maxMobileConcurrency;
        if (props.reuseWorkers !== undefined) this.reuseWorkers = props.reuseWorkers;
        if (props.onDebug !== undefined) this.onDebug = props.onDebug;
    }
    async startJob(name, onMessage = (job, type, data)=>job.done(data), onError = (job, error)=>job.error(error)) {
        const startPromise = new Promise((onStart)=>{
            this.jobQueue.push({
                name: name,
                onMessage: onMessage,
                onError: onError,
                onStart: onStart
            });
            return this;
        });
        this._startQueuedJob();
        return await startPromise;
    }
    async _startQueuedJob() {
        if (!this.jobQueue.length) return;
        const workerThread = this._getAvailableWorker();
        if (!workerThread) return;
        const queuedJob = this.jobQueue.shift();
        if (queuedJob) {
            this.onDebug({
                message: "Starting job",
                name: queuedJob.name,
                workerThread: workerThread,
                backlog: this.jobQueue.length
            });
            const job = new (0, $b84e2d4d6c6f643a$export$2e2bcd8739ae039)(queuedJob.name, workerThread);
            workerThread.onMessage = (data)=>queuedJob.onMessage(job, data.type, data.payload);
            workerThread.onError = (error)=>queuedJob.onError(job, error);
            queuedJob.onStart(job);
            try {
                await job.result;
            } finally{
                this.returnWorkerToQueue(workerThread);
            }
        }
    }
    returnWorkerToQueue(worker) {
        const shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();
        if (shouldDestroyWorker) {
            worker.destroy();
            this.count--;
        } else this.idleQueue.push(worker);
        if (!this.isDestroyed) this._startQueuedJob();
    }
    _getAvailableWorker() {
        if (this.idleQueue.length > 0) return this.idleQueue.shift() || null;
        if (this.count < this._getMaxConcurrency()) {
            this.count++;
            const name = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
            return new (0, $d527c87c76e6f620$export$2e2bcd8739ae039)({
                name: name,
                source: this.source,
                url: this.url
            });
        }
        return null;
    }
    _getMaxConcurrency() {
        return (0, $9f49355659a4ee10$export$d0a8044dce8ff2fc) ? this.maxMobileConcurrency : this.maxConcurrency;
    }
}



const $c6217487f316a31d$var$DEFAULT_PROPS = {
    maxConcurrency: 3,
    maxMobileConcurrency: 1,
    reuseWorkers: true,
    onDebug: ()=>{}
};
class $c6217487f316a31d$export$2e2bcd8739ae039 {
    static isSupported() {
        return (0, $d527c87c76e6f620$export$2e2bcd8739ae039).isSupported();
    }
    static getWorkerFarm(props = {}) {
        $c6217487f316a31d$export$2e2bcd8739ae039._workerFarm = $c6217487f316a31d$export$2e2bcd8739ae039._workerFarm || new $c6217487f316a31d$export$2e2bcd8739ae039({});
        $c6217487f316a31d$export$2e2bcd8739ae039._workerFarm.setProps(props);
        return $c6217487f316a31d$export$2e2bcd8739ae039._workerFarm;
    }
    constructor(props){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "workerPools", new Map());
        this.props = {
            ...$c6217487f316a31d$var$DEFAULT_PROPS
        };
        this.setProps(props);
        this.workerPools = new Map();
    }
    destroy() {
        for (const workerPool of this.workerPools.values())workerPool.destroy();
        this.workerPools = new Map();
    }
    setProps(props) {
        this.props = {
            ...this.props,
            ...props
        };
        for (const workerPool of this.workerPools.values())workerPool.setProps(this._getWorkerPoolProps());
    }
    getWorkerPool(options) {
        const { name: name , source: source , url: url  } = options;
        let workerPool = this.workerPools.get(name);
        if (!workerPool) {
            workerPool = new (0, $ac896f592bed4531$export$2e2bcd8739ae039)({
                name: name,
                source: source,
                url: url
            });
            workerPool.setProps(this._getWorkerPoolProps());
            this.workerPools.set(name, workerPool);
        }
        return workerPool;
    }
    _getWorkerPoolProps() {
        return {
            maxConcurrency: this.props.maxConcurrency,
            maxMobileConcurrency: this.props.maxMobileConcurrency,
            reuseWorkers: this.props.reuseWorkers,
            onDebug: this.props.onDebug
        };
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($c6217487f316a31d$export$2e2bcd8739ae039, "_workerFarm", void 0);



const $71956df2729c708f$var$NPM_TAG = "latest";
const $71956df2729c708f$var$VERSION = "3.2.5";
function $71956df2729c708f$export$72db835c4de3b02e(worker) {
    const warning = worker.version !== $71956df2729c708f$var$VERSION ? " (worker-utils@".concat($71956df2729c708f$var$VERSION, ")") : "";
    return "".concat(worker.name, "@").concat(worker.version).concat(warning);
}
function $71956df2729c708f$export$959914ac3383a118(worker, options = {}) {
    const workerOptions = options[worker.id] || {};
    const workerFile = "".concat(worker.id, "-worker.js");
    let url = workerOptions.workerUrl;
    if (!url && worker.id === "compression") url = options.workerUrl;
    if (options._workerType === "test") url = "modules/".concat(worker.module, "/dist/").concat(workerFile);
    if (!url) {
        let version = worker.version;
        if (version === "latest") version = $71956df2729c708f$var$NPM_TAG;
        const versionTag = version ? "@".concat(version) : "";
        url = "https://unpkg.com/@loaders.gl/".concat(worker.module).concat(versionTag, "/dist/").concat(workerFile);
    }
    (0, $621b2e4491178cd2$export$a7a9523472993e97)(url);
    return url;
}



function $13f60cf71bdb7bc2$export$95e2ee179a5692d5(worker, coreVersion = (0, $1481083a7d4a8836$export$a4ad2735b021c132)) {
    (0, $621b2e4491178cd2$export$a7a9523472993e97)(worker, "no worker provided");
    const workerVersion = worker.version;
    if (!coreVersion || !workerVersion) return false;
    return true;
}
function $13f60cf71bdb7bc2$var$parseVersion(version) {
    const parts = version.split(".").map(Number);
    return {
        major: parts[0],
        minor: parts[1]
    };
}




function $cc2b304bc5bea5e3$export$d28453530d9dde76(loader, options) {
    if (!(0, $c6217487f316a31d$export$2e2bcd8739ae039).isSupported()) return false;
    if (!(0, $9f49355659a4ee10$export$4e09c449d6c407f7) && !(options !== null && options !== void 0 && options._nodeWorkers)) return false;
    return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);
}
async function $cc2b304bc5bea5e3$export$5fc1ede2a33af3b1(loader, data, options, context, parseOnMainThread) {
    const name = loader.id;
    const url = (0, $71956df2729c708f$export$959914ac3383a118)(loader, options);
    const workerFarm = (0, $c6217487f316a31d$export$2e2bcd8739ae039).getWorkerFarm(options);
    const workerPool = workerFarm.getWorkerPool({
        name: name,
        url: url
    });
    options = JSON.parse(JSON.stringify(options));
    context = JSON.parse(JSON.stringify(context || {}));
    const job = await workerPool.startJob("process-on-worker", $cc2b304bc5bea5e3$var$onMessage.bind(null, parseOnMainThread));
    job.postMessage("process", {
        input: data,
        options: options,
        context: context
    });
    const result = await job.result;
    return await result.result;
}
async function $cc2b304bc5bea5e3$var$onMessage(parseOnMainThread, job, type, payload) {
    switch(type){
        case "done":
            job.done(payload);
            break;
        case "error":
            job.error(new Error(payload.error));
            break;
        case "process":
            const { id: id , input: input , options: options  } = payload;
            try {
                const result = await parseOnMainThread(input, options);
                job.postMessage("done", {
                    id: id,
                    result: result
                });
            } catch (error) {
                const message = error instanceof Error ? error.message : "unknown error";
                job.postMessage("error", {
                    id: id,
                    error: message
                });
            }
            break;
        default:
            console.warn("parse-with-worker unknown message ".concat(type));
    }
}


var $9aLFZ = parcelRequire("9aLFZ");
function $349321a255d0af9f$export$a7884ebc965f8f54(value) {
    return value && typeof value === "object" && value.isBuffer;
}
function $349321a255d0af9f$export$fc336dbfaf62f18f(data) {
    return $9aLFZ.toBuffer ? $9aLFZ.toBuffer(data) : data;
}
function $349321a255d0af9f$export$1a478f4dd664a01f(buffer) {
    if ($349321a255d0af9f$export$a7884ebc965f8f54(buffer)) {
        const typedArray = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.length);
        return typedArray.slice().buffer;
    }
    return buffer;
}


function $30754a9468a958e5$export$8b22b05f429b130c(data) {
    if ((0, $349321a255d0af9f$export$a7884ebc965f8f54)(data)) return (0, $349321a255d0af9f$export$1a478f4dd664a01f)(data);
    if (data instanceof ArrayBuffer) return data;
    if (ArrayBuffer.isView(data)) {
        if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) return data.buffer;
        return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
    }
    if (typeof data === "string") {
        const text = data;
        const uint8Array = new TextEncoder().encode(text);
        return uint8Array.buffer;
    }
    if (data && typeof data === "object" && data._toArrayBuffer) return data._toArrayBuffer();
    throw new Error("toArrayBuffer");
}
function $30754a9468a958e5$export$a21c1249ab709443(arrayBuffer1, arrayBuffer2, byteLength) {
    byteLength = byteLength || arrayBuffer1.byteLength;
    if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) return false;
    const array1 = new Uint8Array(arrayBuffer1);
    const array2 = new Uint8Array(arrayBuffer2);
    for(let i = 0; i < array1.length; ++i){
        if (array1[i] !== array2[i]) return false;
    }
    return true;
}
function $30754a9468a958e5$export$9a3e9c78eb778da8(...sources) {
    const sourceArrays = sources.map((source2)=>source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
    const byteLength = sourceArrays.reduce((length, typedArray)=>length + typedArray.byteLength, 0);
    const result = new Uint8Array(byteLength);
    let offset = 0;
    for (const sourceArray of sourceArrays){
        result.set(sourceArray, offset);
        offset += sourceArray.byteLength;
    }
    return result.buffer;
}
function $30754a9468a958e5$export$b9f790e5e2031778(...typedArrays) {
    const arrays = typedArrays;
    const TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;
    if (!TypedArrayConstructor) throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');
    const sumLength = arrays.reduce((acc, value)=>acc + value.length, 0);
    const result = new TypedArrayConstructor(sumLength);
    let offset = 0;
    for (const array of arrays){
        result.set(array, offset);
        offset += array.length;
    }
    return result;
}
function $30754a9468a958e5$export$1c6babfc8b593386(arrayBuffer, byteOffset, byteLength) {
    const subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);
    const arrayCopy = new Uint8Array(subArray);
    return arrayCopy.buffer;
}


async function $19f06be37636b89d$export$4b80e395e36b5a56(iterator, visitor) {
    while(true){
        const { done: done , value: value  } = await iterator.next();
        if (done) {
            iterator.return();
            return;
        }
        const cancel = visitor(value);
        if (cancel) return;
    }
}
async function $19f06be37636b89d$export$b56e0390cdc1b1ca(asyncIterator) {
    const arrayBuffers = [];
    for await (const chunk of asyncIterator)arrayBuffers.push(chunk);
    return (0, $30754a9468a958e5$export$9a3e9c78eb778da8)(...arrayBuffers);
}
async function $19f06be37636b89d$export$8a08e0b4be2e1c13(asyncIterator) {
    const strings = [];
    for await (const chunk of asyncIterator)strings.push(chunk);
    return strings.join("");
}

let $525404fe6adfd5a1$var$pathPrefix = "";
const $525404fe6adfd5a1$var$fileAliases = {};
function $525404fe6adfd5a1$export$fa7cbeea6a0f8cd3(prefix) {
    $525404fe6adfd5a1$var$pathPrefix = prefix;
}
function $525404fe6adfd5a1$export$e21ff368c7512d8e() {
    return $525404fe6adfd5a1$var$pathPrefix;
}
function $525404fe6adfd5a1$export$65b32f70101f5674(aliases) {
    Object.assign($525404fe6adfd5a1$var$fileAliases, aliases);
}
function $525404fe6adfd5a1$export$b09f2ff0bbcb43c7(filename) {
    for(const alias in $525404fe6adfd5a1$var$fileAliases)if (filename.startsWith(alias)) {
        const replacement = $525404fe6adfd5a1$var$fileAliases[alias];
        filename = filename.replace(alias, replacement);
    }
    if (!filename.startsWith("http://") && !filename.startsWith("https://")) filename = "".concat($525404fe6adfd5a1$var$pathPrefix).concat(filename);
    return filename;
}



function $864167f4ef613baf$export$2db07da082dd07a7(loader) {
    var _loader;
    if (!loader) return false;
    if (Array.isArray(loader)) loader = loader[0];
    const hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);
    return hasExtensions;
}
function $864167f4ef613baf$export$a19b0af95f3585f1(loader) {
    var _loader2, _loader3;
    (0, $e2d3345494943a51$export$a7a9523472993e97)(loader, "null loader");
    (0, $e2d3345494943a51$export$a7a9523472993e97)($864167f4ef613baf$export$2db07da082dd07a7(loader), "invalid loader");
    let options;
    if (Array.isArray(loader)) {
        options = loader[1];
        loader = loader[0];
        loader = {
            ...loader,
            options: {
                ...loader.options,
                ...options
            }
        };
    }
    if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) loader.text = true;
    if (!loader.text) loader.binary = true;
    return loader;
}


const $3a21fafe29106685$var$isBoolean = (x)=>typeof x === "boolean";
const $3a21fafe29106685$var$isFunction = (x)=>typeof x === "function";
const $3a21fafe29106685$export$a6cdc56e425d0d0a = (x)=>x !== null && typeof x === "object";
const $3a21fafe29106685$export$e219791d2b49856 = (x)=>$3a21fafe29106685$export$a6cdc56e425d0d0a(x) && x.constructor === ({}).constructor;
const $3a21fafe29106685$export$4369c812aac99591 = (x)=>$3a21fafe29106685$export$a6cdc56e425d0d0a(x) && $3a21fafe29106685$var$isFunction(x.then);
const $3a21fafe29106685$export$9652023d9040757 = (x)=>x && typeof x[Symbol.iterator] === "function";
const $3a21fafe29106685$export$edb10ab8dd75a915 = (x)=>x && typeof x[Symbol.asyncIterator] === "function";
const $3a21fafe29106685$export$50db6e277db66ea0 = (x)=>x && $3a21fafe29106685$var$isFunction(x.next);
const $3a21fafe29106685$export$3f1eb41d9a6a6a27 = (x)=>typeof Response !== "undefined" && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
const $3a21fafe29106685$export$be78b3111c50efdd = (x)=>typeof File !== "undefined" && x instanceof File;
const $3a21fafe29106685$export$5bcd6e94ed871c88 = (x)=>typeof Blob !== "undefined" && x instanceof Blob;
const $3a21fafe29106685$export$a7884ebc965f8f54 = (x)=>x && typeof x === "object" && x.isBuffer;
const $3a21fafe29106685$export$5536d41d90245d51 = (x)=>$3a21fafe29106685$export$a6cdc56e425d0d0a(x) && $3a21fafe29106685$var$isFunction(x.abort) && $3a21fafe29106685$var$isFunction(x.getWriter);
const $3a21fafe29106685$export$f8bb1f6b773199b7 = (x)=>typeof ReadableStream !== "undefined" && x instanceof ReadableStream || $3a21fafe29106685$export$a6cdc56e425d0d0a(x) && $3a21fafe29106685$var$isFunction(x.tee) && $3a21fafe29106685$var$isFunction(x.cancel) && $3a21fafe29106685$var$isFunction(x.getReader);
const $3a21fafe29106685$export$eec1f46c8eef21a4 = (x)=>$3a21fafe29106685$export$a6cdc56e425d0d0a(x) && $3a21fafe29106685$var$isFunction(x.end) && $3a21fafe29106685$var$isFunction(x.write) && $3a21fafe29106685$var$isBoolean(x.writable);
const $3a21fafe29106685$export$2940183a2d5db90f = (x)=>$3a21fafe29106685$export$a6cdc56e425d0d0a(x) && $3a21fafe29106685$var$isFunction(x.read) && $3a21fafe29106685$var$isFunction(x.pipe) && $3a21fafe29106685$var$isBoolean(x.readable);
const $3a21fafe29106685$export$ac613ff475b69d05 = (x)=>$3a21fafe29106685$export$f8bb1f6b773199b7(x) || $3a21fafe29106685$export$2940183a2d5db90f(x);
const $3a21fafe29106685$export$b58a61c52edb4f66 = (x)=>$3a21fafe29106685$export$5536d41d90245d51(x) || $3a21fafe29106685$export$eec1f46c8eef21a4(x);





const $b41e48408a03be18$var$DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
const $b41e48408a03be18$var$MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
function $b41e48408a03be18$export$85e6adb445fa3ef0(mimeString) {
    const matches = $b41e48408a03be18$var$MIME_TYPE_PATTERN.exec(mimeString);
    if (matches) return matches[1];
    return mimeString;
}
function $b41e48408a03be18$export$a8aa3005f5e6c533(url) {
    const matches = $b41e48408a03be18$var$DATA_URL_PATTERN.exec(url);
    if (matches) return matches[1];
    return "";
}


const $68f5dc4489466520$var$QUERY_STRING_PATTERN = /\?.*/;
function $68f5dc4489466520$export$62b93576035b31a0(resource) {
    if ((0, $3a21fafe29106685$export$3f1eb41d9a6a6a27)(resource)) {
        const url = $68f5dc4489466520$var$stripQueryString(resource.url || "");
        const contentTypeHeader = resource.headers.get("content-type") || "";
        return {
            url: url,
            type: (0, $b41e48408a03be18$export$85e6adb445fa3ef0)(contentTypeHeader) || (0, $b41e48408a03be18$export$a8aa3005f5e6c533)(url)
        };
    }
    if ((0, $3a21fafe29106685$export$5bcd6e94ed871c88)(resource)) return {
        url: $68f5dc4489466520$var$stripQueryString(resource.name || ""),
        type: resource.type || ""
    };
    if (typeof resource === "string") return {
        url: $68f5dc4489466520$var$stripQueryString(resource),
        type: (0, $b41e48408a03be18$export$a8aa3005f5e6c533)(resource)
    };
    return {
        url: "",
        type: ""
    };
}
function $68f5dc4489466520$export$795ad0074e2d4d36(resource) {
    if ((0, $3a21fafe29106685$export$3f1eb41d9a6a6a27)(resource)) return resource.headers["content-length"] || -1;
    if ((0, $3a21fafe29106685$export$5bcd6e94ed871c88)(resource)) return resource.size;
    if (typeof resource === "string") return resource.length;
    if (resource instanceof ArrayBuffer) return resource.byteLength;
    if (ArrayBuffer.isView(resource)) return resource.byteLength;
    return -1;
}
function $68f5dc4489466520$var$stripQueryString(url) {
    return url.replace($68f5dc4489466520$var$QUERY_STRING_PATTERN, "");
}


async function $f09c61773fd1de7c$export$16d84ad959da5112(resource) {
    if ((0, $3a21fafe29106685$export$3f1eb41d9a6a6a27)(resource)) return resource;
    const headers = {};
    const contentLength = (0, $68f5dc4489466520$export$795ad0074e2d4d36)(resource);
    if (contentLength >= 0) headers["content-length"] = String(contentLength);
    const { url: url , type: type  } = (0, $68f5dc4489466520$export$62b93576035b31a0)(resource);
    if (type) headers["content-type"] = type;
    const initialDataUrl = await $f09c61773fd1de7c$var$getInitialDataUrl(resource);
    if (initialDataUrl) headers["x-first-bytes"] = initialDataUrl;
    if (typeof resource === "string") resource = new TextEncoder().encode(resource);
    const response = new Response(resource, {
        headers: headers
    });
    Object.defineProperty(response, "url", {
        value: url
    });
    return response;
}
async function $f09c61773fd1de7c$export$5db0ad607ce3410b(response) {
    if (!response.ok) {
        const message = await $f09c61773fd1de7c$var$getResponseError(response);
        throw new Error(message);
    }
}
function $f09c61773fd1de7c$export$ef46f094beca181f(response) {
    if (!response.ok) {
        let message = "".concat(response.status, " ").concat(response.statusText);
        message = message.length > 60 ? "".concat(message.slice(0, 60), "...") : message;
        throw new Error(message);
    }
}
async function $f09c61773fd1de7c$var$getResponseError(response) {
    let message = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");
    try {
        const contentType = response.headers.get("Content-Type");
        let text = response.statusText;
        if (contentType.includes("application/json")) text += " ".concat(await response.text());
        message += text;
        message = message.length > 60 ? "".concat(message.slice(0, 60), "...") : message;
    } catch (error) {}
    return message;
}
async function $f09c61773fd1de7c$var$getInitialDataUrl(resource) {
    const INITIAL_DATA_LENGTH = 5;
    if (typeof resource === "string") return "data:,".concat(resource.slice(0, INITIAL_DATA_LENGTH));
    if (resource instanceof Blob) {
        const blobSlice = resource.slice(0, 5);
        return await new Promise((resolve)=>{
            const reader = new FileReader();
            reader.onload = (event)=>{
                var _event$target;
                return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
            };
            reader.readAsDataURL(blobSlice);
        });
    }
    if (resource instanceof ArrayBuffer) {
        const slice = resource.slice(0, INITIAL_DATA_LENGTH);
        const base64 = $f09c61773fd1de7c$var$arrayBufferToBase64(slice);
        return "data:base64,".concat(base64);
    }
    return null;
}
function $f09c61773fd1de7c$var$arrayBufferToBase64(buffer) {
    let binary = "";
    const bytes = new Uint8Array(buffer);
    for(let i = 0; i < bytes.byteLength; i++)binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
}


async function $3ab0c823d83f8bfb$export$d965bcb23f9d06c5(url, options) {
    if (typeof url === "string") {
        url = (0, $525404fe6adfd5a1$export$b09f2ff0bbcb43c7)(url);
        let fetchOptions = options;
        if (options !== null && options !== void 0 && options.fetch && typeof (options === null || options === void 0 ? void 0 : options.fetch) !== "function") fetchOptions = options.fetch;
        return await fetch(url, fetchOptions);
    }
    return await (0, $f09c61773fd1de7c$export$16d84ad959da5112)(url);
}





const $d0c51c6a82298d65$export$775acaacb88283c4 = new (0, $88fdfccabe5e323d$export$2e2bcd8739ae039)({
    id: "loaders.gl"
});
class $d0c51c6a82298d65$export$c8151b0a106d0aae {
    log() {
        return ()=>{};
    }
    info() {
        return ()=>{};
    }
    warn() {
        return ()=>{};
    }
    error() {
        return ()=>{};
    }
}
class $d0c51c6a82298d65$export$b0d7de77e5ad708 {
    constructor(){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "console", void 0);
        this.console = console;
    }
    log(...args) {
        return this.console.log.bind(this.console, ...args);
    }
    info(...args) {
        return this.console.info.bind(this.console, ...args);
    }
    warn(...args) {
        return this.console.warn.bind(this.console, ...args);
    }
    error(...args) {
        return this.console.error.bind(this.console, ...args);
    }
}




const $64ef6e1fbc380c0a$export$9e68d151f40453e2 = {
    fetch: null,
    mimeType: undefined,
    nothrow: false,
    log: new (0, $d0c51c6a82298d65$export$b0d7de77e5ad708)(),
    CDN: "https://unpkg.com/@loaders.gl",
    worker: true,
    maxConcurrency: 3,
    maxMobileConcurrency: 1,
    reuseWorkers: (0, $4684b3280a916bc3$export$4e09c449d6c407f7),
    _nodeWorkers: false,
    _workerType: "",
    limit: 0,
    _limitMB: 0,
    batchSize: "auto",
    batchDebounceMs: 0,
    metadata: false,
    transforms: []
};
const $64ef6e1fbc380c0a$export$1bd820ce6d516afc = {
    throws: "nothrow",
    dataType: "(no longer used)",
    uri: "baseUri",
    method: "fetch.method",
    headers: "fetch.headers",
    body: "fetch.body",
    mode: "fetch.mode",
    credentials: "fetch.credentials",
    cache: "fetch.cache",
    redirect: "fetch.redirect",
    referrer: "fetch.referrer",
    referrerPolicy: "fetch.referrerPolicy",
    integrity: "fetch.integrity",
    keepalive: "fetch.keepalive",
    signal: "fetch.signal"
};


function $655ea8d161058ae9$export$2a5c5f9d1a96dd63() {
    globalThis.loaders = globalThis.loaders || {};
    const { loaders: loaders  } = globalThis;
    loaders._state = loaders._state || {};
    return loaders._state;
}
const $655ea8d161058ae9$export$6b0f80053d2682ea = ()=>{
    const state = $655ea8d161058ae9$export$2a5c5f9d1a96dd63();
    state.globalOptions = state.globalOptions || {
        ...(0, $64ef6e1fbc380c0a$export$9e68d151f40453e2)
    };
    return state.globalOptions;
};
function $655ea8d161058ae9$export$545eb931aeddfa08(options) {
    const state = $655ea8d161058ae9$export$2a5c5f9d1a96dd63();
    const globalOptions = $655ea8d161058ae9$export$6b0f80053d2682ea();
    state.globalOptions = $655ea8d161058ae9$var$normalizeOptionsInternal(globalOptions, options);
}
function $655ea8d161058ae9$export$eb806c0b85b62f7a(options, loader, loaders, url) {
    loaders = loaders || [];
    loaders = Array.isArray(loaders) ? loaders : [
        loaders
    ];
    $655ea8d161058ae9$var$validateOptions(options, loaders);
    return $655ea8d161058ae9$var$normalizeOptionsInternal(loader, options, url);
}
function $655ea8d161058ae9$export$9b973e0eff85009f(options, context) {
    const globalOptions = $655ea8d161058ae9$export$6b0f80053d2682ea();
    const fetchOptions = options || globalOptions;
    if (typeof fetchOptions.fetch === "function") return fetchOptions.fetch;
    if ((0, $3a21fafe29106685$export$a6cdc56e425d0d0a)(fetchOptions.fetch)) return (url)=>(0, $3ab0c823d83f8bfb$export$d965bcb23f9d06c5)(url, fetchOptions);
    if (context !== null && context !== void 0 && context.fetch) return context === null || context === void 0 ? void 0 : context.fetch;
    return 0, $3ab0c823d83f8bfb$export$d965bcb23f9d06c5;
}
function $655ea8d161058ae9$var$validateOptions(options, loaders) {
    $655ea8d161058ae9$var$validateOptionsObject(options, null, (0, $64ef6e1fbc380c0a$export$9e68d151f40453e2), (0, $64ef6e1fbc380c0a$export$1bd820ce6d516afc), loaders);
    for (const loader of loaders){
        const idOptions = options && options[loader.id] || {};
        const loaderOptions = loader.options && loader.options[loader.id] || {};
        const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
        $655ea8d161058ae9$var$validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
    }
}
function $655ea8d161058ae9$var$validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
    const loaderName = id || "Top level";
    const prefix = id ? "".concat(id, ".") : "";
    for(const key in options){
        const isSubOptions = !id && (0, $3a21fafe29106685$export$a6cdc56e425d0d0a)(options[key]);
        const isBaseUriOption = key === "baseUri" && !id;
        const isWorkerUrlOption = key === "workerUrl" && id;
        if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
            if (key in deprecatedOptions) (0, $d0c51c6a82298d65$export$775acaacb88283c4).warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' no longer supported, use '").concat(deprecatedOptions[key], "'"))();
            else if (!isSubOptions) {
                const suggestion = $655ea8d161058ae9$var$findSimilarOption(key, loaders);
                (0, $d0c51c6a82298d65$export$775acaacb88283c4).warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' not recognized. ").concat(suggestion))();
            }
        }
    }
}
function $655ea8d161058ae9$var$findSimilarOption(optionKey, loaders) {
    const lowerCaseOptionKey = optionKey.toLowerCase();
    let bestSuggestion = "";
    for (const loader of loaders)for(const key in loader.options){
        if (optionKey === key) return "Did you mean '".concat(loader.id, ".").concat(key, "'?");
        const lowerCaseKey = key.toLowerCase();
        const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
        if (isPartialMatch) bestSuggestion = bestSuggestion || "Did you mean '".concat(loader.id, ".").concat(key, "'?");
    }
    return bestSuggestion;
}
function $655ea8d161058ae9$var$normalizeOptionsInternal(loader, options, url) {
    const loaderDefaultOptions = loader.options || {};
    const mergedOptions = {
        ...loaderDefaultOptions
    };
    $655ea8d161058ae9$var$addUrlOptions(mergedOptions, url);
    if (mergedOptions.log === null) mergedOptions.log = new (0, $d0c51c6a82298d65$export$c8151b0a106d0aae)();
    $655ea8d161058ae9$var$mergeNestedFields(mergedOptions, $655ea8d161058ae9$export$6b0f80053d2682ea());
    $655ea8d161058ae9$var$mergeNestedFields(mergedOptions, options);
    return mergedOptions;
}
function $655ea8d161058ae9$var$mergeNestedFields(mergedOptions, options) {
    for(const key in options)if (key in options) {
        const value = options[key];
        if ((0, $3a21fafe29106685$export$e219791d2b49856)(value) && (0, $3a21fafe29106685$export$e219791d2b49856)(mergedOptions[key])) mergedOptions[key] = {
            ...mergedOptions[key],
            ...options[key]
        };
        else mergedOptions[key] = options[key];
    }
}
function $655ea8d161058ae9$var$addUrlOptions(options, url) {
    if (url && !("baseUri" in options)) options.baseUri = url;
}


const $74a7778b58c84a5d$var$getGlobalLoaderRegistry = ()=>{
    const state = (0, $655ea8d161058ae9$export$2a5c5f9d1a96dd63)();
    state.loaderRegistry = state.loaderRegistry || [];
    return state.loaderRegistry;
};
function $74a7778b58c84a5d$export$74069a1a10fa28e5(loaders) {
    const loaderRegistry = $74a7778b58c84a5d$var$getGlobalLoaderRegistry();
    loaders = Array.isArray(loaders) ? loaders : [
        loaders
    ];
    for (const loader of loaders){
        const normalizedLoader = (0, $864167f4ef613baf$export$a19b0af95f3585f1)(loader);
        if (!loaderRegistry.find((registeredLoader)=>normalizedLoader === registeredLoader)) loaderRegistry.unshift(normalizedLoader);
    }
}
function $74a7778b58c84a5d$export$8fa02447f82aef84() {
    return $74a7778b58c84a5d$var$getGlobalLoaderRegistry();
}
function $74a7778b58c84a5d$export$a20f34177d9a64c6() {
    const state = (0, $655ea8d161058ae9$export$2a5c5f9d1a96dd63)();
    state.loaderRegistry = [];
}











const $97bf60a30d8bcc31$var$DEFAULT_CHUNK_SIZE = 262144;
function* $97bf60a30d8bcc31$export$c51500126ec60dd4(string, options) {
    const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || $97bf60a30d8bcc31$var$DEFAULT_CHUNK_SIZE;
    let offset = 0;
    const textEncoder = new TextEncoder();
    while(offset < string.length){
        const chunkLength = Math.min(string.length - offset, chunkSize);
        const chunk = string.slice(offset, offset + chunkLength);
        offset += chunkLength;
        yield textEncoder.encode(chunk);
    }
}


const $e0c0a5a683a20b00$var$DEFAULT_CHUNK_SIZE = 262144;
function* $e0c0a5a683a20b00$export$257e4501e13446d3(arrayBuffer, options = {}) {
    const { chunkSize: chunkSize = $e0c0a5a683a20b00$var$DEFAULT_CHUNK_SIZE  } = options;
    let byteOffset = 0;
    while(byteOffset < arrayBuffer.byteLength){
        const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);
        const chunk = new ArrayBuffer(chunkByteLength);
        const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);
        const chunkArray = new Uint8Array(chunk);
        chunkArray.set(sourceArray);
        byteOffset += chunkByteLength;
        yield chunk;
    }
}


const $765b79490cb41f16$var$DEFAULT_CHUNK_SIZE = 1048576;
async function* $765b79490cb41f16$export$97cfd032a0f445d2(blob, options) {
    const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || $765b79490cb41f16$var$DEFAULT_CHUNK_SIZE;
    let offset = 0;
    while(offset < blob.size){
        const end = offset + chunkSize;
        const chunk = await blob.slice(offset, end).arrayBuffer();
        offset = end;
        yield chunk;
    }
}



function $c1b9a61d0199985f$export$80460602c027534f(stream, options) {
    return (0, $4684b3280a916bc3$export$4e09c449d6c407f7) ? $c1b9a61d0199985f$var$makeBrowserStreamIterator(stream, options) : $c1b9a61d0199985f$var$makeNodeStreamIterator(stream, options);
}
async function* $c1b9a61d0199985f$var$makeBrowserStreamIterator(stream, options) {
    const reader = stream.getReader();
    let nextBatchPromise;
    try {
        while(true){
            const currentBatchPromise = nextBatchPromise || reader.read();
            if (options !== null && options !== void 0 && options._streamReadAhead) nextBatchPromise = reader.read();
            const { done: done , value: value  } = await currentBatchPromise;
            if (done) return;
            yield (0, $30754a9468a958e5$export$8b22b05f429b130c)(value);
        }
    } catch (error) {
        reader.releaseLock();
    }
}
async function* $c1b9a61d0199985f$var$makeNodeStreamIterator(stream, options) {
    for await (const chunk of stream)yield (0, $30754a9468a958e5$export$8b22b05f429b130c)(chunk);
}



function $1a6cbf7309e5e0a9$export$81c40ebfe660d3ca(data, options) {
    if (typeof data === "string") return (0, $97bf60a30d8bcc31$export$c51500126ec60dd4)(data, options);
    if (data instanceof ArrayBuffer) return (0, $e0c0a5a683a20b00$export$257e4501e13446d3)(data, options);
    if ((0, $3a21fafe29106685$export$5bcd6e94ed871c88)(data)) return (0, $765b79490cb41f16$export$97cfd032a0f445d2)(data, options);
    if ((0, $3a21fafe29106685$export$ac613ff475b69d05)(data)) return (0, $c1b9a61d0199985f$export$80460602c027534f)(data, options);
    if ((0, $3a21fafe29106685$export$3f1eb41d9a6a6a27)(data)) {
        const response = data;
        return (0, $c1b9a61d0199985f$export$80460602c027534f)(response.body, options);
    }
    throw new Error("makeIterator");
}



const $d0125102dd389479$var$ERR_DATA = "Cannot convert supplied data type";
function $d0125102dd389479$export$1bdaa95e029beec8(data, loader, options) {
    if (loader.text && typeof data === "string") return data;
    if ((0, $3a21fafe29106685$export$a7884ebc965f8f54)(data)) data = data.buffer;
    if (data instanceof ArrayBuffer) {
        const arrayBuffer = data;
        if (loader.text && !loader.binary) {
            const textDecoder = new TextDecoder("utf8");
            return textDecoder.decode(arrayBuffer);
        }
        return arrayBuffer;
    }
    if (ArrayBuffer.isView(data)) {
        if (loader.text && !loader.binary) {
            const textDecoder = new TextDecoder("utf8");
            return textDecoder.decode(data);
        }
        let arrayBuffer = data.buffer;
        const byteLength = data.byteLength || data.length;
        if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
        return arrayBuffer;
    }
    throw new Error($d0125102dd389479$var$ERR_DATA);
}
async function $d0125102dd389479$export$8f911a3af008501e(data, loader, options) {
    const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
    if (typeof data === "string" || isArrayBuffer) return $d0125102dd389479$export$1bdaa95e029beec8(data, loader, options);
    if ((0, $3a21fafe29106685$export$5bcd6e94ed871c88)(data)) data = await (0, $f09c61773fd1de7c$export$16d84ad959da5112)(data);
    if ((0, $3a21fafe29106685$export$3f1eb41d9a6a6a27)(data)) {
        const response = data;
        await (0, $f09c61773fd1de7c$export$5db0ad607ce3410b)(response);
        return loader.binary ? await response.arrayBuffer() : await response.text();
    }
    if ((0, $3a21fafe29106685$export$ac613ff475b69d05)(data)) data = (0, $1a6cbf7309e5e0a9$export$81c40ebfe660d3ca)(data, options);
    if ((0, $3a21fafe29106685$export$9652023d9040757)(data) || (0, $3a21fafe29106685$export$edb10ab8dd75a915)(data)) return (0, $19f06be37636b89d$export$b56e0390cdc1b1ca)(data);
    throw new Error($d0125102dd389479$var$ERR_DATA);
}
async function $d0125102dd389479$export$439b9c71d78e9e91(data, options) {
    if ((0, $3a21fafe29106685$export$50db6e277db66ea0)(data)) return data;
    if ((0, $3a21fafe29106685$export$3f1eb41d9a6a6a27)(data)) {
        const response = data;
        await (0, $f09c61773fd1de7c$export$5db0ad607ce3410b)(response);
        const body = await response.body;
        return (0, $1a6cbf7309e5e0a9$export$81c40ebfe660d3ca)(body, options);
    }
    if ((0, $3a21fafe29106685$export$5bcd6e94ed871c88)(data) || (0, $3a21fafe29106685$export$ac613ff475b69d05)(data)) return (0, $1a6cbf7309e5e0a9$export$81c40ebfe660d3ca)(data, options);
    if ((0, $3a21fafe29106685$export$edb10ab8dd75a915)(data)) return data[Symbol.asyncIterator]();
    return $d0125102dd389479$var$getIterableFromData(data);
}
async function $d0125102dd389479$export$fcaec59c9cf8d502(data) {
    if ((0, $3a21fafe29106685$export$ac613ff475b69d05)(data)) return data;
    if ((0, $3a21fafe29106685$export$3f1eb41d9a6a6a27)(data)) return data.body;
    const response = await (0, $f09c61773fd1de7c$export$16d84ad959da5112)(data);
    return response.body;
}
function $d0125102dd389479$var$getIterableFromData(data) {
    if (ArrayBuffer.isView(data)) return function* oneChunk() {
        yield data.buffer;
    }();
    if (data instanceof ArrayBuffer) return function* oneChunk() {
        yield data;
    }();
    if ((0, $3a21fafe29106685$export$50db6e277db66ea0)(data)) return data;
    if ((0, $3a21fafe29106685$export$9652023d9040757)(data)) return data[Symbol.iterator]();
    throw new Error($d0125102dd389479$var$ERR_DATA);
}



function $45f3edb3159ef0c0$export$c9fdcdb31d4bf289(context, options, previousContext = null) {
    if (previousContext) return previousContext;
    const resolvedContext = {
        fetch: (0, $655ea8d161058ae9$export$9b973e0eff85009f)(options, context),
        ...context
    };
    if (!Array.isArray(resolvedContext.loaders)) resolvedContext.loaders = null;
    return resolvedContext;
}
function $45f3edb3159ef0c0$export$f7bef68ca326d506(loaders, context) {
    if (!context && loaders && !Array.isArray(loaders)) return loaders;
    let candidateLoaders;
    if (loaders) candidateLoaders = Array.isArray(loaders) ? loaders : [
        loaders
    ];
    if (context && context.loaders) {
        const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [
            context.loaders
        ];
        candidateLoaders = candidateLoaders ? [
            ...candidateLoaders,
            ...contextLoaders
        ] : contextLoaders;
    }
    return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;
}






const $31bbe266be23eade$export$bef1f36f5486a6a3 = new (0, $88fdfccabe5e323d$export$2e2bcd8739ae039)({
    id: "loaders.gl"
});





const $2476546eb8404fd7$var$EXT_PATTERN = /\.([^.]+)$/;
async function $2476546eb8404fd7$export$c633f22f376a9a73(data, loaders = [], options, context) {
    if (!$2476546eb8404fd7$var$validHTTPResponse(data)) return null;
    let loader = $2476546eb8404fd7$export$27c49426aa5beb44(data, loaders, {
        ...options,
        nothrow: true
    }, context);
    if (loader) return loader;
    if ((0, $3a21fafe29106685$export$5bcd6e94ed871c88)(data)) {
        data = await data.slice(0, 10).arrayBuffer();
        loader = $2476546eb8404fd7$export$27c49426aa5beb44(data, loaders, options, context);
    }
    if (!loader && !(options !== null && options !== void 0 && options.nothrow)) throw new Error($2476546eb8404fd7$var$getNoValidLoaderMessage(data));
    return loader;
}
function $2476546eb8404fd7$export$27c49426aa5beb44(data, loaders = [], options, context) {
    if (!$2476546eb8404fd7$var$validHTTPResponse(data)) return null;
    if (loaders && !Array.isArray(loaders)) return (0, $864167f4ef613baf$export$a19b0af95f3585f1)(loaders);
    let candidateLoaders = [];
    if (loaders) candidateLoaders = candidateLoaders.concat(loaders);
    if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) candidateLoaders.push(...(0, $74a7778b58c84a5d$export$8fa02447f82aef84)());
    $2476546eb8404fd7$var$normalizeLoaders(candidateLoaders);
    const loader = $2476546eb8404fd7$var$selectLoaderInternal(data, candidateLoaders, options, context);
    if (!loader && !(options !== null && options !== void 0 && options.nothrow)) throw new Error($2476546eb8404fd7$var$getNoValidLoaderMessage(data));
    return loader;
}
function $2476546eb8404fd7$var$selectLoaderInternal(data, loaders, options, context) {
    const { url: url , type: type  } = (0, $68f5dc4489466520$export$62b93576035b31a0)(data);
    const testUrl = url || (context === null || context === void 0 ? void 0 : context.url);
    let loader = null;
    let reason = "";
    if (options !== null && options !== void 0 && options.mimeType) {
        loader = $2476546eb8404fd7$var$findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);
        reason = "match forced by supplied MIME type ".concat(options === null || options === void 0 ? void 0 : options.mimeType);
    }
    loader = loader || $2476546eb8404fd7$var$findLoaderByUrl(loaders, testUrl);
    reason = reason || (loader ? "matched url ".concat(testUrl) : "");
    loader = loader || $2476546eb8404fd7$var$findLoaderByMIMEType(loaders, type);
    reason = reason || (loader ? "matched MIME type ".concat(type) : "");
    loader = loader || $2476546eb8404fd7$var$findLoaderByInitialBytes(loaders, data);
    reason = reason || (loader ? "matched initial data ".concat($2476546eb8404fd7$var$getFirstCharacters(data)) : "");
    loader = loader || $2476546eb8404fd7$var$findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);
    reason = reason || (loader ? "matched fallback MIME type ".concat(type) : "");
    if (reason) {
        var _loader;
        (0, $31bbe266be23eade$export$bef1f36f5486a6a3).log(1, "selectLoader selected ".concat((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.name, ": ").concat(reason, "."));
    }
    return loader;
}
function $2476546eb8404fd7$var$validHTTPResponse(data) {
    if (data instanceof Response) {
        if (data.status === 204) return false;
    }
    return true;
}
function $2476546eb8404fd7$var$getNoValidLoaderMessage(data) {
    const { url: url , type: type  } = (0, $68f5dc4489466520$export$62b93576035b31a0)(data);
    let message = "No valid loader found (";
    message += url ? "".concat((0, $51a006089e505849$exports).filename(url), ", ") : "no url provided, ";
    message += "MIME type: ".concat(type ? '"'.concat(type, '"') : "not provided", ", ");
    const firstCharacters = data ? $2476546eb8404fd7$var$getFirstCharacters(data) : "";
    message += firstCharacters ? ' first bytes: "'.concat(firstCharacters, '"') : "first bytes: not available";
    message += ")";
    return message;
}
function $2476546eb8404fd7$var$normalizeLoaders(loaders) {
    for (const loader of loaders)(0, $864167f4ef613baf$export$a19b0af95f3585f1)(loader);
}
function $2476546eb8404fd7$var$findLoaderByUrl(loaders, url) {
    const match = url && $2476546eb8404fd7$var$EXT_PATTERN.exec(url);
    const extension = match && match[1];
    return extension ? $2476546eb8404fd7$var$findLoaderByExtension(loaders, extension) : null;
}
function $2476546eb8404fd7$var$findLoaderByExtension(loaders, extension) {
    extension = extension.toLowerCase();
    for (const loader of loaders)for (const loaderExtension of loader.extensions){
        if (loaderExtension.toLowerCase() === extension) return loader;
    }
    return null;
}
function $2476546eb8404fd7$var$findLoaderByMIMEType(loaders, mimeType) {
    for (const loader of loaders){
        if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) return loader;
        if (mimeType === "application/x.".concat(loader.id)) return loader;
    }
    return null;
}
function $2476546eb8404fd7$var$findLoaderByInitialBytes(loaders, data) {
    if (!data) return null;
    for (const loader of loaders){
        if (typeof data === "string") {
            if ($2476546eb8404fd7$var$testDataAgainstText(data, loader)) return loader;
        } else if (ArrayBuffer.isView(data)) {
            if ($2476546eb8404fd7$var$testDataAgainstBinary(data.buffer, data.byteOffset, loader)) return loader;
        } else if (data instanceof ArrayBuffer) {
            const byteOffset = 0;
            if ($2476546eb8404fd7$var$testDataAgainstBinary(data, byteOffset, loader)) return loader;
        }
    }
    return null;
}
function $2476546eb8404fd7$var$testDataAgainstText(data, loader) {
    if (loader.testText) return loader.testText(data);
    const tests = Array.isArray(loader.tests) ? loader.tests : [
        loader.tests
    ];
    return tests.some((test)=>data.startsWith(test));
}
function $2476546eb8404fd7$var$testDataAgainstBinary(data, byteOffset, loader) {
    const tests = Array.isArray(loader.tests) ? loader.tests : [
        loader.tests
    ];
    return tests.some((test)=>$2476546eb8404fd7$var$testBinary(data, byteOffset, loader, test));
}
function $2476546eb8404fd7$var$testBinary(data, byteOffset, loader, test) {
    if (test instanceof ArrayBuffer) return (0, $30754a9468a958e5$export$a21c1249ab709443)(test, data, test.byteLength);
    switch(typeof test){
        case "function":
            return test(data, loader);
        case "string":
            const magic = $2476546eb8404fd7$var$getMagicString(data, byteOffset, test.length);
            return test === magic;
        default:
            return false;
    }
}
function $2476546eb8404fd7$var$getFirstCharacters(data, length = 5) {
    if (typeof data === "string") return data.slice(0, length);
    else if (ArrayBuffer.isView(data)) return $2476546eb8404fd7$var$getMagicString(data.buffer, data.byteOffset, length);
    else if (data instanceof ArrayBuffer) {
        const byteOffset = 0;
        return $2476546eb8404fd7$var$getMagicString(data, byteOffset, length);
    }
    return "";
}
function $2476546eb8404fd7$var$getMagicString(arrayBuffer, byteOffset, length) {
    if (arrayBuffer.byteLength < byteOffset + length) return "";
    const dataView = new DataView(arrayBuffer);
    let magic = "";
    for(let i = 0; i < length; i++)magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
    return magic;
}


async function $5e2763efee34aaaa$export$98e6a39c04603d36(data, loaders, options, context) {
    (0, $621b2e4491178cd2$export$a7a9523472993e97)(!context || typeof context === "object");
    if (loaders && !Array.isArray(loaders) && !(0, $864167f4ef613baf$export$2db07da082dd07a7)(loaders)) {
        context = undefined;
        options = loaders;
        loaders = undefined;
    }
    data = await data;
    options = options || {};
    const { url: url  } = (0, $68f5dc4489466520$export$62b93576035b31a0)(data);
    const typedLoaders = loaders;
    const candidateLoaders = (0, $45f3edb3159ef0c0$export$f7bef68ca326d506)(typedLoaders, context);
    const loader = await (0, $2476546eb8404fd7$export$c633f22f376a9a73)(data, candidateLoaders, options);
    if (!loader) return null;
    options = (0, $655ea8d161058ae9$export$eb806c0b85b62f7a)(options, loader, candidateLoaders, url);
    context = (0, $45f3edb3159ef0c0$export$c9fdcdb31d4bf289)({
        url: url,
        parse: $5e2763efee34aaaa$export$98e6a39c04603d36,
        loaders: candidateLoaders
    }, options, context);
    return await $5e2763efee34aaaa$var$parseWithLoader(loader, data, options, context);
}
async function $5e2763efee34aaaa$var$parseWithLoader(loader, data, options, context) {
    (0, $13f60cf71bdb7bc2$export$95e2ee179a5692d5)(loader);
    if ((0, $3a21fafe29106685$export$3f1eb41d9a6a6a27)(data)) {
        const response = data;
        const { ok: ok , redirected: redirected , status: status , statusText: statusText , type: type , url: url  } = response;
        const headers = Object.fromEntries(response.headers.entries());
        context.response = {
            headers: headers,
            ok: ok,
            redirected: redirected,
            status: status,
            statusText: statusText,
            type: type,
            url: url
        };
    }
    data = await (0, $d0125102dd389479$export$8f911a3af008501e)(data, loader, options);
    if (loader.parseTextSync && typeof data === "string") {
        options.dataType = "text";
        return loader.parseTextSync(data, options, context, loader);
    }
    if ((0, $cc2b304bc5bea5e3$export$d28453530d9dde76)(loader, options)) return await (0, $cc2b304bc5bea5e3$export$5fc1ede2a33af3b1)(loader, data, options, context, $5e2763efee34aaaa$export$98e6a39c04603d36);
    if (loader.parseText && typeof data === "string") return await loader.parseText(data, options, context, loader);
    if (loader.parse) return await loader.parse(data, options, context, loader);
    (0, $621b2e4491178cd2$export$a7a9523472993e97)(!loader.parseSync);
    throw new Error("".concat(loader.id, " loader - no parser found and worker is disabled"));
}


async function $10b58f50fbeb8045$export$11e63f7b0f3d9900(url, loaders, options, context) {
    if (!Array.isArray(loaders) && !(0, $864167f4ef613baf$export$2db07da082dd07a7)(loaders)) {
        context = undefined;
        options = loaders;
        loaders = undefined;
    }
    const fetch = (0, $655ea8d161058ae9$export$9b973e0eff85009f)(options);
    let data = url;
    if (typeof url === "string") data = await fetch(url);
    if ((0, $3a21fafe29106685$export$5bcd6e94ed871c88)(url)) data = await fetch(url);
    return await (0, $5e2763efee34aaaa$export$98e6a39c04603d36)(data, loaders, options);
}



class $621d77364ac7bdec$export$2e2bcd8739ae039 {
    constructor(id, data, context){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "context", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "isLoaded", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "persistent", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_loadCount", 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_subscribers", new Set());
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_data", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_loader", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_error", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_content", void 0);
        this.id = id;
        this.context = context;
        this.setData(data);
    }
    subscribe(consumer) {
        this._subscribers.add(consumer);
    }
    unsubscribe(consumer) {
        this._subscribers.delete(consumer);
    }
    inUse() {
        return this._subscribers.size > 0;
    }
    delete() {}
    getData() {
        return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(()=>this.getData());
    }
    setData(data, forceUpdate) {
        if (data === this._data && !forceUpdate) return;
        this._data = data;
        const loadCount = ++this._loadCount;
        let loader = data;
        if (typeof data === "string") loader = (0, $10b58f50fbeb8045$export$11e63f7b0f3d9900)(data);
        if (loader instanceof Promise) {
            this.isLoaded = false;
            this._loader = loader.then((result)=>{
                if (this._loadCount === loadCount) {
                    this.isLoaded = true;
                    this._error = undefined;
                    this._content = result;
                }
            }).catch((error)=>{
                if (this._loadCount === loadCount) {
                    this.isLoaded = true;
                    this._error = error || true;
                }
            });
        } else {
            this.isLoaded = true;
            this._error = undefined;
            this._content = data;
        }
        for (const subscriber of this._subscribers)subscriber.onChange(this.getData());
    }
}


class $23cb722a95241d61$export$2e2bcd8739ae039 {
    constructor({ gl: gl , protocol: protocol  }){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "protocol", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_context", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_resources", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_consumers", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_pruneRequest", void 0);
        this.protocol = protocol || "resource://";
        this._context = {
            gl: gl,
            resourceManager: this
        };
        this._resources = {};
        this._consumers = {};
        this._pruneRequest = null;
    }
    contains(resourceId) {
        if (resourceId.startsWith(this.protocol)) return true;
        return resourceId in this._resources;
    }
    add({ resourceId: resourceId , data: data , forceUpdate: forceUpdate = false , persistent: persistent = true  }) {
        let res = this._resources[resourceId];
        if (res) res.setData(data, forceUpdate);
        else {
            res = new (0, $621d77364ac7bdec$export$2e2bcd8739ae039)(resourceId, data, this._context);
            this._resources[resourceId] = res;
        }
        res.persistent = persistent;
    }
    remove(resourceId) {
        const res = this._resources[resourceId];
        if (res) {
            res.delete();
            delete this._resources[resourceId];
        }
    }
    unsubscribe({ consumerId: consumerId  }) {
        const consumer = this._consumers[consumerId];
        if (consumer) {
            for(const requestId in consumer){
                const request = consumer[requestId];
                const resource = this._resources[request.resourceId];
                if (resource) resource.unsubscribe(request);
            }
            delete this._consumers[consumerId];
            this.prune();
        }
    }
    subscribe({ resourceId: resourceId , onChange: onChange , consumerId: consumerId , requestId: requestId = "default"  }) {
        const { _resources: resources , protocol: protocol  } = this;
        if (resourceId.startsWith(protocol)) {
            resourceId = resourceId.replace(protocol, "");
            if (!resources[resourceId]) this.add({
                resourceId: resourceId,
                data: null,
                persistent: false
            });
        }
        const res = resources[resourceId];
        this._track(consumerId, requestId, res, onChange);
        if (res) return res.getData();
        return undefined;
    }
    prune() {
        if (!this._pruneRequest) this._pruneRequest = setTimeout(()=>this._prune(), 0);
    }
    finalize() {
        for(const key in this._resources)this._resources[key].delete();
    }
    _track(consumerId, requestId, resource, onChange) {
        const consumers = this._consumers;
        const consumer = consumers[consumerId] = consumers[consumerId] || {};
        const request = consumer[requestId] || {};
        const oldResource = request.resourceId && this._resources[request.resourceId];
        if (oldResource) {
            oldResource.unsubscribe(request);
            this.prune();
        }
        if (resource) {
            consumer[requestId] = request;
            request.onChange = onChange;
            request.resourceId = resource.id;
            resource.subscribe(request);
        }
    }
    _prune() {
        this._pruneRequest = null;
        for (const key of Object.keys(this._resources)){
            const res = this._resources[key];
            if (!res.persistent && !res.inUse()) {
                res.delete();
                delete this._resources[key];
            }
        }
    }
}





class $e0cd51e92519f55c$export$ae7911e6e34e8f38 {
    constructor(options = {}){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_pool", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "opts", {
            overAlloc: 2,
            poolSize: 100
        });
        this.setOptions(options);
    }
    setOptions(options) {
        Object.assign(this.opts, options);
    }
    allocate(typedArray, count, { size: size = 1 , type: type , padding: padding = 0 , copy: copy = false , initialize: initialize = false , maxCount: maxCount  }) {
        const Type = type || typedArray && typedArray.constructor || Float32Array;
        const newSize = count * size + padding;
        if (ArrayBuffer.isView(typedArray)) {
            if (newSize <= typedArray.length) return typedArray;
            if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) return new Type(typedArray.buffer, 0, newSize);
        }
        let maxSize = Infinity;
        if (maxCount) maxSize = maxCount * size + padding;
        const newArray = this._allocate(Type, newSize, initialize, maxSize);
        if (typedArray && copy) newArray.set(typedArray);
        else if (!initialize) newArray.fill(0, 0, 4);
        this._release(typedArray);
        return newArray;
    }
    release(typedArray) {
        this._release(typedArray);
    }
    _allocate(Type, size, initialize, maxSize) {
        let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);
        if (sizeToAllocate > maxSize) sizeToAllocate = maxSize;
        const pool = this._pool;
        const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;
        const i = pool.findIndex((b)=>b.byteLength >= byteLength);
        if (i >= 0) {
            const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);
            if (initialize) array.fill(0);
            return array;
        }
        return new Type(sizeToAllocate);
    }
    _release(typedArray) {
        if (!ArrayBuffer.isView(typedArray)) return;
        const pool = this._pool;
        const { buffer: buffer  } = typedArray;
        const { byteLength: byteLength  } = buffer;
        const i = pool.findIndex((b)=>b.byteLength >= byteLength);
        if (i < 0) pool.push(buffer);
        else if (i > 0 || pool.length < this.opts.poolSize) pool.splice(i, 0, buffer);
        if (pool.length > this.opts.poolSize) pool.shift();
    }
}
var $e0cd51e92519f55c$export$2e2bcd8739ae039 = new $e0cd51e92519f55c$export$ae7911e6e34e8f38();


function $357091e5c1a009be$export$2e2bcd8739ae039(condition, message) {
    if (!condition) throw new Error("math.gl assertion ".concat(message));
}


const $53a37c44451cea56$var$RADIANS_TO_DEGREES = 1 / Math.PI * 180;
const $53a37c44451cea56$var$DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
const $53a37c44451cea56$export$e506a1d27d1eaa20 = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true
};
function $53a37c44451cea56$export$8d21e34596265fa2(options) {
    for(const key in options){
        (0, $357091e5c1a009be$export$2e2bcd8739ae039)(key in $53a37c44451cea56$export$e506a1d27d1eaa20);
        $53a37c44451cea56$export$e506a1d27d1eaa20[key] = options[key];
    }
    return $53a37c44451cea56$export$e506a1d27d1eaa20;
}
function $53a37c44451cea56$export$7c4d25c0c3217d8c(value, { precision: precision = $53a37c44451cea56$export$e506a1d27d1eaa20.precision  } = {}) {
    value = $53a37c44451cea56$var$round(value);
    return "".concat(parseFloat(value.toPrecision(precision)));
}
function $53a37c44451cea56$export$43bee75e5e14138e(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function $53a37c44451cea56$export$9cd59f9826255e47(array) {
    return "clone" in array ? array.clone() : array.slice();
}
function $53a37c44451cea56$export$cba01ba138429a1d(degrees1) {
    return $53a37c44451cea56$export$8449e153fbd325fc(degrees1);
}
function $53a37c44451cea56$export$56cb859c01fa134d(radians1) {
    return $53a37c44451cea56$export$41fc368e1a942b97(radians1);
}
function $53a37c44451cea56$export$8449e153fbd325fc(degrees2, result) {
    return $53a37c44451cea56$var$map(degrees2, (degrees3)=>degrees3 * $53a37c44451cea56$var$DEGREES_TO_RADIANS, result);
}
function $53a37c44451cea56$export$41fc368e1a942b97(radians2, result) {
    return $53a37c44451cea56$var$map(radians2, (radians3)=>radians3 * $53a37c44451cea56$var$RADIANS_TO_DEGREES, result);
}
function $53a37c44451cea56$export$5de3937cb4b592ed(radians4, result) {
    return $53a37c44451cea56$var$map(radians4, (angle)=>Math.sin(angle), result);
}
function $53a37c44451cea56$export$50d414a77b60d802(radians5, result) {
    return $53a37c44451cea56$var$map(radians5, (angle)=>Math.cos(angle), result);
}
function $53a37c44451cea56$export$fcdd3b0b3246a325(radians6, result) {
    return $53a37c44451cea56$var$map(radians6, (angle)=>Math.tan(angle), result);
}
function $53a37c44451cea56$export$41726bdb1fc63f(radians7, result) {
    return $53a37c44451cea56$var$map(radians7, (angle)=>Math.asin(angle), result);
}
function $53a37c44451cea56$export$fd6306be3fde5b04(radians8, result) {
    return $53a37c44451cea56$var$map(radians8, (angle)=>Math.acos(angle), result);
}
function $53a37c44451cea56$export$628dc4eed22b0fbd(radians9, result) {
    return $53a37c44451cea56$var$map(radians9, (angle)=>Math.atan(angle), result);
}
function $53a37c44451cea56$export$7d15b64cf5a3a4c4(value1, min, max) {
    return $53a37c44451cea56$var$map(value1, (value)=>Math.max(min, Math.min(max, value)));
}
function $53a37c44451cea56$export$3a89f8d6f6bf6c9f(a, b, t) {
    if ($53a37c44451cea56$export$43bee75e5e14138e(a)) return a.map((ai, i)=>$53a37c44451cea56$export$3a89f8d6f6bf6c9f(ai, b[i], t));
    return t * b + (1 - t) * a;
}
function $53a37c44451cea56$export$e9bab7fafb253603(a, b, epsilon) {
    const oldEpsilon = $53a37c44451cea56$export$e506a1d27d1eaa20.EPSILON;
    if (epsilon) $53a37c44451cea56$export$e506a1d27d1eaa20.EPSILON = epsilon;
    try {
        if (a === b) return true;
        if ($53a37c44451cea56$export$43bee75e5e14138e(a) && $53a37c44451cea56$export$43bee75e5e14138e(b)) {
            if (a.length !== b.length) return false;
            for(let i = 0; i < a.length; ++i){
                if (!$53a37c44451cea56$export$e9bab7fafb253603(a[i], b[i])) return false;
            }
            return true;
        }
        if (a && a.equals) return a.equals(b);
        if (b && b.equals) return b.equals(a);
        if (typeof a === "number" && typeof b === "number") return Math.abs(a - b) <= $53a37c44451cea56$export$e506a1d27d1eaa20.EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
        return false;
    } finally{
        $53a37c44451cea56$export$e506a1d27d1eaa20.EPSILON = oldEpsilon;
    }
}
function $53a37c44451cea56$export$f2599a5cf1109d8(a, b) {
    if (a === b) return true;
    if (a && typeof a === "object" && b && typeof b === "object") {
        if (a.constructor !== b.constructor) return false;
        if (a.exactEquals) return a.exactEquals(b);
    }
    if ($53a37c44451cea56$export$43bee75e5e14138e(a) && $53a37c44451cea56$export$43bee75e5e14138e(b)) {
        if (a.length !== b.length) return false;
        for(let i = 0; i < a.length; ++i){
            if (!$53a37c44451cea56$export$f2599a5cf1109d8(a[i], b[i])) return false;
        }
        return true;
    }
    return false;
}
function $53a37c44451cea56$export$33e486a830e586b3(epsilon, func) {
    const oldPrecision = $53a37c44451cea56$export$e506a1d27d1eaa20.EPSILON;
    $53a37c44451cea56$export$e506a1d27d1eaa20.EPSILON = epsilon;
    let value;
    try {
        value = func();
    } finally{
        $53a37c44451cea56$export$e506a1d27d1eaa20.EPSILON = oldPrecision;
    }
    return value;
}
function $53a37c44451cea56$var$round(value) {
    return Math.round(value / $53a37c44451cea56$export$e506a1d27d1eaa20.EPSILON) * $53a37c44451cea56$export$e506a1d27d1eaa20.EPSILON;
}
function $53a37c44451cea56$var$duplicateArray(array) {
    return array.clone ? array.clone() : new Array(array.length);
}
function $53a37c44451cea56$var$map(value, func, result) {
    if ($53a37c44451cea56$export$43bee75e5e14138e(value)) {
        const array = value;
        result = result || $53a37c44451cea56$var$duplicateArray(array);
        for(let i = 0; i < result.length && i < array.length; ++i)result[i] = func(value[i], i, result);
        return result;
    }
    return func(value);
}


function $99c41966f61b2e6e$var$_extendableBuiltin(cls) {
    function ExtendableBuiltin() {
        var instance = Reflect.construct(cls, Array.from(arguments));
        Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
        return instance;
    }
    ExtendableBuiltin.prototype = Object.create(cls.prototype, {
        constructor: {
            value: cls,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (Object.setPrototypeOf) Object.setPrototypeOf(ExtendableBuiltin, cls);
    else ExtendableBuiltin.__proto__ = cls;
    return ExtendableBuiltin;
}
class $99c41966f61b2e6e$export$2e2bcd8739ae039 extends $99c41966f61b2e6e$var$_extendableBuiltin(Array) {
    clone() {
        return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] = array[i + offset];
        return this.check();
    }
    toArray(targetArray = [], offset = 0) {
        for(let i = 0; i < this.ELEMENTS; ++i)targetArray[offset + i] = this[i];
        return targetArray;
    }
    from(arrayOrObject) {
        return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
    }
    to(arrayOrObject) {
        if (arrayOrObject === this) return this;
        return (0, $53a37c44451cea56$export$43bee75e5e14138e)(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
    toTarget(target) {
        return target ? this.to(target) : this;
    }
    toFloat32Array() {
        return new Float32Array(this);
    }
    toString() {
        return this.formatString((0, $53a37c44451cea56$export$e506a1d27d1eaa20));
    }
    formatString(opts) {
        let string = "";
        for(let i = 0; i < this.ELEMENTS; ++i)string += (i > 0 ? ", " : "") + (0, $53a37c44451cea56$export$7c4d25c0c3217d8c)(this[i], opts);
        return "".concat(opts.printTypes ? this.constructor.name : "", "[").concat(string, "]");
    }
    equals(array) {
        if (!array || this.length !== array.length) return false;
        for(let i = 0; i < this.ELEMENTS; ++i){
            if (!(0, $53a37c44451cea56$export$e9bab7fafb253603)(this[i], array[i])) return false;
        }
        return true;
    }
    exactEquals(array) {
        if (!array || this.length !== array.length) return false;
        for(let i = 0; i < this.ELEMENTS; ++i){
            if (this[i] !== array[i]) return false;
        }
        return true;
    }
    negate() {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] = -this[i];
        return this.check();
    }
    lerp(a, b, t) {
        if (t === undefined) return this.lerp(this, a, b);
        for(let i = 0; i < this.ELEMENTS; ++i){
            const ai = a[i];
            this[i] = ai + t * (b[i] - ai);
        }
        return this.check();
    }
    min(vector) {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] = Math.min(vector[i], this[i]);
        return this.check();
    }
    max(vector) {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] = Math.max(vector[i], this[i]);
        return this.check();
    }
    clamp(minVector, maxVector) {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
        return this.check();
    }
    add(...vectors) {
        for (const vector of vectors)for(let i = 0; i < this.ELEMENTS; ++i)this[i] += vector[i];
        return this.check();
    }
    subtract(...vectors) {
        for (const vector of vectors)for(let i = 0; i < this.ELEMENTS; ++i)this[i] -= vector[i];
        return this.check();
    }
    scale(scale) {
        if (typeof scale === "number") for(let i = 0; i < this.ELEMENTS; ++i)this[i] *= scale;
        else for(let i1 = 0; i1 < this.ELEMENTS && i1 < scale.length; ++i1)this[i1] *= scale[i1];
        return this.check();
    }
    multiplyByScalar(scalar) {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] *= scalar;
        return this.check();
    }
    check() {
        if ((0, $53a37c44451cea56$export$e506a1d27d1eaa20).debug && !this.validate()) throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
        return this;
    }
    validate() {
        let valid = this.length === this.ELEMENTS;
        for(let i = 0; i < this.ELEMENTS; ++i)valid = valid && Number.isFinite(this[i]);
        return valid;
    }
    sub(a) {
        return this.subtract(a);
    }
    setScalar(a) {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] = a;
        return this.check();
    }
    addScalar(a) {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] += a;
        return this.check();
    }
    subScalar(a) {
        return this.addScalar(-a);
    }
    multiplyScalar(scalar) {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] *= scalar;
        return this.check();
    }
    divideScalar(a) {
        return this.multiplyByScalar(1 / a);
    }
    clampScalar(min, max) {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] = Math.min(Math.max(this[i], min), max);
        return this.check();
    }
    get elements() {
        return this;
    }
}



function $c362065f7b29175e$export$a1b6cd0c891cc7(v, length) {
    if (v.length !== length) return false;
    for(let i = 0; i < v.length; ++i){
        if (!Number.isFinite(v[i])) return false;
    }
    return true;
}
function $c362065f7b29175e$export$74ff82ccb88f9fb1(value) {
    if (!Number.isFinite(value)) throw new Error("Invalid number ".concat(value));
    return value;
}
function $c362065f7b29175e$export$3eb62eb6ef90f888(v, length, callerName = "") {
    if ((0, $53a37c44451cea56$export$e506a1d27d1eaa20).debug && !$c362065f7b29175e$export$a1b6cd0c891cc7(v, length)) throw new Error("math.gl: ".concat(callerName, " some fields set to invalid numbers'"));
    return v;
}
const $c362065f7b29175e$var$map = {};
function $c362065f7b29175e$export$cdd73fc4100a6ef4(method, version) {
    if (!$c362065f7b29175e$var$map[method]) {
        $c362065f7b29175e$var$map[method] = true;
        console.warn("".concat(method, " has been removed in version ").concat(version, ", see upgrade guide for more information"));
    }
}



class $b690e88cf380b7fe$export$2e2bcd8739ae039 extends (0, $99c41966f61b2e6e$export$2e2bcd8739ae039) {
    get x() {
        return this[0];
    }
    set x(value) {
        this[0] = (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(value);
    }
    get y() {
        return this[1];
    }
    set y(value) {
        this[1] = (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(value);
    }
    len() {
        return Math.sqrt(this.lengthSquared());
    }
    magnitude() {
        return this.len();
    }
    lengthSquared() {
        let length = 0;
        for(let i = 0; i < this.ELEMENTS; ++i)length += this[i] * this[i];
        return length;
    }
    magnitudeSquared() {
        return this.lengthSquared();
    }
    distance(mathArray) {
        return Math.sqrt(this.distanceSquared(mathArray));
    }
    distanceSquared(mathArray) {
        let length = 0;
        for(let i = 0; i < this.ELEMENTS; ++i){
            const dist = this[i] - mathArray[i];
            length += dist * dist;
        }
        return (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(length);
    }
    dot(mathArray) {
        let product = 0;
        for(let i = 0; i < this.ELEMENTS; ++i)product += this[i] * mathArray[i];
        return (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(product);
    }
    normalize() {
        const length = this.magnitude();
        if (length !== 0) for(let i = 0; i < this.ELEMENTS; ++i)this[i] /= length;
        return this.check();
    }
    multiply(...vectors) {
        for (const vector of vectors)for(let i = 0; i < this.ELEMENTS; ++i)this[i] *= vector[i];
        return this.check();
    }
    divide(...vectors) {
        for (const vector of vectors)for(let i = 0; i < this.ELEMENTS; ++i)this[i] /= vector[i];
        return this.check();
    }
    lengthSq() {
        return this.lengthSquared();
    }
    distanceTo(vector) {
        return this.distance(vector);
    }
    distanceToSquared(vector) {
        return this.distanceSquared(vector);
    }
    getComponent(i) {
        (0, $357091e5c1a009be$export$2e2bcd8739ae039)(i >= 0 && i < this.ELEMENTS, "index is out of range");
        return (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(this[i]);
    }
    setComponent(i, value) {
        (0, $357091e5c1a009be$export$2e2bcd8739ae039)(i >= 0 && i < this.ELEMENTS, "index is out of range");
        this[i] = value;
        return this.check();
    }
    addVectors(a, b) {
        return this.copy(a).add(b);
    }
    subVectors(a, b) {
        return this.copy(a).subtract(b);
    }
    multiplyVectors(a, b) {
        return this.copy(a).multiply(b);
    }
    addScaledVector(a, b) {
        return this.add(new this.constructor(a).multiplyScalar(b));
    }
}





function $68948bc2139893c7$export$185802fd694ee1f5() {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(3);
    if ($90626a8105199b14$export$b67359430d3b1b2 != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
    }
    return out;
}
function $68948bc2139893c7$export$9cd59f9826255e47(a) {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
}
function $68948bc2139893c7$export$f24224f1c91d8156(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.hypot(x, y, z);
}
function $68948bc2139893c7$export$a82be99ed2a44a7d(x, y, z) {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
}
function $68948bc2139893c7$export$784d13d8ee351f07(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
}
function $68948bc2139893c7$export$adaa4cf7ef1b65be(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
}
function $68948bc2139893c7$export$e16d8520af44a096(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
}
function $68948bc2139893c7$export$4e2d2ead65e5f7e3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
}
function $68948bc2139893c7$export$2060d2db72cce88f(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
}
function $68948bc2139893c7$export$cd007d971a5a2143(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
}
function $68948bc2139893c7$export$803ce6b71a0a94b2(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
}
function $68948bc2139893c7$export$a3fe094919f356fd(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
}
function $68948bc2139893c7$export$96ec731ed4dcb222(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
}
function $68948bc2139893c7$export$8960430cfd85939f(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
}
function $68948bc2139893c7$export$2077e0241d6afd3c(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
}
function $68948bc2139893c7$export$dcdf75081b88279d(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
}
function $68948bc2139893c7$export$19cedf1da84ba854(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    return out;
}
function $68948bc2139893c7$export$9f17032d917177de(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return Math.hypot(x, y, z);
}
function $68948bc2139893c7$export$88e6ebb4fe54f538(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return x * x + y * y + z * z;
}
function $68948bc2139893c7$export$ab44e1323ffc8376(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return x * x + y * y + z * z;
}
function $68948bc2139893c7$export$aef51622e549b8b0(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
}
function $68948bc2139893c7$export$70ae2c07e401031b(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    out[2] = 1.0 / a[2];
    return out;
}
function $68948bc2139893c7$export$a3295358bff77e(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len1 = x * x + y * y + z * z;
    if (len1 > 0) //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
    out[0] = a[0] * len1;
    out[1] = a[1] * len1;
    out[2] = a[2] * len1;
    return out;
}
function $68948bc2139893c7$export$94132a0e348806d4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function $68948bc2139893c7$export$bb646b20bb93d339(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
}
function $68948bc2139893c7$export$3a89f8d6f6bf6c9f(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
}
function $68948bc2139893c7$export$ae8865616f30561c(out, a, b, c, d, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
}
function $68948bc2139893c7$export$b9c5f84610baddaf(out, a, b, c, d, t) {
    var inverseFactor = 1 - t;
    var inverseFactorTimesTwo = inverseFactor * inverseFactor;
    var factorTimes2 = t * t;
    var factor1 = inverseFactorTimesTwo * inverseFactor;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * inverseFactor;
    var factor4 = factorTimes2 * t;
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
}
function $68948bc2139893c7$export$4385e60b38654f68(out, scale2) {
    scale2 = scale2 || 1.0;
    var r = $90626a8105199b14$export$5ada478c8a628231() * 2.0 * Math.PI;
    var z = $90626a8105199b14$export$5ada478c8a628231() * 2.0 - 1.0;
    var zScale = Math.sqrt(1.0 - z * z) * scale2;
    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale2;
    return out;
}
function $68948bc2139893c7$export$5ffbd13800309d59(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
}
function $68948bc2139893c7$export$f0bfa0a0024626ee(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
}
function $68948bc2139893c7$export$c32adef9e939ce85(out, a, q) {
    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x = a[0], y = a[1], z = a[2]; // var qvec = [qx, qy, qz];
    // var uv = vec3.cross([], qvec, a);
    var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2; // vec3.scale(uuv, uuv, 2);
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));
    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
}
function $68948bc2139893c7$export$a59c8716592e09af(out, a, b, rad) {
    var p = [], r = []; //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation
    r[0] = p[0];
    r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
    r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function $68948bc2139893c7$export$cf71e4d4ca4d1cfd(out, a, b, rad) {
    var p = [], r = []; //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation
    r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
    r[1] = p[1];
    r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function $68948bc2139893c7$export$ea6eae3365de5b9c(out, a, b, rad) {
    var p = [], r = []; //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation
    r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
    r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
    r[2] = p[2]; //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function $68948bc2139893c7$export$944b09d2ad10b378(a, b) {
    var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && $68948bc2139893c7$export$94132a0e348806d4(a, b) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function $68948bc2139893c7$export$7f9972325ebfd559(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    out[2] = 0.0;
    return out;
}
function $68948bc2139893c7$export$42d51816ce590c93(a) {
    return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function $68948bc2139893c7$export$f2599a5cf1109d8(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function $68948bc2139893c7$export$e9bab7fafb253603(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return Math.abs(a0 - b0) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
var $68948bc2139893c7$export$f93b5905241a7cca = $68948bc2139893c7$export$4e2d2ead65e5f7e3;
var $68948bc2139893c7$export$6e3a27864ab166fe = $68948bc2139893c7$export$2060d2db72cce88f;
var $68948bc2139893c7$export$159d9494db57879b = $68948bc2139893c7$export$cd007d971a5a2143;
var $68948bc2139893c7$export$6c4a311cc157c764 = $68948bc2139893c7$export$9f17032d917177de;
var $68948bc2139893c7$export$2422cd6c492a8b3a = $68948bc2139893c7$export$88e6ebb4fe54f538;
var $68948bc2139893c7$export$fc1400facf92c78 = $68948bc2139893c7$export$f24224f1c91d8156;
var $68948bc2139893c7$export$99d8dd3f32a3435 = $68948bc2139893c7$export$ab44e1323ffc8376;
var $68948bc2139893c7$export$4b80e395e36b5a56 = function() {
    var vec = $68948bc2139893c7$export$185802fd694ee1f5();
    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if (!stride) stride = 3;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            vec[2] = a[i + 2];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
            a[i + 2] = vec[2];
        }
        return a;
    };
}();


function $04a7f04ce3522ae0$export$9c22d6d462b57a6c(out, a, m) {
    const x = a[0];
    const y = a[1];
    const w = m[3] * x + m[7] * y || 1.0;
    out[0] = (m[0] * x + m[4] * y) / w;
    out[1] = (m[1] * x + m[5] * y) / w;
    return out;
}
function $04a7f04ce3522ae0$export$df62a5cc0f49271(out, a, m) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    const w = m[3] * x + m[7] * y + m[11] * z || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
    return out;
}
function $04a7f04ce3522ae0$export$1287c03b2c6fb6a5(out, a, m) {
    const x = a[0];
    const y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    out[2] = a[2];
    return out;
}
function $04a7f04ce3522ae0$export$808cc2c9e882a204(out, a, m) {
    const x = a[0];
    const y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function $04a7f04ce3522ae0$export$bfe7f279eafb7f9b(out, a, m) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    out[0] = m[0] * x + m[3] * y + m[6] * z;
    out[1] = m[1] * x + m[4] * y + m[7] * z;
    out[2] = m[2] * x + m[5] * y + m[8] * z;
    out[3] = a[3];
    return out;
}


const $9c6695c39a874609$var$ORIGIN = [
    0,
    0,
    0
];
let $9c6695c39a874609$var$ZERO;
class $9c6695c39a874609$export$2e2bcd8739ae039 extends (0, $b690e88cf380b7fe$export$2e2bcd8739ae039) {
    static get ZERO() {
        if (!$9c6695c39a874609$var$ZERO) {
            $9c6695c39a874609$var$ZERO = new $9c6695c39a874609$export$2e2bcd8739ae039(0, 0, 0);
            Object.freeze($9c6695c39a874609$var$ZERO);
        }
        return $9c6695c39a874609$var$ZERO;
    }
    constructor(x = 0, y = 0, z = 0){
        super(-0, -0, -0);
        if (arguments.length === 1 && (0, $53a37c44451cea56$export$43bee75e5e14138e)(x)) this.copy(x);
        else {
            if ((0, $53a37c44451cea56$export$e506a1d27d1eaa20).debug) {
                (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(x);
                (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(y);
                (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(z);
            }
            this[0] = x;
            this[1] = y;
            this[2] = z;
        }
    }
    set(x, y, z) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        return this.check();
    }
    copy(array) {
        this[0] = array[0];
        this[1] = array[1];
        this[2] = array[2];
        return this.check();
    }
    fromObject(object) {
        if ((0, $53a37c44451cea56$export$e506a1d27d1eaa20).debug) {
            (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(object.x);
            (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(object.y);
            (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(object.z);
        }
        this[0] = object.x;
        this[1] = object.y;
        this[2] = object.z;
        return this.check();
    }
    toObject(object) {
        object.x = this[0];
        object.y = this[1];
        object.z = this[2];
        return object;
    }
    get ELEMENTS() {
        return 3;
    }
    get z() {
        return this[2];
    }
    set z(value) {
        this[2] = (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(value);
    }
    angle(vector) {
        return $68948bc2139893c7$export$944b09d2ad10b378(this, vector);
    }
    cross(vector) {
        $68948bc2139893c7$export$bb646b20bb93d339(this, this, vector);
        return this.check();
    }
    rotateX({ radians: radians , origin: origin = $9c6695c39a874609$var$ORIGIN  }) {
        $68948bc2139893c7$export$a59c8716592e09af(this, this, origin, radians);
        return this.check();
    }
    rotateY({ radians: radians , origin: origin = $9c6695c39a874609$var$ORIGIN  }) {
        $68948bc2139893c7$export$cf71e4d4ca4d1cfd(this, this, origin, radians);
        return this.check();
    }
    rotateZ({ radians: radians , origin: origin = $9c6695c39a874609$var$ORIGIN  }) {
        $68948bc2139893c7$export$ea6eae3365de5b9c(this, this, origin, radians);
        return this.check();
    }
    transform(matrix4) {
        return this.transformAsPoint(matrix4);
    }
    transformAsPoint(matrix4) {
        $68948bc2139893c7$export$5ffbd13800309d59(this, this, matrix4);
        return this.check();
    }
    transformAsVector(matrix4) {
        (0, $04a7f04ce3522ae0$export$df62a5cc0f49271)(this, this, matrix4);
        return this.check();
    }
    transformByMatrix3(matrix3) {
        $68948bc2139893c7$export$f0bfa0a0024626ee(this, this, matrix3);
        return this.check();
    }
    transformByMatrix2(matrix2) {
        (0, $04a7f04ce3522ae0$export$1287c03b2c6fb6a5)(this, this, matrix2);
        return this.check();
    }
    transformByQuaternion(quaternion) {
        $68948bc2139893c7$export$c32adef9e939ce85(this, this, quaternion);
        return this.check();
    }
}




class $cbe714f87587f435$export$2e2bcd8739ae039 extends (0, $99c41966f61b2e6e$export$2e2bcd8739ae039) {
    toString() {
        let string = "[";
        if ((0, $53a37c44451cea56$export$e506a1d27d1eaa20).printRowMajor) {
            string += "row-major:";
            for(let row = 0; row < this.RANK; ++row)for(let col = 0; col < this.RANK; ++col)string += " ".concat(this[col * this.RANK + row]);
        } else {
            string += "column-major:";
            for(let i = 0; i < this.ELEMENTS; ++i)string += " ".concat(this[i]);
        }
        string += "]";
        return string;
    }
    getElementIndex(row, col) {
        return col * this.RANK + row;
    }
    getElement(row, col) {
        return this[col * this.RANK + row];
    }
    setElement(row, col, value) {
        this[col * this.RANK + row] = (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(value);
        return this;
    }
    getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
        const firstIndex = columnIndex * this.RANK;
        for(let i = 0; i < this.RANK; ++i)result[i] = this[firstIndex + i];
        return result;
    }
    setColumn(columnIndex, columnVector) {
        const firstIndex = columnIndex * this.RANK;
        for(let i = 0; i < this.RANK; ++i)this[firstIndex + i] = columnVector[i];
        return this;
    }
}






function $fceb3370258170b6$export$185802fd694ee1f5() {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(2);
    if ($90626a8105199b14$export$b67359430d3b1b2 != Float32Array) {
        out[0] = 0;
        out[1] = 0;
    }
    return out;
}
function $fceb3370258170b6$export$9cd59f9826255e47(a) {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
}
function $fceb3370258170b6$export$a82be99ed2a44a7d(x, y) {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(2);
    out[0] = x;
    out[1] = y;
    return out;
}
function $fceb3370258170b6$export$784d13d8ee351f07(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
}
function $fceb3370258170b6$export$adaa4cf7ef1b65be(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
}
function $fceb3370258170b6$export$e16d8520af44a096(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
}
function $fceb3370258170b6$export$4e2d2ead65e5f7e3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
}
function $fceb3370258170b6$export$2060d2db72cce88f(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
}
function $fceb3370258170b6$export$cd007d971a5a2143(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
}
function $fceb3370258170b6$export$803ce6b71a0a94b2(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
}
function $fceb3370258170b6$export$a3fe094919f356fd(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
}
function $fceb3370258170b6$export$96ec731ed4dcb222(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
}
function $fceb3370258170b6$export$8960430cfd85939f(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
}
function $fceb3370258170b6$export$2077e0241d6afd3c(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
}
function $fceb3370258170b6$export$dcdf75081b88279d(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
}
function $fceb3370258170b6$export$19cedf1da84ba854(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    return out;
}
function $fceb3370258170b6$export$9f17032d917177de(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return Math.hypot(x, y);
}
function $fceb3370258170b6$export$88e6ebb4fe54f538(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return x * x + y * y;
}
function $fceb3370258170b6$export$f24224f1c91d8156(a) {
    var x = a[0], y = a[1];
    return Math.hypot(x, y);
}
function $fceb3370258170b6$export$ab44e1323ffc8376(a) {
    var x = a[0], y = a[1];
    return x * x + y * y;
}
function $fceb3370258170b6$export$aef51622e549b8b0(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
}
function $fceb3370258170b6$export$70ae2c07e401031b(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    return out;
}
function $fceb3370258170b6$export$a3295358bff77e(out, a) {
    var x = a[0], y = a[1];
    var len1 = x * x + y * y;
    if (len1 > 0) //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
    out[0] = a[0] * len1;
    out[1] = a[1] * len1;
    return out;
}
function $fceb3370258170b6$export$94132a0e348806d4(a, b) {
    return a[0] * b[0] + a[1] * b[1];
}
function $fceb3370258170b6$export$bb646b20bb93d339(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
}
function $fceb3370258170b6$export$3a89f8d6f6bf6c9f(out, a, b, t) {
    var ax = a[0], ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
}
function $fceb3370258170b6$export$4385e60b38654f68(out, scale2) {
    scale2 = scale2 || 1.0;
    var r = $90626a8105199b14$export$5ada478c8a628231() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale2;
    out[1] = Math.sin(r) * scale2;
    return out;
}
function $fceb3370258170b6$export$b732428d73874bfc(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
}
function $fceb3370258170b6$export$3e55bc4b3707dfd3(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
}
function $fceb3370258170b6$export$f0bfa0a0024626ee(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
}
function $fceb3370258170b6$export$5ffbd13800309d59(out, a, m) {
    var x = a[0];
    var y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
}
function $fceb3370258170b6$export$bb628a54ab399bc9(out, a, b, rad) {
    //Translate point to the origin
    var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(rad), cosC = Math.cos(rad); //perform rotation and translate to correct position
    out[0] = p0 * cosC - p1 * sinC + b[0];
    out[1] = p0 * sinC + p1 * cosC + b[1];
    return out;
}
function $fceb3370258170b6$export$944b09d2ad10b378(a, b) {
    var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], // mag is the product of the magnitudes of a and b
    mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), // mag &&.. short circuits if mag == 0
    cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function $fceb3370258170b6$export$7f9972325ebfd559(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    return out;
}
function $fceb3370258170b6$export$42d51816ce590c93(a) {
    return "vec2(" + a[0] + ", " + a[1] + ")";
}
function $fceb3370258170b6$export$f2599a5cf1109d8(a, b) {
    return a[0] === b[0] && a[1] === b[1];
}
function $fceb3370258170b6$export$e9bab7fafb253603(a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return Math.abs(a0 - b0) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
var $fceb3370258170b6$export$fc1400facf92c78 = $fceb3370258170b6$export$f24224f1c91d8156;
var $fceb3370258170b6$export$f93b5905241a7cca = $fceb3370258170b6$export$4e2d2ead65e5f7e3;
var $fceb3370258170b6$export$6e3a27864ab166fe = $fceb3370258170b6$export$2060d2db72cce88f;
var $fceb3370258170b6$export$159d9494db57879b = $fceb3370258170b6$export$cd007d971a5a2143;
var $fceb3370258170b6$export$6c4a311cc157c764 = $fceb3370258170b6$export$9f17032d917177de;
var $fceb3370258170b6$export$2422cd6c492a8b3a = $fceb3370258170b6$export$88e6ebb4fe54f538;
var $fceb3370258170b6$export$99d8dd3f32a3435 = $fceb3370258170b6$export$ab44e1323ffc8376;
var $fceb3370258170b6$export$4b80e395e36b5a56 = function() {
    var vec = $fceb3370258170b6$export$185802fd694ee1f5();
    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if (!stride) stride = 2;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
        }
        return a;
    };
}();




var $16800f0dff513c4e$var$INDICES;
(function(INDICES1) {
    INDICES1[INDICES1["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES1[INDICES1["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES1[INDICES1["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES1[INDICES1["COL0ROW3"] = 3] = "COL0ROW3";
    INDICES1[INDICES1["COL1ROW0"] = 4] = "COL1ROW0";
    INDICES1[INDICES1["COL1ROW1"] = 5] = "COL1ROW1";
    INDICES1[INDICES1["COL1ROW2"] = 6] = "COL1ROW2";
    INDICES1[INDICES1["COL1ROW3"] = 7] = "COL1ROW3";
    INDICES1[INDICES1["COL2ROW0"] = 8] = "COL2ROW0";
    INDICES1[INDICES1["COL2ROW1"] = 9] = "COL2ROW1";
    INDICES1[INDICES1["COL2ROW2"] = 10] = "COL2ROW2";
    INDICES1[INDICES1["COL2ROW3"] = 11] = "COL2ROW3";
    INDICES1[INDICES1["COL3ROW0"] = 12] = "COL3ROW0";
    INDICES1[INDICES1["COL3ROW1"] = 13] = "COL3ROW1";
    INDICES1[INDICES1["COL3ROW2"] = 14] = "COL3ROW2";
    INDICES1[INDICES1["COL3ROW3"] = 15] = "COL3ROW3";
})($16800f0dff513c4e$var$INDICES || ($16800f0dff513c4e$var$INDICES = {}));
const $16800f0dff513c4e$var$DEFAULT_FOVY = 45 * Math.PI / 180;
const $16800f0dff513c4e$var$DEFAULT_ASPECT = 1;
const $16800f0dff513c4e$var$DEFAULT_NEAR = 0.1;
const $16800f0dff513c4e$var$DEFAULT_FAR = 500;
const $16800f0dff513c4e$var$IDENTITY_MATRIX = Object.freeze([
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
]);
class $16800f0dff513c4e$export$2e2bcd8739ae039 extends (0, $cbe714f87587f435$export$2e2bcd8739ae039) {
    static get IDENTITY() {
        return $16800f0dff513c4e$var$getIdentityMatrix();
    }
    static get ZERO() {
        return $16800f0dff513c4e$var$getZeroMatrix();
    }
    get ELEMENTS() {
        return 16;
    }
    get RANK() {
        return 4;
    }
    get INDICES() {
        return $16800f0dff513c4e$var$INDICES;
    }
    constructor(array){
        super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
        if (arguments.length === 1 && Array.isArray(array)) this.copy(array);
        else this.identity();
    }
    copy(array) {
        this[0] = array[0];
        this[1] = array[1];
        this[2] = array[2];
        this[3] = array[3];
        this[4] = array[4];
        this[5] = array[5];
        this[6] = array[6];
        this[7] = array[7];
        this[8] = array[8];
        this[9] = array[9];
        this[10] = array[10];
        this[11] = array[11];
        this[12] = array[12];
        this[13] = array[13];
        this[14] = array[14];
        this[15] = array[15];
        return this.check();
    }
    set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
        this[0] = m00;
        this[1] = m10;
        this[2] = m20;
        this[3] = m30;
        this[4] = m01;
        this[5] = m11;
        this[6] = m21;
        this[7] = m31;
        this[8] = m02;
        this[9] = m12;
        this[10] = m22;
        this[11] = m32;
        this[12] = m03;
        this[13] = m13;
        this[14] = m23;
        this[15] = m33;
        return this.check();
    }
    setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        this[0] = m00;
        this[1] = m10;
        this[2] = m20;
        this[3] = m30;
        this[4] = m01;
        this[5] = m11;
        this[6] = m21;
        this[7] = m31;
        this[8] = m02;
        this[9] = m12;
        this[10] = m22;
        this[11] = m32;
        this[12] = m03;
        this[13] = m13;
        this[14] = m23;
        this[15] = m33;
        return this.check();
    }
    toRowMajor(result) {
        result[0] = this[0];
        result[1] = this[4];
        result[2] = this[8];
        result[3] = this[12];
        result[4] = this[1];
        result[5] = this[5];
        result[6] = this[9];
        result[7] = this[13];
        result[8] = this[2];
        result[9] = this[6];
        result[10] = this[10];
        result[11] = this[14];
        result[12] = this[3];
        result[13] = this[7];
        result[14] = this[11];
        result[15] = this[15];
        return result;
    }
    identity() {
        return this.copy($16800f0dff513c4e$var$IDENTITY_MATRIX);
    }
    fromObject(object) {
        return this.check();
    }
    fromQuaternion(quaternion) {
        $46ec5f9ed0e75076$export$2ff2bbe382249af7(this, quaternion);
        return this.check();
    }
    frustum(view) {
        const { left: left , right: right , bottom: bottom , top: top , near: near = $16800f0dff513c4e$var$DEFAULT_NEAR , far: far = $16800f0dff513c4e$var$DEFAULT_FAR  } = view;
        if (far === Infinity) $16800f0dff513c4e$var$computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
        else $46ec5f9ed0e75076$export$89b5708c387cac6c(this, left, right, bottom, top, near, far);
        return this.check();
    }
    lookAt(view) {
        const { eye: eye , center: center = [
            0,
            0,
            0
        ] , up: up = [
            0,
            1,
            0
        ]  } = view;
        $46ec5f9ed0e75076$export$d924e14fd6d9aa66(this, eye, center, up);
        return this.check();
    }
    ortho(view) {
        const { left: left , right: right , bottom: bottom , top: top , near: near = $16800f0dff513c4e$var$DEFAULT_NEAR , far: far = $16800f0dff513c4e$var$DEFAULT_FAR  } = view;
        $46ec5f9ed0e75076$export$4f2167e613cfc87b(this, left, right, bottom, top, near, far);
        return this.check();
    }
    orthographic(view) {
        const { fovy: fovy = $16800f0dff513c4e$var$DEFAULT_FOVY , aspect: aspect = $16800f0dff513c4e$var$DEFAULT_ASPECT , focalDistance: focalDistance = 1 , near: near = $16800f0dff513c4e$var$DEFAULT_NEAR , far: far = $16800f0dff513c4e$var$DEFAULT_FAR  } = view;
        $16800f0dff513c4e$var$checkRadians(fovy);
        const halfY = fovy / 2;
        const top = focalDistance * Math.tan(halfY);
        const right = top * aspect;
        return this.ortho({
            left: -right,
            right: right,
            bottom: -top,
            top: top,
            near: near,
            far: far
        });
    }
    perspective(view) {
        const { fovy: fovy = 45 * Math.PI / 180 , aspect: aspect = 1 , near: near = 0.1 , far: far = 500  } = view;
        $16800f0dff513c4e$var$checkRadians(fovy);
        $46ec5f9ed0e75076$export$541149539f3a4684(this, fovy, aspect, near, far);
        return this.check();
    }
    determinant() {
        return $46ec5f9ed0e75076$export$a04698f914c55ed9(this);
    }
    getScale(result = [
        -0,
        -0,
        -0
    ]) {
        result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
        result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
        result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
        return result;
    }
    getTranslation(result = [
        -0,
        -0,
        -0
    ]) {
        result[0] = this[12];
        result[1] = this[13];
        result[2] = this[14];
        return result;
    }
    getRotation(result, scaleResult) {
        result = result || [
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0
        ];
        scaleResult = scaleResult || [
            -0,
            -0,
            -0
        ];
        const scale = this.getScale(scaleResult);
        const inverseScale0 = 1 / scale[0];
        const inverseScale1 = 1 / scale[1];
        const inverseScale2 = 1 / scale[2];
        result[0] = this[0] * inverseScale0;
        result[1] = this[1] * inverseScale1;
        result[2] = this[2] * inverseScale2;
        result[3] = 0;
        result[4] = this[4] * inverseScale0;
        result[5] = this[5] * inverseScale1;
        result[6] = this[6] * inverseScale2;
        result[7] = 0;
        result[8] = this[8] * inverseScale0;
        result[9] = this[9] * inverseScale1;
        result[10] = this[10] * inverseScale2;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
    }
    getRotationMatrix3(result, scaleResult) {
        result = result || [
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0
        ];
        scaleResult = scaleResult || [
            -0,
            -0,
            -0
        ];
        const scale = this.getScale(scaleResult);
        const inverseScale0 = 1 / scale[0];
        const inverseScale1 = 1 / scale[1];
        const inverseScale2 = 1 / scale[2];
        result[0] = this[0] * inverseScale0;
        result[1] = this[1] * inverseScale1;
        result[2] = this[2] * inverseScale2;
        result[3] = this[4] * inverseScale0;
        result[4] = this[5] * inverseScale1;
        result[5] = this[6] * inverseScale2;
        result[6] = this[8] * inverseScale0;
        result[7] = this[9] * inverseScale1;
        result[8] = this[10] * inverseScale2;
        return result;
    }
    transpose() {
        $46ec5f9ed0e75076$export$9cb09a71b7d66923(this, this);
        return this.check();
    }
    invert() {
        $46ec5f9ed0e75076$export$6897c284b6f9f4dc(this, this);
        return this.check();
    }
    multiplyLeft(a) {
        $46ec5f9ed0e75076$export$2060d2db72cce88f(this, a, this);
        return this.check();
    }
    multiplyRight(a) {
        $46ec5f9ed0e75076$export$2060d2db72cce88f(this, this, a);
        return this.check();
    }
    rotateX(radians) {
        $46ec5f9ed0e75076$export$a59c8716592e09af(this, this, radians);
        return this.check();
    }
    rotateY(radians) {
        $46ec5f9ed0e75076$export$cf71e4d4ca4d1cfd(this, this, radians);
        return this.check();
    }
    rotateZ(radians) {
        $46ec5f9ed0e75076$export$ea6eae3365de5b9c(this, this, radians);
        return this.check();
    }
    rotateXYZ(angleXYZ) {
        return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
    }
    rotateAxis(radians, axis) {
        $46ec5f9ed0e75076$export$bb628a54ab399bc9(this, this, radians, axis);
        return this.check();
    }
    scale(factor) {
        $46ec5f9ed0e75076$export$dcdf75081b88279d(this, this, Array.isArray(factor) ? factor : [
            factor,
            factor,
            factor
        ]);
        return this.check();
    }
    translate(vector) {
        $46ec5f9ed0e75076$export$d73ee8ef04f5226a(this, this, vector);
        return this.check();
    }
    transform(vector, result) {
        if (vector.length === 4) {
            result = $bd1e837fe7e33410$export$5ffbd13800309d59(result || [
                -0,
                -0,
                -0,
                -0
            ], vector, this);
            (0, $c362065f7b29175e$export$3eb62eb6ef90f888)(result, 4);
            return result;
        }
        return this.transformAsPoint(vector, result);
    }
    transformAsPoint(vector, result) {
        const { length: length  } = vector;
        let out;
        switch(length){
            case 2:
                out = $fceb3370258170b6$export$5ffbd13800309d59(result || [
                    -0,
                    -0
                ], vector, this);
                break;
            case 3:
                out = $68948bc2139893c7$export$5ffbd13800309d59(result || [
                    -0,
                    -0,
                    -0
                ], vector, this);
                break;
            default:
                throw new Error("Illegal vector");
        }
        (0, $c362065f7b29175e$export$3eb62eb6ef90f888)(out, vector.length);
        return out;
    }
    transformAsVector(vector, result) {
        let out;
        switch(vector.length){
            case 2:
                out = (0, $04a7f04ce3522ae0$export$9c22d6d462b57a6c)(result || [
                    -0,
                    -0
                ], vector, this);
                break;
            case 3:
                out = (0, $04a7f04ce3522ae0$export$df62a5cc0f49271)(result || [
                    -0,
                    -0,
                    -0
                ], vector, this);
                break;
            default:
                throw new Error("Illegal vector");
        }
        (0, $c362065f7b29175e$export$3eb62eb6ef90f888)(out, vector.length);
        return out;
    }
    transformPoint(vector, result) {
        return this.transformAsPoint(vector, result);
    }
    transformVector(vector, result) {
        return this.transformAsPoint(vector, result);
    }
    transformDirection(vector, result) {
        return this.transformAsVector(vector, result);
    }
    makeRotationX(radians) {
        return this.identity().rotateX(radians);
    }
    makeTranslation(x, y, z) {
        return this.identity().translate([
            x,
            y,
            z
        ]);
    }
}
let $16800f0dff513c4e$var$ZERO;
let $16800f0dff513c4e$var$IDENTITY;
function $16800f0dff513c4e$var$getZeroMatrix() {
    if (!$16800f0dff513c4e$var$ZERO) {
        $16800f0dff513c4e$var$ZERO = new $16800f0dff513c4e$export$2e2bcd8739ae039([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]);
        Object.freeze($16800f0dff513c4e$var$ZERO);
    }
    return $16800f0dff513c4e$var$ZERO;
}
function $16800f0dff513c4e$var$getIdentityMatrix() {
    if (!$16800f0dff513c4e$var$IDENTITY) {
        $16800f0dff513c4e$var$IDENTITY = new $16800f0dff513c4e$export$2e2bcd8739ae039();
        Object.freeze($16800f0dff513c4e$var$IDENTITY);
    }
    return $16800f0dff513c4e$var$IDENTITY;
}
function $16800f0dff513c4e$var$checkRadians(possiblyDegrees) {
    if (possiblyDegrees > Math.PI * 2) throw Error("expected radians");
}
function $16800f0dff513c4e$var$computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
    const column0Row0 = 2 * near / (right - left);
    const column1Row1 = 2 * near / (top - bottom);
    const column2Row0 = (right + left) / (right - left);
    const column2Row1 = (top + bottom) / (top - bottom);
    const column2Row2 = -1;
    const column2Row3 = -1;
    const column3Row2 = -2 * near;
    result[0] = column0Row0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = column1Row1;
    result[6] = 0;
    result[7] = 0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0;
    result[13] = 0;
    result[14] = column3Row2;
    result[15] = 0;
    return result;
}



function $97790275b37bd567$export$1a9a28cade4dcdc4() {
    return [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ];
}
function $97790275b37bd567$export$842a2cf37af977e1(value, divisor) {
    const modulus = value % divisor;
    return modulus < 0 ? divisor + modulus : modulus;
}
function $97790275b37bd567$export$f411fdc3e02e158b(viewMatrixInverse) {
    return [
        viewMatrixInverse[12],
        viewMatrixInverse[13],
        viewMatrixInverse[14]
    ];
}
function $97790275b37bd567$export$7fd6193a8fe6de4e(viewProjectionMatrix) {
    return {
        left: $97790275b37bd567$var$getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]),
        right: $97790275b37bd567$var$getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]),
        bottom: $97790275b37bd567$var$getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]),
        top: $97790275b37bd567$var$getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]),
        near: $97790275b37bd567$var$getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]),
        far: $97790275b37bd567$var$getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14])
    };
}
const $97790275b37bd567$var$scratchVector = new (0, $9c6695c39a874609$export$2e2bcd8739ae039)();
function $97790275b37bd567$var$getFrustumPlane(a, b, c, d) {
    $97790275b37bd567$var$scratchVector.set(a, b, c);
    const L = $97790275b37bd567$var$scratchVector.len();
    return {
        distance: d / L,
        normal: new (0, $9c6695c39a874609$export$2e2bcd8739ae039)(-a / L, -b / L, -c / L)
    };
}
function $97790275b37bd567$export$4e5285c56a99f06d(x) {
    return x - Math.fround(x);
}
let $97790275b37bd567$var$scratchArray;
function $97790275b37bd567$export$550bd089be4eedcb(typedArray, options) {
    const { size: size = 1 , startIndex: startIndex = 0  } = options;
    const endIndex = options.endIndex !== undefined ? options.endIndex : typedArray.length;
    const count = (endIndex - startIndex) / size;
    $97790275b37bd567$var$scratchArray = (0, $e0cd51e92519f55c$export$2e2bcd8739ae039).allocate($97790275b37bd567$var$scratchArray, count, {
        type: Float32Array,
        size: size * 2
    });
    let sourceIndex = startIndex;
    let targetIndex = 0;
    while(sourceIndex < endIndex){
        for(let j = 0; j < size; j++){
            const value = typedArray[sourceIndex++];
            $97790275b37bd567$var$scratchArray[targetIndex + j] = value;
            $97790275b37bd567$var$scratchArray[targetIndex + j + size] = $97790275b37bd567$export$4e5285c56a99f06d(value);
        }
        targetIndex += size * 2;
    }
    return $97790275b37bd567$var$scratchArray.subarray(0, count * size * 2);
}






function $8ff31ed396c58e4f$export$1a9a28cade4dcdc4() {
    return [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ];
}
function $8ff31ed396c58e4f$export$8248199402822036(matrix, vector) {
    const result = (0, $bd1e837fe7e33410$export$5ffbd13800309d59)([], vector, matrix);
    (0, $bd1e837fe7e33410$export$dcdf75081b88279d)(result, result, 1 / result[3]);
    return result;
}
function $8ff31ed396c58e4f$export$842a2cf37af977e1(value, divisor) {
    const modulus = value % divisor;
    return modulus < 0 ? divisor + modulus : modulus;
}
function $8ff31ed396c58e4f$export$3a89f8d6f6bf6c9f(start, end, step) {
    return step * end + (1 - step) * start;
}
function $8ff31ed396c58e4f$export$7d15b64cf5a3a4c4(x, min, max) {
    return x < min ? min : x > max ? max : x;
}
function $8ff31ed396c58e4f$var$ieLog2(x) {
    return Math.log(x) * Math.LOG2E;
}
const $8ff31ed396c58e4f$export$b9fae0bba9d9094d = Math.log2 || $8ff31ed396c58e4f$var$ieLog2;






function $b721105c5eaabf93$export$2e2bcd8739ae039(condition, message) {
    if (!condition) throw new Error(message || "@math.gl/web-mercator: assertion failed.");
}


const $f5ef504cb5091e21$var$PI = Math.PI;
const $f5ef504cb5091e21$var$PI_4 = $f5ef504cb5091e21$var$PI / 4;
const $f5ef504cb5091e21$var$DEGREES_TO_RADIANS = $f5ef504cb5091e21$var$PI / 180;
const $f5ef504cb5091e21$var$RADIANS_TO_DEGREES = 180 / $f5ef504cb5091e21$var$PI;
const $f5ef504cb5091e21$var$TILE_SIZE = 512;
const $f5ef504cb5091e21$var$EARTH_CIRCUMFERENCE = 40.03e6;
const $f5ef504cb5091e21$export$6872bd9851469b83 = 85.051129;
const $f5ef504cb5091e21$export$c10d0dffa5af045 = 1.5;
function $f5ef504cb5091e21$export$eda81de7742ad8e7(zoom) {
    return Math.pow(2, zoom);
}
function $f5ef504cb5091e21$export$6e08c044660f3e30(scale) {
    return (0, $8ff31ed396c58e4f$export$b9fae0bba9d9094d)(scale);
}
function $f5ef504cb5091e21$export$4a0e8ea52607cc9b(lngLat) {
    const [lng, lat] = lngLat;
    (0, $b721105c5eaabf93$export$2e2bcd8739ae039)(Number.isFinite(lng));
    (0, $b721105c5eaabf93$export$2e2bcd8739ae039)(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
    const lambda2 = lng * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS;
    const phi2 = lat * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS;
    const x = $f5ef504cb5091e21$var$TILE_SIZE * (lambda2 + $f5ef504cb5091e21$var$PI) / (2 * $f5ef504cb5091e21$var$PI);
    const y = $f5ef504cb5091e21$var$TILE_SIZE * ($f5ef504cb5091e21$var$PI + Math.log(Math.tan($f5ef504cb5091e21$var$PI_4 + phi2 * 0.5))) / (2 * $f5ef504cb5091e21$var$PI);
    return [
        x,
        y
    ];
}
function $f5ef504cb5091e21$export$66ee0abd8a6a9660(xy) {
    const [x, y] = xy;
    const lambda2 = x / $f5ef504cb5091e21$var$TILE_SIZE * (2 * $f5ef504cb5091e21$var$PI) - $f5ef504cb5091e21$var$PI;
    const phi2 = 2 * (Math.atan(Math.exp(y / $f5ef504cb5091e21$var$TILE_SIZE * (2 * $f5ef504cb5091e21$var$PI) - $f5ef504cb5091e21$var$PI)) - $f5ef504cb5091e21$var$PI_4);
    return [
        lambda2 * $f5ef504cb5091e21$var$RADIANS_TO_DEGREES,
        phi2 * $f5ef504cb5091e21$var$RADIANS_TO_DEGREES
    ];
}
function $f5ef504cb5091e21$export$f4aaab1d865abddd(options) {
    const { latitude: latitude  } = options;
    (0, $b721105c5eaabf93$export$2e2bcd8739ae039)(Number.isFinite(latitude));
    const latCosine = Math.cos(latitude * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS);
    return $f5ef504cb5091e21$export$6e08c044660f3e30($f5ef504cb5091e21$var$EARTH_CIRCUMFERENCE * latCosine) - 9;
}
function $f5ef504cb5091e21$export$de3bf8f403bfc548(latitude) {
    const latCosine = Math.cos(latitude * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS);
    return $f5ef504cb5091e21$var$TILE_SIZE / $f5ef504cb5091e21$var$EARTH_CIRCUMFERENCE / latCosine;
}
function $f5ef504cb5091e21$export$14a522c4e7772100(options) {
    const { latitude: latitude , longitude: longitude , highPrecision: highPrecision = false  } = options;
    (0, $b721105c5eaabf93$export$2e2bcd8739ae039)(Number.isFinite(latitude) && Number.isFinite(longitude));
    const worldSize = $f5ef504cb5091e21$var$TILE_SIZE;
    const latCosine = Math.cos(latitude * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS);
    const unitsPerDegreeX = worldSize / 360;
    const unitsPerDegreeY = unitsPerDegreeX / latCosine;
    const altUnitsPerMeter = worldSize / $f5ef504cb5091e21$var$EARTH_CIRCUMFERENCE / latCosine;
    const result = {
        unitsPerMeter: [
            altUnitsPerMeter,
            altUnitsPerMeter,
            altUnitsPerMeter
        ],
        metersPerUnit: [
            1 / altUnitsPerMeter,
            1 / altUnitsPerMeter,
            1 / altUnitsPerMeter
        ],
        unitsPerDegree: [
            unitsPerDegreeX,
            unitsPerDegreeY,
            altUnitsPerMeter
        ],
        degreesPerUnit: [
            1 / unitsPerDegreeX,
            1 / unitsPerDegreeY,
            1 / altUnitsPerMeter
        ]
    };
    if (highPrecision) {
        const latCosine2 = $f5ef504cb5091e21$var$DEGREES_TO_RADIANS * Math.tan(latitude * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS) / latCosine;
        const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
        const altUnitsPerDegree2 = worldSize / $f5ef504cb5091e21$var$EARTH_CIRCUMFERENCE * latCosine2;
        const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
        result.unitsPerDegree2 = [
            0,
            unitsPerDegreeY2,
            altUnitsPerDegree2
        ];
        result.unitsPerMeter2 = [
            altUnitsPerMeter2,
            0,
            altUnitsPerMeter2
        ];
    }
    return result;
}
function $f5ef504cb5091e21$export$86ab4399faf187a8(lngLatZ, xyz) {
    const [longitude, latitude, z0] = lngLatZ;
    const [x, y, z] = xyz;
    const { unitsPerMeter: unitsPerMeter1 , unitsPerMeter2: unitsPerMeter2  } = $f5ef504cb5091e21$export$14a522c4e7772100({
        longitude: longitude,
        latitude: latitude,
        highPrecision: true
    });
    const worldspace = $f5ef504cb5091e21$export$4a0e8ea52607cc9b(lngLatZ);
    worldspace[0] += x * (unitsPerMeter1[0] + unitsPerMeter2[0] * y);
    worldspace[1] += y * (unitsPerMeter1[1] + unitsPerMeter2[1] * y);
    const newLngLat = $f5ef504cb5091e21$export$66ee0abd8a6a9660(worldspace);
    const newZ = (z0 || 0) + (z || 0);
    return Number.isFinite(z0) || Number.isFinite(z) ? [
        newLngLat[0],
        newLngLat[1],
        newZ
    ] : newLngLat;
}
function $f5ef504cb5091e21$export$a4dee078b9284944(options) {
    const { height: height , pitch: pitch , bearing: bearing , altitude: altitude , scale: scale , center: center  } = options;
    const vm = (0, $8ff31ed396c58e4f$export$1a9a28cade4dcdc4)();
    $46ec5f9ed0e75076$export$d73ee8ef04f5226a(vm, vm, [
        0,
        0,
        -altitude
    ]);
    $46ec5f9ed0e75076$export$a59c8716592e09af(vm, vm, -pitch * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS);
    $46ec5f9ed0e75076$export$ea6eae3365de5b9c(vm, vm, bearing * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS);
    const relativeScale = scale / height;
    $46ec5f9ed0e75076$export$dcdf75081b88279d(vm, vm, [
        relativeScale,
        relativeScale,
        relativeScale
    ]);
    if (center) $46ec5f9ed0e75076$export$d73ee8ef04f5226a(vm, vm, $68948bc2139893c7$export$aef51622e549b8b0([], center));
    return vm;
}
function $f5ef504cb5091e21$export$3debb7b92b597428(options) {
    const { width: width , height: height , altitude: altitude , pitch: pitch = 0 , offset: offset , center: center , scale: scale , nearZMultiplier: nearZMultiplier = 1 , farZMultiplier: farZMultiplier = 1  } = options;
    let { fovy: fovy = $f5ef504cb5091e21$export$4b02e2005c3c5cc($f5ef504cb5091e21$export$c10d0dffa5af045)  } = options;
    if (altitude !== undefined) fovy = $f5ef504cb5091e21$export$4b02e2005c3c5cc(altitude);
    const fovRadians = fovy * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS;
    const pitchRadians = pitch * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS;
    const focalDistance = $f5ef504cb5091e21$export$2e0715d5da7e224d(fovy);
    let cameraToSeaLevelDistance = focalDistance;
    if (center) cameraToSeaLevelDistance += center[2] * scale / Math.cos(pitchRadians) / height;
    const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);
    const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin((0, $8ff31ed396c58e4f$export$7d15b64cf5a3a4c4)(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));
    const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;
    const horizonDistance = cameraToSeaLevelDistance * 10;
    const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);
    return {
        fov: fovRadians,
        aspect: width / height,
        focalDistance: focalDistance,
        near: nearZMultiplier,
        far: farZ
    };
}
function $f5ef504cb5091e21$export$1d64991cd669ebf9(options) {
    const { fov: fov , aspect: aspect , near: near , far: far  } = $f5ef504cb5091e21$export$3debb7b92b597428(options);
    const projectionMatrix = $46ec5f9ed0e75076$export$541149539f3a4684([], fov, aspect, near, far);
    return projectionMatrix;
}
function $f5ef504cb5091e21$export$4b02e2005c3c5cc(altitude) {
    return 2 * Math.atan(0.5 / altitude) * $f5ef504cb5091e21$var$RADIANS_TO_DEGREES;
}
function $f5ef504cb5091e21$export$2e0715d5da7e224d(fovy) {
    return 0.5 / Math.tan(0.5 * fovy * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS);
}
function $f5ef504cb5091e21$export$46d0dd92e8f9a0db(xyz, pixelProjectionMatrix) {
    const [x, y, z = 0] = xyz;
    (0, $b721105c5eaabf93$export$2e2bcd8739ae039)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));
    return (0, $8ff31ed396c58e4f$export$8248199402822036)(pixelProjectionMatrix, [
        x,
        y,
        z,
        1
    ]);
}
function $f5ef504cb5091e21$export$d0eff18eb06add5f(xyz, pixelUnprojectionMatrix, targetZ = 0) {
    const [x, y, z] = xyz;
    (0, $b721105c5eaabf93$export$2e2bcd8739ae039)(Number.isFinite(x) && Number.isFinite(y), "invalid pixel coordinate");
    if (Number.isFinite(z)) {
        const coord = (0, $8ff31ed396c58e4f$export$8248199402822036)(pixelUnprojectionMatrix, [
            x,
            y,
            z,
            1
        ]);
        return coord;
    }
    const coord0 = (0, $8ff31ed396c58e4f$export$8248199402822036)(pixelUnprojectionMatrix, [
        x,
        y,
        0,
        1
    ]);
    const coord1 = (0, $8ff31ed396c58e4f$export$8248199402822036)(pixelUnprojectionMatrix, [
        x,
        y,
        1,
        1
    ]);
    const z0 = coord0[2];
    const z1 = coord1[2];
    const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
    return $fceb3370258170b6$export$3a89f8d6f6bf6c9f([], coord0, coord1, t);
}





function $7401923064b435ee$export$2e2bcd8739ae039(options) {
    const { width: width , height: height , bounds: bounds , minExtent: minExtent = 0 , maxZoom: maxZoom = 24 , offset: offset = [
        0,
        0
    ]  } = options;
    const [[west, south], [east, north]] = bounds;
    const padding = $7401923064b435ee$var$getPaddingObject(options.padding);
    const nw = (0, $f5ef504cb5091e21$export$4a0e8ea52607cc9b)([
        west,
        (0, $8ff31ed396c58e4f$export$7d15b64cf5a3a4c4)(north, -(0, $f5ef504cb5091e21$export$6872bd9851469b83), (0, $f5ef504cb5091e21$export$6872bd9851469b83))
    ]);
    const se = (0, $f5ef504cb5091e21$export$4a0e8ea52607cc9b)([
        east,
        (0, $8ff31ed396c58e4f$export$7d15b64cf5a3a4c4)(south, -(0, $f5ef504cb5091e21$export$6872bd9851469b83), (0, $f5ef504cb5091e21$export$6872bd9851469b83))
    ]);
    const size = [
        Math.max(Math.abs(se[0] - nw[0]), minExtent),
        Math.max(Math.abs(se[1] - nw[1]), minExtent)
    ];
    const targetSize = [
        width - padding.left - padding.right - Math.abs(offset[0]) * 2,
        height - padding.top - padding.bottom - Math.abs(offset[1]) * 2
    ];
    (0, $b721105c5eaabf93$export$2e2bcd8739ae039)(targetSize[0] > 0 && targetSize[1] > 0);
    const scaleX = targetSize[0] / size[0];
    const scaleY = targetSize[1] / size[1];
    const offsetX = (padding.right - padding.left) / 2 / scaleX;
    const offsetY = (padding.bottom - padding.top) / 2 / scaleY;
    const center = [
        (se[0] + nw[0]) / 2 + offsetX,
        (se[1] + nw[1]) / 2 + offsetY
    ];
    const centerLngLat = (0, $f5ef504cb5091e21$export$66ee0abd8a6a9660)(center);
    const zoom = Math.min(maxZoom, (0, $8ff31ed396c58e4f$export$b9fae0bba9d9094d)(Math.abs(Math.min(scaleX, scaleY))));
    (0, $b721105c5eaabf93$export$2e2bcd8739ae039)(Number.isFinite(zoom));
    return {
        longitude: centerLngLat[0],
        latitude: centerLngLat[1],
        zoom: zoom
    };
}
function $7401923064b435ee$var$getPaddingObject(padding = 0) {
    if (typeof padding === "number") return {
        top: padding,
        bottom: padding,
        left: padding,
        right: padding
    };
    (0, $b721105c5eaabf93$export$2e2bcd8739ae039)(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
    return padding;
}





const $0c06f6449ce0cec0$var$DEGREES_TO_RADIANS = Math.PI / 180;
function $0c06f6449ce0cec0$export$2e2bcd8739ae039(viewport, z = 0) {
    const { width: width , height: height , unproject: unproject  } = viewport;
    const unprojectOps = {
        targetZ: z
    };
    const bottomLeft = unproject([
        0,
        height
    ], unprojectOps);
    const bottomRight = unproject([
        width,
        height
    ], unprojectOps);
    let topLeft;
    let topRight;
    const halfFov = viewport.fovy ? 0.5 * viewport.fovy * $0c06f6449ce0cec0$var$DEGREES_TO_RADIANS : Math.atan(0.5 / viewport.altitude);
    const angleToGround = (90 - viewport.pitch) * $0c06f6449ce0cec0$var$DEGREES_TO_RADIANS;
    if (halfFov > angleToGround - 0.01) {
        topLeft = $0c06f6449ce0cec0$var$unprojectOnFarPlane(viewport, 0, z);
        topRight = $0c06f6449ce0cec0$var$unprojectOnFarPlane(viewport, width, z);
    } else {
        topLeft = unproject([
            0,
            0
        ], unprojectOps);
        topRight = unproject([
            width,
            0
        ], unprojectOps);
    }
    return [
        bottomLeft,
        bottomRight,
        topRight,
        topLeft
    ];
}
function $0c06f6449ce0cec0$var$unprojectOnFarPlane(viewport, x, targetZ) {
    const { pixelUnprojectionMatrix: pixelUnprojectionMatrix  } = viewport;
    const coord0 = (0, $8ff31ed396c58e4f$export$8248199402822036)(pixelUnprojectionMatrix, [
        x,
        0,
        1,
        1
    ]);
    const coord1 = (0, $8ff31ed396c58e4f$export$8248199402822036)(pixelUnprojectionMatrix, [
        x,
        viewport.height,
        1,
        1
    ]);
    const z = targetZ * viewport.distanceScales.unitsPerMeter[2];
    const t = (z - coord0[2]) / (coord1[2] - coord0[2]);
    const coord = $fceb3370258170b6$export$3a89f8d6f6bf6c9f([], coord0, coord1, t);
    const result = (0, $f5ef504cb5091e21$export$66ee0abd8a6a9660)(coord);
    result.push(targetZ);
    return result;
}





class $65aa3992a29fe1ce$export$2e2bcd8739ae039 {
    constructor(props = {
        width: 1,
        height: 1
    }){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "latitude", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "longitude", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "zoom", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pitch", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "bearing", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "altitude", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "fovy", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "meterOffset", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "center", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "width", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "height", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "scale", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "distanceScales", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "projectionMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewProjectionMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pixelProjectionMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pixelUnprojectionMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "equals", (viewport)=>{
            if (!(viewport instanceof $65aa3992a29fe1ce$export$2e2bcd8739ae039)) return false;
            return viewport.width === this.width && viewport.height === this.height && $46ec5f9ed0e75076$export$e9bab7fafb253603(viewport.projectionMatrix, this.projectionMatrix) && $46ec5f9ed0e75076$export$e9bab7fafb253603(viewport.viewMatrix, this.viewMatrix);
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "project", (lngLatZ, options = {})=>{
            const { topLeft: topLeft = true  } = options;
            const worldPosition = this.projectPosition(lngLatZ);
            const coord = (0, $f5ef504cb5091e21$export$46d0dd92e8f9a0db)(worldPosition, this.pixelProjectionMatrix);
            const [x, y] = coord;
            const y2 = topLeft ? y : this.height - y;
            return lngLatZ.length === 2 ? [
                x,
                y2
            ] : [
                x,
                y2,
                coord[2]
            ];
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "unproject", (xyz, options = {})=>{
            const { topLeft: topLeft = true , targetZ: targetZ  } = options;
            const [x, y, z] = xyz;
            const y2 = topLeft ? y : this.height - y;
            const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
            const coord = (0, $f5ef504cb5091e21$export$d0eff18eb06add5f)([
                x,
                y2,
                z
            ], this.pixelUnprojectionMatrix, targetZWorld);
            const [X, Y, Z] = this.unprojectPosition(coord);
            if (Number.isFinite(z)) return [
                X,
                Y,
                Z
            ];
            return Number.isFinite(targetZ) ? [
                X,
                Y,
                targetZ
            ] : [
                X,
                Y
            ];
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "projectPosition", (xyz)=>{
            const [X, Y] = (0, $f5ef504cb5091e21$export$4a0e8ea52607cc9b)(xyz);
            const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
            return [
                X,
                Y,
                Z
            ];
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "unprojectPosition", (xyz)=>{
            const [X, Y] = (0, $f5ef504cb5091e21$export$66ee0abd8a6a9660)(xyz);
            const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
            return [
                X,
                Y,
                Z
            ];
        });
        let { width: width , height: height , altitude: altitude = null , fovy: fovy = null  } = props;
        const { latitude: latitude = 0 , longitude: longitude = 0 , zoom: zoom = 0 , pitch: pitch = 0 , bearing: bearing = 0 , position: position = null , nearZMultiplier: nearZMultiplier = 0.02 , farZMultiplier: farZMultiplier = 1.01  } = props;
        width = width || 1;
        height = height || 1;
        if (fovy === null && altitude === null) {
            altitude = (0, $f5ef504cb5091e21$export$c10d0dffa5af045);
            fovy = (0, $f5ef504cb5091e21$export$4b02e2005c3c5cc)(altitude);
        } else if (fovy === null) fovy = (0, $f5ef504cb5091e21$export$4b02e2005c3c5cc)(altitude);
        else if (altitude === null) altitude = (0, $f5ef504cb5091e21$export$2e0715d5da7e224d)(fovy);
        const scale = (0, $f5ef504cb5091e21$export$eda81de7742ad8e7)(zoom);
        altitude = Math.max(0.75, altitude);
        const distanceScales = (0, $f5ef504cb5091e21$export$14a522c4e7772100)({
            longitude: longitude,
            latitude: latitude
        });
        const center = (0, $f5ef504cb5091e21$export$4a0e8ea52607cc9b)([
            longitude,
            latitude
        ]);
        center.push(0);
        if (position) $68948bc2139893c7$export$e16d8520af44a096(center, center, $68948bc2139893c7$export$6e3a27864ab166fe([], position, distanceScales.unitsPerMeter));
        this.projectionMatrix = (0, $f5ef504cb5091e21$export$1d64991cd669ebf9)({
            width: width,
            height: height,
            scale: scale,
            center: center,
            pitch: pitch,
            fovy: fovy,
            nearZMultiplier: nearZMultiplier,
            farZMultiplier: farZMultiplier
        });
        this.viewMatrix = (0, $f5ef504cb5091e21$export$a4dee078b9284944)({
            height: height,
            scale: scale,
            center: center,
            pitch: pitch,
            bearing: bearing,
            altitude: altitude
        });
        this.width = width;
        this.height = height;
        this.scale = scale;
        this.latitude = latitude;
        this.longitude = longitude;
        this.zoom = zoom;
        this.pitch = pitch;
        this.bearing = bearing;
        this.altitude = altitude;
        this.fovy = fovy;
        this.center = center;
        this.meterOffset = position || [
            0,
            0,
            0
        ];
        this.distanceScales = distanceScales;
        this._initMatrices();
        Object.freeze(this);
    }
    _initMatrices() {
        const { width: width , height: height , projectionMatrix: projectionMatrix , viewMatrix: viewMatrix  } = this;
        const vpm = (0, $8ff31ed396c58e4f$export$1a9a28cade4dcdc4)();
        $46ec5f9ed0e75076$export$2060d2db72cce88f(vpm, vpm, projectionMatrix);
        $46ec5f9ed0e75076$export$2060d2db72cce88f(vpm, vpm, viewMatrix);
        this.viewProjectionMatrix = vpm;
        const m = (0, $8ff31ed396c58e4f$export$1a9a28cade4dcdc4)();
        $46ec5f9ed0e75076$export$dcdf75081b88279d(m, m, [
            width / 2,
            -height / 2,
            1
        ]);
        $46ec5f9ed0e75076$export$d73ee8ef04f5226a(m, m, [
            1,
            -1,
            0
        ]);
        $46ec5f9ed0e75076$export$2060d2db72cce88f(m, m, vpm);
        const mInverse = $46ec5f9ed0e75076$export$6897c284b6f9f4dc((0, $8ff31ed396c58e4f$export$1a9a28cade4dcdc4)(), m);
        if (!mInverse) throw new Error("Pixel project matrix not invertible");
        this.pixelProjectionMatrix = m;
        this.pixelUnprojectionMatrix = mInverse;
    }
    projectFlat(lngLat) {
        return (0, $f5ef504cb5091e21$export$4a0e8ea52607cc9b)(lngLat);
    }
    unprojectFlat(xy) {
        return (0, $f5ef504cb5091e21$export$66ee0abd8a6a9660)(xy);
    }
    getMapCenterByLngLatPosition({ lngLat: lngLat , pos: pos  }) {
        const fromLocation = (0, $f5ef504cb5091e21$export$d0eff18eb06add5f)(pos, this.pixelUnprojectionMatrix);
        const toLocation = (0, $f5ef504cb5091e21$export$4a0e8ea52607cc9b)(lngLat);
        const translate = $fceb3370258170b6$export$e16d8520af44a096([], toLocation, $fceb3370258170b6$export$aef51622e549b8b0([], fromLocation));
        const newCenter = $fceb3370258170b6$export$e16d8520af44a096([], this.center, translate);
        return (0, $f5ef504cb5091e21$export$66ee0abd8a6a9660)(newCenter);
    }
    fitBounds(bounds, options = {}) {
        const { width: width , height: height  } = this;
        const { longitude: longitude , latitude: latitude , zoom: zoom  } = (0, $7401923064b435ee$export$2e2bcd8739ae039)(Object.assign({
            width: width,
            height: height,
            bounds: bounds
        }, options));
        return new $65aa3992a29fe1ce$export$2e2bcd8739ae039({
            width: width,
            height: height,
            longitude: longitude,
            latitude: latitude,
            zoom: zoom
        });
    }
    getBounds(options) {
        const corners = this.getBoundingRegion(options);
        const west = Math.min(...corners.map((p)=>p[0]));
        const east = Math.max(...corners.map((p)=>p[0]));
        const south = Math.min(...corners.map((p)=>p[1]));
        const north = Math.max(...corners.map((p)=>p[1]));
        return [
            [
                west,
                south
            ],
            [
                east,
                north
            ]
        ];
    }
    getBoundingRegion(options = {}) {
        return (0, $0c06f6449ce0cec0$export$2e2bcd8739ae039)(this, options.z || 0);
    }
    getLocationAtPoint({ lngLat: lngLat , pos: pos  }) {
        return this.getMapCenterByLngLatPosition({
            lngLat: lngLat,
            pos: pos
        });
    }
}







const $a727f0775314f814$var$TILE_SIZE = 512;
function $a727f0775314f814$export$2e2bcd8739ae039(props) {
    const { width: width , height: height , pitch: pitch = 0  } = props;
    let { longitude: longitude , latitude: latitude , zoom: zoom , bearing: bearing = 0  } = props;
    if (longitude < -180 || longitude > 180) longitude = (0, $8ff31ed396c58e4f$export$842a2cf37af977e1)(longitude + 180, 360) - 180;
    if (bearing < -180 || bearing > 180) bearing = (0, $8ff31ed396c58e4f$export$842a2cf37af977e1)(bearing + 180, 360) - 180;
    const minZoom = (0, $8ff31ed396c58e4f$export$b9fae0bba9d9094d)(height / $a727f0775314f814$var$TILE_SIZE);
    if (zoom <= minZoom) {
        zoom = minZoom;
        latitude = 0;
    } else {
        const halfHeightPixels = height / 2 / Math.pow(2, zoom);
        const minLatitude = (0, $f5ef504cb5091e21$export$66ee0abd8a6a9660)([
            0,
            halfHeightPixels
        ])[1];
        if (latitude < minLatitude) latitude = minLatitude;
        else {
            const maxLatitude = (0, $f5ef504cb5091e21$export$66ee0abd8a6a9660)([
                0,
                $a727f0775314f814$var$TILE_SIZE - halfHeightPixels
            ])[1];
            if (latitude > maxLatitude) latitude = maxLatitude;
        }
    }
    return {
        width: width,
        height: height,
        longitude: longitude,
        latitude: latitude,
        zoom: zoom,
        pitch: pitch,
        bearing: bearing
    };
}





const $d660f234a938c540$var$EPSILON = 0.01;
const $d660f234a938c540$var$VIEWPORT_TRANSITION_PROPS = [
    "longitude",
    "latitude",
    "zoom"
];
const $d660f234a938c540$var$DEFAULT_OPTS = {
    curve: 1.414,
    speed: 1.2
};
function $d660f234a938c540$export$2e2bcd8739ae039(startProps, endProps, t, options) {
    const { startZoom: startZoom , startCenterXY: startCenterXY , uDelta: uDelta , w0: w0 , u1: u1 , S: S , rho: rho , rho2: rho2 , r0: r0  } = $d660f234a938c540$var$getFlyToTransitionParams(startProps, endProps, options);
    if (u1 < $d660f234a938c540$var$EPSILON) {
        const viewport = {};
        for (const key of $d660f234a938c540$var$VIEWPORT_TRANSITION_PROPS){
            const startValue = startProps[key];
            const endValue = endProps[key];
            viewport[key] = (0, $8ff31ed396c58e4f$export$3a89f8d6f6bf6c9f)(startValue, endValue, t);
        }
        return viewport;
    }
    const s = t * S;
    const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);
    const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;
    const scaleIncrement = 1 / w;
    const newZoom = startZoom + (0, $f5ef504cb5091e21$export$6e08c044660f3e30)(scaleIncrement);
    const newCenterWorld = $fceb3370258170b6$export$dcdf75081b88279d([], uDelta, u);
    $fceb3370258170b6$export$e16d8520af44a096(newCenterWorld, newCenterWorld, startCenterXY);
    const newCenter = (0, $f5ef504cb5091e21$export$66ee0abd8a6a9660)(newCenterWorld);
    return {
        longitude: newCenter[0],
        latitude: newCenter[1],
        zoom: newZoom
    };
}
function $d660f234a938c540$export$1d42c64f84307be3(startProps, endProps, options) {
    const opts = {
        ...$d660f234a938c540$var$DEFAULT_OPTS,
        ...options
    };
    const { screenSpeed: screenSpeed , speed: speed , maxDuration: maxDuration  } = opts;
    const { S: S , rho: rho  } = $d660f234a938c540$var$getFlyToTransitionParams(startProps, endProps, opts);
    const length = 1000 * S;
    let duration;
    if (Number.isFinite(screenSpeed)) duration = length / (screenSpeed / rho);
    else duration = length / speed;
    return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;
}
function $d660f234a938c540$var$getFlyToTransitionParams(startProps, endProps, opts) {
    opts = Object.assign({}, $d660f234a938c540$var$DEFAULT_OPTS, opts);
    const rho = opts.curve;
    const startZoom = startProps.zoom;
    const startCenter = [
        startProps.longitude,
        startProps.latitude
    ];
    const startScale = (0, $f5ef504cb5091e21$export$eda81de7742ad8e7)(startZoom);
    const endZoom = endProps.zoom;
    const endCenter = [
        endProps.longitude,
        endProps.latitude
    ];
    const scale = (0, $f5ef504cb5091e21$export$eda81de7742ad8e7)(endZoom - startZoom);
    const startCenterXY = (0, $f5ef504cb5091e21$export$4a0e8ea52607cc9b)(startCenter);
    const endCenterXY = (0, $f5ef504cb5091e21$export$4a0e8ea52607cc9b)(endCenter);
    const uDelta = $fceb3370258170b6$export$f93b5905241a7cca([], endCenterXY, startCenterXY);
    const w0 = Math.max(startProps.width, startProps.height);
    const w1 = w0 / scale;
    const u1 = $fceb3370258170b6$export$f24224f1c91d8156(uDelta) * startScale;
    const _u1 = Math.max(u1, $d660f234a938c540$var$EPSILON);
    const rho2 = rho * rho;
    const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);
    const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);
    const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
    const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    const S = (r1 - r0) / rho;
    return {
        startZoom: startZoom,
        startCenterXY: startCenterXY,
        uDelta: uDelta,
        w0: w0,
        u1: u1,
        S: S,
        rho: rho,
        rho2: rho2,
        r0: r0,
        r1: r1
    };
}






const $bdb7668fd52e659a$var$DEGREES_TO_RADIANS = Math.PI / 180;
const $bdb7668fd52e659a$var$IDENTITY = (0, $97790275b37bd567$export$1a9a28cade4dcdc4)();
const $bdb7668fd52e659a$var$ZERO_VECTOR = [
    0,
    0,
    0
];
const $bdb7668fd52e659a$var$DEFAULT_DISTANCE_SCALES = {
    unitsPerMeter: [
        1,
        1,
        1
    ],
    metersPerUnit: [
        1,
        1,
        1
    ]
};
function $bdb7668fd52e659a$var$createProjectionMatrix({ width: width , height: height , orthographic: orthographic , fovyRadians: fovyRadians , focalDistance: focalDistance , padding: padding , near: near , far: far  }) {
    const aspect = width / height;
    const matrix = orthographic ? new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)().orthographic({
        fovy: fovyRadians,
        aspect: aspect,
        focalDistance: focalDistance,
        near: near,
        far: far
    }) : new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)().perspective({
        fovy: fovyRadians,
        aspect: aspect,
        near: near,
        far: far
    });
    if (padding) {
        const { left: left = 0 , right: right = 0 , top: top = 0 , bottom: bottom = 0  } = padding;
        const offsetX = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)((left + width - right) / 2, 0, width) - width / 2;
        const offsetY = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)((top + height - bottom) / 2, 0, height) - height / 2;
        matrix[8] -= offsetX * 2 / width;
        matrix[9] += offsetY * 2 / height;
    }
    return matrix;
}
class $bdb7668fd52e659a$export$2e2bcd8739ae039 {
    constructor(opts = {}){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "x", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "y", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "width", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "height", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "isGeospatial", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "zoom", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "focalDistance", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "position", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "modelMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "distanceScales", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "scale", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "center", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "cameraPosition", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "projectionMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewMatrixUncentered", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewMatrixInverse", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewProjectionMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pixelProjectionMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pixelUnprojectionMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "resolution", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_frustumPlanes", {});
        this.id = opts.id || this.constructor.displayName || "viewport";
        this.x = opts.x || 0;
        this.y = opts.y || 0;
        this.width = opts.width || 1;
        this.height = opts.height || 1;
        this.zoom = opts.zoom || 0;
        this.distanceScales = opts.distanceScales || $bdb7668fd52e659a$var$DEFAULT_DISTANCE_SCALES;
        this.focalDistance = opts.focalDistance || 1;
        this.position = opts.position || $bdb7668fd52e659a$var$ZERO_VECTOR;
        this.modelMatrix = opts.modelMatrix || null;
        const { longitude: longitude , latitude: latitude  } = opts;
        this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
        this._initProps(opts);
        this._initMatrices(opts);
        this.equals = this.equals.bind(this);
        this.project = this.project.bind(this);
        this.unproject = this.unproject.bind(this);
        this.projectPosition = this.projectPosition.bind(this);
        this.unprojectPosition = this.unprojectPosition.bind(this);
        this.projectFlat = this.projectFlat.bind(this);
        this.unprojectFlat = this.unprojectFlat.bind(this);
    }
    get metersPerPixel() {
        return this.distanceScales.metersPerUnit[2] / this.scale;
    }
    get projectionMode() {
        if (this.isGeospatial) return this.zoom < 12 ? (0, $b42a5b9aa3b1a41f$export$3697aaebd269a548).WEB_MERCATOR : (0, $b42a5b9aa3b1a41f$export$3697aaebd269a548).WEB_MERCATOR_AUTO_OFFSET;
        return (0, $b42a5b9aa3b1a41f$export$3697aaebd269a548).IDENTITY;
    }
    equals(viewport) {
        if (!(viewport instanceof $bdb7668fd52e659a$export$2e2bcd8739ae039)) return false;
        if (this === viewport) return true;
        return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && (0, $53a37c44451cea56$export$e9bab7fafb253603)(viewport.projectionMatrix, this.projectionMatrix) && (0, $53a37c44451cea56$export$e9bab7fafb253603)(viewport.viewMatrix, this.viewMatrix);
    }
    project(xyz, { topLeft: topLeft = true  } = {}) {
        const worldPosition = this.projectPosition(xyz);
        const coord = (0, $f5ef504cb5091e21$export$46d0dd92e8f9a0db)(worldPosition, this.pixelProjectionMatrix);
        const [x, y] = coord;
        const y2 = topLeft ? y : this.height - y;
        return xyz.length === 2 ? [
            x,
            y2
        ] : [
            x,
            y2,
            coord[2]
        ];
    }
    unproject(xyz, { topLeft: topLeft = true , targetZ: targetZ  } = {}) {
        const [x, y, z] = xyz;
        const y2 = topLeft ? y : this.height - y;
        const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
        const coord = (0, $f5ef504cb5091e21$export$d0eff18eb06add5f)([
            x,
            y2,
            z
        ], this.pixelUnprojectionMatrix, targetZWorld);
        const [X, Y, Z] = this.unprojectPosition(coord);
        if (Number.isFinite(z)) return [
            X,
            Y,
            Z
        ];
        return Number.isFinite(targetZ) ? [
            X,
            Y,
            targetZ
        ] : [
            X,
            Y
        ];
    }
    projectPosition(xyz) {
        const [X, Y] = this.projectFlat(xyz);
        const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
        return [
            X,
            Y,
            Z
        ];
    }
    unprojectPosition(xyz) {
        const [X, Y] = this.unprojectFlat(xyz);
        const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
        return [
            X,
            Y,
            Z
        ];
    }
    projectFlat(xyz) {
        if (this.isGeospatial) {
            const result = (0, $f5ef504cb5091e21$export$4a0e8ea52607cc9b)(xyz);
            result[1] = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(result[1], -318, 830);
            return result;
        }
        return xyz;
    }
    unprojectFlat(xyz) {
        if (this.isGeospatial) return (0, $f5ef504cb5091e21$export$66ee0abd8a6a9660)(xyz);
        return xyz;
    }
    getBounds(options = {}) {
        const unprojectOption = {
            targetZ: options.z || 0
        };
        const topLeft = this.unproject([
            0,
            0
        ], unprojectOption);
        const topRight = this.unproject([
            this.width,
            0
        ], unprojectOption);
        const bottomLeft = this.unproject([
            0,
            this.height
        ], unprojectOption);
        const bottomRight = this.unproject([
            this.width,
            this.height
        ], unprojectOption);
        return [
            Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
            Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),
            Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
            Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])
        ];
    }
    getDistanceScales(coordinateOrigin) {
        if (coordinateOrigin) return (0, $f5ef504cb5091e21$export$14a522c4e7772100)({
            longitude: coordinateOrigin[0],
            latitude: coordinateOrigin[1],
            highPrecision: true
        });
        return this.distanceScales;
    }
    containsPixel({ x: x , y: y , width: width = 1 , height: height = 1  }) {
        return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;
    }
    getFrustumPlanes() {
        if (this._frustumPlanes.near) return this._frustumPlanes;
        Object.assign(this._frustumPlanes, (0, $97790275b37bd567$export$7fd6193a8fe6de4e)(this.viewProjectionMatrix));
        return this._frustumPlanes;
    }
    panByPosition(coords, pixel) {
        return null;
    }
    _initProps(opts) {
        const longitude = opts.longitude;
        const latitude = opts.latitude;
        if (this.isGeospatial) {
            if (!Number.isFinite(opts.zoom)) this.zoom = (0, $f5ef504cb5091e21$export$f4aaab1d865abddd)({
                latitude: latitude
            }) + Math.log2(this.focalDistance);
            this.distanceScales = opts.distanceScales || (0, $f5ef504cb5091e21$export$14a522c4e7772100)({
                latitude: latitude,
                longitude: longitude
            });
        }
        const scale = Math.pow(2, this.zoom);
        this.scale = scale;
        const { position: position , modelMatrix: modelMatrix  } = opts;
        let meterOffset = $bdb7668fd52e659a$var$ZERO_VECTOR;
        if (position) meterOffset = modelMatrix ? new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)(modelMatrix).transformAsVector(position, []) : position;
        if (this.isGeospatial) {
            const center = this.projectPosition([
                longitude,
                latitude,
                0
            ]);
            this.center = new (0, $9c6695c39a874609$export$2e2bcd8739ae039)(meterOffset).scale(this.distanceScales.unitsPerMeter).add(center);
        } else this.center = this.projectPosition(meterOffset);
    }
    _initMatrices(opts) {
        const { viewMatrix: viewMatrix = $bdb7668fd52e659a$var$IDENTITY , projectionMatrix: projectionMatrix = null , orthographic: orthographic = false , fovyRadians: fovyRadians , fovy: fovy = 75 , near: near = 0.1 , far: far = 1000 , padding: padding = null , focalDistance: focalDistance = 1  } = opts;
        this.viewMatrixUncentered = viewMatrix;
        this.viewMatrix = new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)().multiplyRight(viewMatrix).translate(new (0, $9c6695c39a874609$export$2e2bcd8739ae039)(this.center).negate());
        this.projectionMatrix = projectionMatrix || $bdb7668fd52e659a$var$createProjectionMatrix({
            width: this.width,
            height: this.height,
            orthographic: orthographic,
            fovyRadians: fovyRadians || fovy * $bdb7668fd52e659a$var$DEGREES_TO_RADIANS,
            focalDistance: focalDistance,
            padding: padding,
            near: near,
            far: far
        });
        const vpm = (0, $97790275b37bd567$export$1a9a28cade4dcdc4)();
        $46ec5f9ed0e75076$export$2060d2db72cce88f(vpm, vpm, this.projectionMatrix);
        $46ec5f9ed0e75076$export$2060d2db72cce88f(vpm, vpm, this.viewMatrix);
        this.viewProjectionMatrix = vpm;
        this.viewMatrixInverse = $46ec5f9ed0e75076$export$6897c284b6f9f4dc([], this.viewMatrix) || this.viewMatrix;
        this.cameraPosition = (0, $97790275b37bd567$export$f411fdc3e02e158b)(this.viewMatrixInverse);
        const viewportMatrix = (0, $97790275b37bd567$export$1a9a28cade4dcdc4)();
        const pixelProjectionMatrix = (0, $97790275b37bd567$export$1a9a28cade4dcdc4)();
        $46ec5f9ed0e75076$export$dcdf75081b88279d(viewportMatrix, viewportMatrix, [
            this.width / 2,
            -this.height / 2,
            1
        ]);
        $46ec5f9ed0e75076$export$d73ee8ef04f5226a(viewportMatrix, viewportMatrix, [
            1,
            -1,
            0
        ]);
        $46ec5f9ed0e75076$export$2060d2db72cce88f(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
        this.pixelProjectionMatrix = pixelProjectionMatrix;
        this.pixelUnprojectionMatrix = $46ec5f9ed0e75076$export$6897c284b6f9f4dc((0, $97790275b37bd567$export$1a9a28cade4dcdc4)(), this.pixelProjectionMatrix);
        if (!this.pixelUnprojectionMatrix) (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("Pixel project matrix not invertible")();
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($bdb7668fd52e659a$export$2e2bcd8739ae039, "displayName", "Viewport");



const $6a52b0a4ad5491f9$var$TRACE_SET_LAYERS = "layerManager.setLayers";
const $6a52b0a4ad5491f9$var$TRACE_ACTIVATE_VIEWPORT = "layerManager.activateViewport";
class $6a52b0a4ad5491f9$export$2e2bcd8739ae039 {
    constructor(gl, { deck: deck , stats: stats , viewport: _viewport , timeline: timeline  } = {}){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "layers", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "context", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "resourceManager", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_lastRenderedLayers", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_needsRedraw", false);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_needsUpdate", false);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_nextLayers", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_debug", false);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "activateViewport", (viewport)=>{
            (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($6a52b0a4ad5491f9$var$TRACE_ACTIVATE_VIEWPORT, this, viewport);
            if (viewport) this.context.viewport = viewport;
        });
        this.layers = [];
        this.resourceManager = new (0, $23cb722a95241d61$export$2e2bcd8739ae039)({
            gl: gl,
            protocol: "deck://"
        });
        this.context = {
            mousePosition: null,
            userData: {},
            layerManager: this,
            gl: gl,
            deck: deck,
            programManager: gl && (0, $c6e8420d48e336f1$export$249fec8be25f60d5)(gl),
            stats: stats || new (0, $2fb061cfbc5cb32d$export$2e2bcd8739ae039)({
                id: "deck.gl"
            }),
            viewport: _viewport || new (0, $bdb7668fd52e659a$export$2e2bcd8739ae039)({
                id: "DEFAULT-INITIAL-VIEWPORT"
            }),
            timeline: timeline || new (0, $bc7bc101e53b8e33$export$e6a97ba2cae5bb94)(),
            resourceManager: this.resourceManager,
            onError: undefined
        };
        Object.seal(this);
    }
    finalize() {
        this.resourceManager.finalize();
        for (const layer of this.layers)this._finalizeLayer(layer);
    }
    needsRedraw(opts = {
        clearRedrawFlags: false
    }) {
        let redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) this._needsRedraw = false;
        for (const layer of this.layers){
            const layerNeedsRedraw = layer.getNeedsRedraw(opts);
            redraw = redraw || layerNeedsRedraw;
        }
        return redraw;
    }
    needsUpdate() {
        if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) return "layers changed";
        return this._needsUpdate;
    }
    setNeedsRedraw(reason) {
        this._needsRedraw = this._needsRedraw || reason;
    }
    setNeedsUpdate(reason) {
        this._needsUpdate = this._needsUpdate || reason;
    }
    getLayers({ layerIds: layerIds  } = {}) {
        return layerIds ? this.layers.filter((layer)=>layerIds.find((layerId)=>layer.id.indexOf(layerId) === 0)) : this.layers;
    }
    setProps(props) {
        if ("debug" in props) this._debug = props.debug;
        if ("userData" in props) this.context.userData = props.userData;
        if ("layers" in props) this._nextLayers = props.layers;
        if ("onError" in props) this.context.onError = props.onError;
    }
    setLayers(newLayers, reason) {
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($6a52b0a4ad5491f9$var$TRACE_SET_LAYERS, this, reason, newLayers);
        this._lastRenderedLayers = newLayers;
        const flatLayers = (0, $755f3c37a143f46e$export$bffa455ba8c619a6)(newLayers, Boolean);
        for (const layer of flatLayers)layer.context = this.context;
        this._updateLayers(this.layers, flatLayers);
    }
    updateLayers() {
        const reason = this.needsUpdate();
        if (reason) {
            this.setNeedsRedraw("updating layers: ".concat(reason));
            this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);
        }
        this._nextLayers = null;
    }
    _handleError(stage, error, layer) {
        layer.raiseError(error, "".concat(stage, " of ").concat(layer));
    }
    _updateLayers(oldLayers, newLayers) {
        const oldLayerMap = {};
        for (const oldLayer of oldLayers)if (oldLayerMap[oldLayer.id]) (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("Multiple old layers with same id ".concat(oldLayer.id))();
        else oldLayerMap[oldLayer.id] = oldLayer;
        const generatedLayers = [];
        this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);
        this._finalizeOldLayers(oldLayerMap);
        let needsUpdate = false;
        for (const layer of generatedLayers)if (layer.hasUniformTransition()) {
            needsUpdate = "Uniform transition in ".concat(layer);
            break;
        }
        this._needsUpdate = needsUpdate;
        this.layers = generatedLayers;
    }
    _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {
        for (const newLayer of newLayers){
            newLayer.context = this.context;
            const oldLayer = oldLayerMap[newLayer.id];
            if (oldLayer === null) (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("Multiple new layers with same id ".concat(newLayer.id))();
            oldLayerMap[newLayer.id] = null;
            let sublayers = null;
            try {
                if (this._debug && oldLayer !== newLayer) newLayer.validateProps();
                if (!oldLayer) this._initializeLayer(newLayer);
                else {
                    this._transferLayerState(oldLayer, newLayer);
                    this._updateLayer(newLayer);
                }
                generatedLayers.push(newLayer);
                sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;
            } catch (err) {
                this._handleError("matching", err, newLayer);
            }
            if (sublayers) this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);
        }
    }
    _finalizeOldLayers(oldLayerMap) {
        for(const layerId in oldLayerMap){
            const layer = oldLayerMap[layerId];
            if (layer) this._finalizeLayer(layer);
        }
    }
    _initializeLayer(layer) {
        try {
            layer._initialize();
            layer.lifecycle = (0, $434611e3e90ee53e$export$2cb9787dd463cbf4).INITIALIZED;
        } catch (err) {
            this._handleError("initialization", err, layer);
        }
    }
    _transferLayerState(oldLayer, newLayer) {
        newLayer._transferState(oldLayer);
        newLayer.lifecycle = (0, $434611e3e90ee53e$export$2cb9787dd463cbf4).MATCHED;
        if (newLayer !== oldLayer) oldLayer.lifecycle = (0, $434611e3e90ee53e$export$2cb9787dd463cbf4).AWAITING_GC;
    }
    _updateLayer(layer) {
        try {
            layer._update();
        } catch (err) {
            this._handleError("update", err, layer);
        }
    }
    _finalizeLayer(layer) {
        this._needsRedraw = this._needsRedraw || "finalized ".concat(layer);
        layer.lifecycle = (0, $434611e3e90ee53e$export$2cb9787dd463cbf4).AWAITING_FINALIZATION;
        try {
            layer._finalize();
            layer.lifecycle = (0, $434611e3e90ee53e$export$2cb9787dd463cbf4).FINALIZED;
        } catch (err) {
            this._handleError("finalization", err, layer);
        }
    }
}



function $70a948cba88c73a3$export$9cb4719e2e525b7a(a, b) {
    if (a === b) return true;
    if (!a || !b) return false;
    for(const key in a){
        const aValue = a[key];
        const bValue = b[key];
        const equals = aValue === bValue || Array.isArray(aValue) && Array.isArray(bValue) && $70a948cba88c73a3$export$9cb4719e2e525b7a(aValue, bValue);
        if (!equals) return false;
    }
    return true;
}




class $12d396d6877d881f$export$2e2bcd8739ae039 {
    constructor(props){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "width", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "height", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "views", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewState", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "controllers", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "timeline", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_viewports", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_viewportMap", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_isUpdating", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_needsRedraw", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_needsUpdate", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_eventManager", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_eventCallbacks", void 0);
        this.views = [];
        this.width = 100;
        this.height = 100;
        this.viewState = {};
        this.controllers = {};
        this.timeline = props.timeline;
        this._viewports = [];
        this._viewportMap = {};
        this._isUpdating = false;
        this._needsRedraw = "First render";
        this._needsUpdate = "Initialize";
        this._eventManager = props.eventManager;
        this._eventCallbacks = {
            onViewStateChange: props.onViewStateChange,
            onInteractionStateChange: props.onInteractionStateChange
        };
        Object.seal(this);
        this.setProps(props);
    }
    finalize() {
        for(const key in this.controllers){
            const controller = this.controllers[key];
            if (controller) controller.finalize();
        }
        this.controllers = {};
    }
    needsRedraw(opts = {
        clearRedrawFlags: false
    }) {
        const redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) this._needsRedraw = false;
        return redraw;
    }
    setNeedsUpdate(reason) {
        this._needsUpdate = this._needsUpdate || reason;
        this._needsRedraw = this._needsRedraw || reason;
    }
    updateViewStates() {
        for(const viewId in this.controllers){
            const controller = this.controllers[viewId];
            if (controller) controller.updateTransition();
        }
    }
    getViewports(rect) {
        if (rect) return this._viewports.filter((viewport)=>viewport.containsPixel(rect));
        return this._viewports;
    }
    getViews() {
        const viewMap = {};
        this.views.forEach((view)=>{
            viewMap[view.id] = view;
        });
        return viewMap;
    }
    getView(viewId) {
        return this.views.find((view)=>view.id === viewId);
    }
    getViewState(viewOrViewId) {
        const view = typeof viewOrViewId === "string" ? this.getView(viewOrViewId) : viewOrViewId;
        const viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
        return view ? view.filterViewState(viewState) : viewState;
    }
    getViewport(viewId) {
        return this._viewportMap[viewId];
    }
    unproject(xyz, opts) {
        const viewports = this.getViewports();
        const pixel = {
            x: xyz[0],
            y: xyz[1]
        };
        for(let i = viewports.length - 1; i >= 0; --i){
            const viewport = viewports[i];
            if (viewport.containsPixel(pixel)) {
                const p = xyz.slice();
                p[0] -= viewport.x;
                p[1] -= viewport.y;
                return viewport.unproject(p, opts);
            }
        }
        return null;
    }
    setProps(props) {
        if (props.views) this._setViews(props.views);
        if (props.viewState) this._setViewState(props.viewState);
        if ("width" in props || "height" in props) this._setSize(props.width, props.height);
        if (!this._isUpdating) this._update();
    }
    _update() {
        this._isUpdating = true;
        if (this._needsUpdate) {
            this._needsUpdate = false;
            this._rebuildViewports();
        }
        if (this._needsUpdate) {
            this._needsUpdate = false;
            this._rebuildViewports();
        }
        this._isUpdating = false;
    }
    _setSize(width, height) {
        if (width !== this.width || height !== this.height) {
            this.width = width;
            this.height = height;
            this.setNeedsUpdate("Size changed");
        }
    }
    _setViews(views) {
        views = (0, $755f3c37a143f46e$export$bffa455ba8c619a6)(views, Boolean);
        const viewsChanged = this._diffViews(views, this.views);
        if (viewsChanged) this.setNeedsUpdate("views changed");
        this.views = views;
    }
    _setViewState(viewState) {
        if (viewState) {
            const viewStateChanged = !(0, $70a948cba88c73a3$export$9cb4719e2e525b7a)(viewState, this.viewState);
            if (viewStateChanged) this.setNeedsUpdate("viewState changed");
            this.viewState = viewState;
        } else (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("missing `viewState` or `initialViewState`")();
    }
    _onViewStateChange(viewId, event) {
        if (this._eventCallbacks.onViewStateChange) this._eventCallbacks.onViewStateChange({
            ...event,
            viewId: viewId
        });
    }
    _createController(view, props) {
        const Controller = props.type;
        const controller = new Controller({
            timeline: this.timeline,
            eventManager: this._eventManager,
            onViewStateChange: this._onViewStateChange.bind(this, props.id),
            onStateChange: this._eventCallbacks.onInteractionStateChange,
            makeViewport: (viewState)=>view.makeViewport({
                    viewState: viewState,
                    width: this.width,
                    height: this.height
                })
        });
        return controller;
    }
    _updateController(view, viewState, viewport, controller) {
        const controllerProps = view.controller;
        if (controllerProps) {
            const resolvedProps = {
                ...viewState,
                ...controllerProps,
                id: view.id,
                x: viewport.x,
                y: viewport.y,
                width: viewport.width,
                height: viewport.height
            };
            if (!controller) controller = this._createController(view, resolvedProps);
            if (controller) controller.setProps(resolvedProps);
            return controller;
        }
        return null;
    }
    _rebuildViewports() {
        const { views: views  } = this;
        const oldControllers = this.controllers;
        this._viewports = [];
        this.controllers = {};
        let invalidateControllers = false;
        for(let i = views.length; i--;){
            const view = views[i];
            const viewState = this.getViewState(view);
            const viewport = view.makeViewport({
                viewState: viewState,
                width: this.width,
                height: this.height
            });
            let oldController = oldControllers[view.id];
            const hasController = Boolean(view.controller);
            if (hasController && !oldController) invalidateControllers = true;
            if ((invalidateControllers || !hasController) && oldController) {
                oldController.finalize();
                oldController = null;
            }
            this.controllers[view.id] = this._updateController(view, viewState, viewport, oldController);
            this._viewports.unshift(viewport);
        }
        for(const id in oldControllers){
            const oldController = oldControllers[id];
            if (oldController && !this.controllers[id]) oldController.finalize();
        }
        this._buildViewportMap();
    }
    _buildViewportMap() {
        this._viewportMap = {};
        this._viewports.forEach((viewport)=>{
            if (viewport.id) this._viewportMap[viewport.id] = this._viewportMap[viewport.id] || viewport;
        });
    }
    _diffViews(newViews, oldViews) {
        if (newViews.length !== oldViews.length) return true;
        return newViews.some((_, i)=>!newViews[i].equals(oldViews[i]));
    }
}





const $13bad85ed5bba3fb$var$PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;
function $13bad85ed5bba3fb$export$16d1640ef8464a10(value) {
    switch(typeof value){
        case "number":
            return {
                position: value,
                relative: false
            };
        case "string":
            const match = $13bad85ed5bba3fb$var$PERCENT_OR_PIXELS_REGEX.exec(value);
            if (match && match.length >= 3) {
                const relative = match[2] === "%";
                const position = parseFloat(match[1]);
                return {
                    position: relative ? position / 100 : position,
                    relative: relative
                };
            }
        default:
            throw new Error("Could not parse position string ".concat(value));
    }
}
function $13bad85ed5bba3fb$export$1690e12b840569b9(position, extent) {
    return position.relative ? Math.round(position.position * extent) : position.position;
}



function $828c58095cddb61a$export$2e2bcd8739ae039(condition, message) {
    if (!condition) throw new Error(message || "deck.gl: assertion failed.");
}


class $f435da35b0feb027$export$2e2bcd8739ae039 {
    constructor(props){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewportInstance", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_x", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_y", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_width", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_height", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_padding", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", void 0);
        const { id: id , x: x = 0 , y: y = 0 , width: width = "100%" , height: height = "100%" , padding: padding = null , viewportInstance: viewportInstance  } = props || {};
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(!viewportInstance || viewportInstance instanceof (0, $bdb7668fd52e659a$export$2e2bcd8739ae039));
        this.viewportInstance = viewportInstance;
        this.id = id || this.constructor.displayName || "view";
        this.props = {
            ...props,
            id: this.id
        };
        this._x = (0, $13bad85ed5bba3fb$export$16d1640ef8464a10)(x);
        this._y = (0, $13bad85ed5bba3fb$export$16d1640ef8464a10)(y);
        this._width = (0, $13bad85ed5bba3fb$export$16d1640ef8464a10)(width);
        this._height = (0, $13bad85ed5bba3fb$export$16d1640ef8464a10)(height);
        this._padding = padding && {
            left: (0, $13bad85ed5bba3fb$export$16d1640ef8464a10)(padding.left || 0),
            right: (0, $13bad85ed5bba3fb$export$16d1640ef8464a10)(padding.right || 0),
            top: (0, $13bad85ed5bba3fb$export$16d1640ef8464a10)(padding.top || 0),
            bottom: (0, $13bad85ed5bba3fb$export$16d1640ef8464a10)(padding.bottom || 0)
        };
        this.equals = this.equals.bind(this);
        Object.seal(this);
    }
    equals(view) {
        if (this === view) return true;
        if (this.viewportInstance) return view.viewportInstance ? this.viewportInstance.equals(view.viewportInstance) : false;
        return this.ViewportType === view.ViewportType && (0, $70a948cba88c73a3$export$9cb4719e2e525b7a)(this.props, view.props);
    }
    makeViewport({ width: width , height: height , viewState: viewState  }) {
        if (this.viewportInstance) return this.viewportInstance;
        viewState = this.filterViewState(viewState);
        const viewportDimensions = this.getDimensions({
            width: width,
            height: height
        });
        return new this.ViewportType({
            ...viewState,
            ...this.props,
            ...viewportDimensions
        });
    }
    getViewStateId() {
        const { viewState: viewState  } = this.props;
        if (typeof viewState === "string") return viewState;
        return (viewState === null || viewState === void 0 ? void 0 : viewState.id) || this.id;
    }
    filterViewState(viewState) {
        if (this.props.viewState && typeof this.props.viewState === "object") {
            if (!this.props.viewState.id) return this.props.viewState;
            const newViewState = {
                ...viewState
            };
            for(const key in this.props.viewState)if (key !== "id") newViewState[key] = this.props.viewState[key];
            return newViewState;
        }
        return viewState;
    }
    getDimensions({ width: width , height: height  }) {
        const dimensions = {
            x: (0, $13bad85ed5bba3fb$export$1690e12b840569b9)(this._x, width),
            y: (0, $13bad85ed5bba3fb$export$1690e12b840569b9)(this._y, height),
            width: (0, $13bad85ed5bba3fb$export$1690e12b840569b9)(this._width, width),
            height: (0, $13bad85ed5bba3fb$export$1690e12b840569b9)(this._height, height)
        };
        if (this._padding) dimensions.padding = {
            left: (0, $13bad85ed5bba3fb$export$1690e12b840569b9)(this._padding.left, width),
            top: (0, $13bad85ed5bba3fb$export$1690e12b840569b9)(this._padding.top, height),
            right: (0, $13bad85ed5bba3fb$export$1690e12b840569b9)(this._padding.right, width),
            bottom: (0, $13bad85ed5bba3fb$export$1690e12b840569b9)(this._padding.bottom, height)
        };
        return dimensions;
    }
    get controller() {
        const opts = this.props.controller;
        if (!opts) return null;
        if (opts === true) return {
            type: this.ControllerType
        };
        if (typeof opts === "function") return {
            type: opts
        };
        return {
            type: this.ControllerType,
            ...opts
        };
    }
}







const $4ac7d89cb7f1c4ad$var$TILE_SIZE = 512;
const $4ac7d89cb7f1c4ad$var$EARTH_CIRCUMFERENCE = 40.03e6;
const $4ac7d89cb7f1c4ad$var$DEGREES_TO_RADIANS = Math.PI / 180;
function $4ac7d89cb7f1c4ad$var$unitsPerMeter(latitude) {
    const latCosine = Math.cos(latitude * $4ac7d89cb7f1c4ad$var$DEGREES_TO_RADIANS);
    return $4ac7d89cb7f1c4ad$var$TILE_SIZE / $4ac7d89cb7f1c4ad$var$EARTH_CIRCUMFERENCE / latCosine;
}
class $4ac7d89cb7f1c4ad$export$2e2bcd8739ae039 extends (0, $bdb7668fd52e659a$export$2e2bcd8739ae039) {
    constructor(opts = {}){
        const { latitude: latitude = 0 , longitude: longitude = 0 , zoom: zoom = 0 , pitch: pitch = 0 , bearing: bearing = 0 , nearZMultiplier: nearZMultiplier = 0.1 , farZMultiplier: farZMultiplier = 1.01 , orthographic: orthographic = false , projectionMatrix: projectionMatrix , repeat: repeat = false , worldOffset: worldOffset = 0 , legacyMeterSizes: legacyMeterSizes = false  } = opts;
        let { width: width , height: height , altitude: altitude = 1.5  } = opts;
        const scale = Math.pow(2, zoom);
        width = width || 1;
        height = height || 1;
        let fovy;
        let projectionParameters = null;
        if (projectionMatrix) {
            altitude = projectionMatrix[5] / 2;
            fovy = (0, $f5ef504cb5091e21$export$4b02e2005c3c5cc)(altitude);
        } else {
            if (opts.fovy) {
                fovy = opts.fovy;
                altitude = (0, $f5ef504cb5091e21$export$2e0715d5da7e224d)(fovy);
            } else fovy = (0, $f5ef504cb5091e21$export$4b02e2005c3c5cc)(altitude);
            projectionParameters = (0, $f5ef504cb5091e21$export$3debb7b92b597428)({
                width: width,
                height: height,
                pitch: pitch,
                fovy: fovy,
                nearZMultiplier: nearZMultiplier,
                farZMultiplier: farZMultiplier
            });
        }
        let viewMatrixUncentered = (0, $f5ef504cb5091e21$export$a4dee078b9284944)({
            height: height,
            pitch: pitch,
            bearing: bearing,
            scale: scale,
            altitude: altitude
        });
        if (worldOffset) {
            const viewOffset = new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)().translate([
                512 * worldOffset,
                0,
                0
            ]);
            viewMatrixUncentered = viewOffset.multiplyLeft(viewMatrixUncentered);
        }
        super({
            ...opts,
            width: width,
            height: height,
            viewMatrix: viewMatrixUncentered,
            longitude: longitude,
            latitude: latitude,
            zoom: zoom,
            ...projectionParameters,
            fovy: fovy,
            focalDistance: altitude
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "longitude", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "latitude", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pitch", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "bearing", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "altitude", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "fovy", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "orthographic", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_subViewports", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_pseudoMeters", void 0);
        this.latitude = latitude;
        this.longitude = longitude;
        this.zoom = zoom;
        this.pitch = pitch;
        this.bearing = bearing;
        this.altitude = altitude;
        this.fovy = fovy;
        this.orthographic = orthographic;
        this._subViewports = repeat ? [] : null;
        this._pseudoMeters = legacyMeterSizes;
        Object.freeze(this);
    }
    get subViewports() {
        if (this._subViewports && !this._subViewports.length) {
            const bounds = this.getBounds();
            const minOffset = Math.floor((bounds[0] + 180) / 360);
            const maxOffset = Math.ceil((bounds[2] - 180) / 360);
            for(let x = minOffset; x <= maxOffset; x++){
                const offsetViewport = x ? new $4ac7d89cb7f1c4ad$export$2e2bcd8739ae039({
                    ...this,
                    worldOffset: x
                }) : this;
                this._subViewports.push(offsetViewport);
            }
        }
        return this._subViewports;
    }
    projectPosition(xyz) {
        if (this._pseudoMeters) return super.projectPosition(xyz);
        const [X, Y] = this.projectFlat(xyz);
        const Z = (xyz[2] || 0) * $4ac7d89cb7f1c4ad$var$unitsPerMeter(xyz[1]);
        return [
            X,
            Y,
            Z
        ];
    }
    unprojectPosition(xyz) {
        if (this._pseudoMeters) return super.unprojectPosition(xyz);
        const [X, Y] = this.unprojectFlat(xyz);
        const Z = (xyz[2] || 0) / $4ac7d89cb7f1c4ad$var$unitsPerMeter(Y);
        return [
            X,
            Y,
            Z
        ];
    }
    addMetersToLngLat(lngLatZ, xyz) {
        return (0, $f5ef504cb5091e21$export$86ab4399faf187a8)(lngLatZ, xyz);
    }
    panByPosition(coords, pixel) {
        const fromLocation = (0, $f5ef504cb5091e21$export$d0eff18eb06add5f)(pixel, this.pixelUnprojectionMatrix);
        const toLocation = this.projectFlat(coords);
        const translate = $fceb3370258170b6$export$e16d8520af44a096([], toLocation, $fceb3370258170b6$export$aef51622e549b8b0([], fromLocation));
        const newCenter = $fceb3370258170b6$export$e16d8520af44a096([], this.center, translate);
        const [longitude, latitude] = this.unprojectFlat(newCenter);
        return {
            longitude: longitude,
            latitude: latitude
        };
    }
    getBounds(options = {}) {
        const corners = (0, $0c06f6449ce0cec0$export$2e2bcd8739ae039)(this, options.z || 0);
        return [
            Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]),
            Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]),
            Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]),
            Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])
        ];
    }
    fitBounds(bounds, options = {}) {
        const { width: width , height: height  } = this;
        const { longitude: longitude , latitude: latitude , zoom: zoom  } = (0, $7401923064b435ee$export$2e2bcd8739ae039)({
            width: width,
            height: height,
            bounds: bounds,
            ...options
        });
        return new $4ac7d89cb7f1c4ad$export$2e2bcd8739ae039({
            width: width,
            height: height,
            longitude: longitude,
            latitude: latitude,
            zoom: zoom
        });
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($4ac7d89cb7f1c4ad$export$2e2bcd8739ae039, "displayName", "WebMercatorViewport");







class $c302e779b9092c62$export$2e2bcd8739ae039 {
    constructor(timeline){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_inProgress", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_handle", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_timeline", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "time", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "settings", void 0);
        this._inProgress = false;
        this._handle = null;
        this._timeline = timeline;
        this.time = 0;
        this.settings = {
            duration: 0
        };
    }
    get inProgress() {
        return this._inProgress;
    }
    start(settings) {
        var _this$settings$onStar, _this$settings;
        this.cancel();
        this.settings = settings;
        this._inProgress = true;
        (_this$settings$onStar = (_this$settings = this.settings).onStart) === null || _this$settings$onStar === void 0 || _this$settings$onStar.call(_this$settings, this);
    }
    end() {
        if (this._inProgress) {
            var _this$settings$onEnd, _this$settings2;
            this._timeline.removeChannel(this._handle);
            this._handle = null;
            this._inProgress = false;
            (_this$settings$onEnd = (_this$settings2 = this.settings).onEnd) === null || _this$settings$onEnd === void 0 || _this$settings$onEnd.call(_this$settings2, this);
        }
    }
    cancel() {
        if (this._inProgress) {
            var _this$settings$onInte, _this$settings3;
            (_this$settings$onInte = (_this$settings3 = this.settings).onInterrupt) === null || _this$settings$onInte === void 0 || _this$settings$onInte.call(_this$settings3, this);
            this._timeline.removeChannel(this._handle);
            this._handle = null;
            this._inProgress = false;
        }
    }
    update() {
        var _this$settings$onUpda, _this$settings4;
        if (!this._inProgress) return false;
        if (this._handle === null) {
            const { _timeline: timeline , settings: settings  } = this;
            this._handle = timeline.addChannel({
                delay: timeline.getTime(),
                duration: settings.duration
            });
        }
        this.time = this._timeline.getTime(this._handle);
        this._onUpdate();
        (_this$settings$onUpda = (_this$settings4 = this.settings).onUpdate) === null || _this$settings$onUpda === void 0 || _this$settings$onUpda.call(_this$settings4, this);
        if (this._timeline.isFinished(this._handle)) this.end();
        return true;
    }
    _onUpdate() {}
}


const $0c98ca1748d9c859$var$noop = ()=>{};
const $0c98ca1748d9c859$export$71599bdd9f367e95 = {
    BREAK: 1,
    SNAP_TO_END: 2,
    IGNORE: 3
};
const $0c98ca1748d9c859$var$DEFAULT_EASING = (t)=>t;
const $0c98ca1748d9c859$var$DEFAULT_INTERRUPTION = $0c98ca1748d9c859$export$71599bdd9f367e95.BREAK;
class $0c98ca1748d9c859$export$2e2bcd8739ae039 {
    constructor(opts){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "getControllerState", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "propsInTransition", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transition", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "onViewStateChange", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "onStateChange", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_onTransitionUpdate", (transition)=>{
            const { time: time , settings: { interpolator: interpolator , startProps: startProps , endProps: endProps , duration: duration , easing: easing  }  } = transition;
            const t = easing(time / duration);
            const viewport = interpolator.interpolateProps(startProps, endProps, t);
            this.propsInTransition = this.getControllerState({
                ...this.props,
                ...viewport
            }).getViewportProps();
            this.onViewStateChange({
                viewState: this.propsInTransition,
                oldViewState: this.props
            });
        });
        this.getControllerState = opts.getControllerState;
        this.propsInTransition = null;
        this.transition = new (0, $c302e779b9092c62$export$2e2bcd8739ae039)(opts.timeline);
        this.onViewStateChange = opts.onViewStateChange || $0c98ca1748d9c859$var$noop;
        this.onStateChange = opts.onStateChange || $0c98ca1748d9c859$var$noop;
    }
    finalize() {
        this.transition.cancel();
    }
    getViewportInTransition() {
        return this.propsInTransition;
    }
    processViewStateChange(nextProps) {
        let transitionTriggered = false;
        const currentProps = this.props;
        this.props = nextProps;
        if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) return false;
        if (this._isTransitionEnabled(nextProps)) {
            let startProps = currentProps;
            if (this.transition.inProgress) {
                const { interruption: interruption , endProps: endProps  } = this.transition.settings;
                startProps = {
                    ...currentProps,
                    ...interruption === $0c98ca1748d9c859$export$71599bdd9f367e95.SNAP_TO_END ? endProps : this.propsInTransition || currentProps
                };
            }
            this._triggerTransition(startProps, nextProps);
            transitionTriggered = true;
        } else this.transition.cancel();
        return transitionTriggered;
    }
    updateTransition() {
        this.transition.update();
    }
    _isTransitionEnabled(props) {
        const { transitionDuration: transitionDuration , transitionInterpolator: transitionInterpolator  } = props;
        return (transitionDuration > 0 || transitionDuration === "auto") && Boolean(transitionInterpolator);
    }
    _isUpdateDueToCurrentTransition(props) {
        if (this.transition.inProgress && this.propsInTransition) return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);
        return false;
    }
    _shouldIgnoreViewportChange(currentProps, nextProps) {
        if (this.transition.inProgress) return this.transition.settings.interruption === $0c98ca1748d9c859$export$71599bdd9f367e95.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);
        if (this._isTransitionEnabled(nextProps)) return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
        return true;
    }
    _triggerTransition(startProps, endProps) {
        const startViewstate = this.getControllerState(startProps);
        const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);
        const transitionInterpolator = endProps.transitionInterpolator;
        const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;
        if (duration === 0) return;
        const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);
        this.propsInTransition = {};
        const transitionSettings = {
            duration: duration,
            easing: endProps.transitionEasing || $0c98ca1748d9c859$var$DEFAULT_EASING,
            interpolator: transitionInterpolator,
            interruption: endProps.transitionInterruption || $0c98ca1748d9c859$var$DEFAULT_INTERRUPTION,
            startProps: initialProps.start,
            endProps: initialProps.end,
            onStart: endProps.onTransitionStart,
            onUpdate: this._onTransitionUpdate,
            onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
            onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
        };
        this.transition.start(transitionSettings);
        this.onStateChange({
            inTransition: true
        });
        this.updateTransition();
    }
    _onTransitionEnd(callback) {
        return (transition)=>{
            this.propsInTransition = null;
            this.onStateChange({
                inTransition: false,
                isZooming: false,
                isPanning: false,
                isRotating: false
            });
            callback === null || callback === void 0 || callback(transition);
        };
    }
}






class $f6e2f9eab4b10c8b$export$2e2bcd8739ae039 {
    constructor(opts){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_propsToCompare", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_propsToExtract", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_requiredProps", void 0);
        const { compare: compare , extract: extract , required: required  } = opts;
        this._propsToCompare = compare;
        this._propsToExtract = extract || compare;
        this._requiredProps = required;
    }
    arePropsEqual(currentProps, nextProps) {
        for (const key of this._propsToCompare){
            if (!(key in currentProps) || !(key in nextProps) || !(0, $53a37c44451cea56$export$e9bab7fafb253603)(currentProps[key], nextProps[key])) return false;
        }
        return true;
    }
    initializeProps(startProps, endProps) {
        const startViewStateProps = {};
        const endViewStateProps = {};
        for (const key of this._propsToExtract)if (key in startProps || key in endProps) {
            startViewStateProps[key] = startProps[key];
            endViewStateProps[key] = endProps[key];
        }
        this._checkRequiredProps(startViewStateProps);
        this._checkRequiredProps(endViewStateProps);
        return {
            start: startViewStateProps,
            end: endViewStateProps
        };
    }
    getDuration(startProps, endProps) {
        return endProps.transitionDuration;
    }
    _checkRequiredProps(props) {
        if (!this._requiredProps) return;
        this._requiredProps.forEach((propName)=>{
            const value = props[propName];
            (0, $828c58095cddb61a$export$2e2bcd8739ae039)(Number.isFinite(value) || Array.isArray(value), "".concat(propName, " is required for transition"));
        });
    }
}



const $be3e6f41f904fd21$var$DEFAULT_PROPS = [
    "longitude",
    "latitude",
    "zoom",
    "bearing",
    "pitch"
];
const $be3e6f41f904fd21$var$DEFAULT_REQUIRED_PROPS = [
    "longitude",
    "latitude",
    "zoom"
];
class $be3e6f41f904fd21$export$2e2bcd8739ae039 extends (0, $f6e2f9eab4b10c8b$export$2e2bcd8739ae039) {
    constructor(opts = {}){
        const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;
        const normalizedOpts = Array.isArray(opts) ? {} : opts;
        normalizedOpts.transitionProps = Array.isArray(transitionProps) ? {
            compare: transitionProps,
            required: transitionProps
        } : transitionProps || {
            compare: $be3e6f41f904fd21$var$DEFAULT_PROPS,
            required: $be3e6f41f904fd21$var$DEFAULT_REQUIRED_PROPS
        };
        super(normalizedOpts.transitionProps);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "opts", void 0);
        this.opts = normalizedOpts;
    }
    initializeProps(startProps, endProps) {
        const result = super.initializeProps(startProps, endProps);
        const { makeViewport: makeViewport , around: around  } = this.opts;
        if (makeViewport && around) {
            const startViewport = makeViewport(startProps);
            const endViewport = makeViewport(endProps);
            const aroundPosition = startViewport.unproject(around);
            result.start.around = around;
            Object.assign(result.end, {
                around: endViewport.project(aroundPosition),
                aroundPosition: aroundPosition,
                width: endProps.width,
                height: endProps.height
            });
        }
        return result;
    }
    interpolateProps(startProps, endProps, t) {
        const propsInTransition = {};
        for (const key of this._propsToExtract)propsInTransition[key] = (0, $53a37c44451cea56$export$3a89f8d6f6bf6c9f)(startProps[key] || 0, endProps[key] || 0, t);
        if (endProps.aroundPosition && this.opts.makeViewport) {
            const viewport = this.opts.makeViewport({
                ...endProps,
                ...propsInTransition
            });
            Object.assign(propsInTransition, viewport.panByPosition(endProps.aroundPosition, (0, $53a37c44451cea56$export$3a89f8d6f6bf6c9f)(startProps.around, endProps.around, t)));
        }
        return propsInTransition;
    }
}


const $9a93059544335596$var$NO_TRANSITION_PROPS = {
    transitionDuration: 0
};
const $9a93059544335596$var$DEFAULT_INERTIA = 300;
const $9a93059544335596$var$INERTIA_EASING = (t)=>1 - (1 - t) * (1 - t);
const $9a93059544335596$var$EVENT_TYPES = {
    WHEEL: [
        "wheel"
    ],
    PAN: [
        "panstart",
        "panmove",
        "panend"
    ],
    PINCH: [
        "pinchstart",
        "pinchmove",
        "pinchend"
    ],
    TRIPLE_PAN: [
        "tripanstart",
        "tripanmove",
        "tripanend"
    ],
    DOUBLE_TAP: [
        "doubletap"
    ],
    KEYBOARD: [
        "keydown"
    ]
};
const $9a93059544335596$var$pinchEventWorkaround = {};
class $9a93059544335596$export$2e2bcd8739ae039 {
    constructor(opts){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "state", {});
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transitionManager", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "eventManager", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "onViewStateChange", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "onStateChange", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "makeViewport", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_controllerState", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_events", {});
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_interactionState", {
            isDragging: false
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_customEvents", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_eventStartBlocked", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_panMove", false);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "invertPan", false);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "dragMode", "rotate");
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "inertia", 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "scrollZoom", true);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "dragPan", true);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "dragRotate", true);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "doubleClickZoom", true);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "touchZoom", true);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "touchRotate", false);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "keyboard", true);
        this.transitionManager = new (0, $0c98ca1748d9c859$export$2e2bcd8739ae039)({
            ...opts,
            getControllerState: (props)=>new this.ControllerState(props),
            onViewStateChange: this._onTransition.bind(this),
            onStateChange: this._setInteractionState.bind(this)
        });
        this.handleEvent = this.handleEvent.bind(this);
        this.eventManager = opts.eventManager;
        this.onViewStateChange = opts.onViewStateChange || (()=>{});
        this.onStateChange = opts.onStateChange || (()=>{});
        this.makeViewport = opts.makeViewport;
    }
    set events(customEvents) {
        this.toggleEvents(this._customEvents, false);
        this.toggleEvents(customEvents, true);
        this._customEvents = customEvents;
        if (this.props) this.setProps(this.props);
    }
    finalize() {
        for(const eventName in this._events)if (this._events[eventName]) {
            var _this$eventManager;
            (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 || _this$eventManager.off(eventName, this.handleEvent);
        }
        this.transitionManager.finalize();
    }
    handleEvent(event) {
        this._controllerState = undefined;
        const eventStartBlocked = this._eventStartBlocked;
        switch(event.type){
            case "panstart":
                return eventStartBlocked ? false : this._onPanStart(event);
            case "panmove":
                return this._onPan(event);
            case "panend":
                return this._onPanEnd(event);
            case "pinchstart":
                return eventStartBlocked ? false : this._onPinchStart(event);
            case "pinchmove":
                return this._onPinch(event);
            case "pinchend":
                return this._onPinchEnd(event);
            case "tripanstart":
                return eventStartBlocked ? false : this._onTriplePanStart(event);
            case "tripanmove":
                return this._onTriplePan(event);
            case "tripanend":
                return this._onTriplePanEnd(event);
            case "doubletap":
                return this._onDoubleTap(event);
            case "wheel":
                return this._onWheel(event);
            case "keydown":
                return this._onKeyDown(event);
            default:
                return false;
        }
    }
    get controllerState() {
        this._controllerState = this._controllerState || new this.ControllerState({
            makeViewport: this.makeViewport,
            ...this.props,
            ...this.state
        });
        return this._controllerState;
    }
    getCenter(event) {
        const { x: x , y: y  } = this.props;
        const { offsetCenter: offsetCenter  } = event;
        return [
            offsetCenter.x - x,
            offsetCenter.y - y
        ];
    }
    isPointInBounds(pos, event) {
        const { width: width , height: height  } = this.props;
        if (event && event.handled) return false;
        const inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;
        if (inside && event) event.stopPropagation();
        return inside;
    }
    isFunctionKeyPressed(event) {
        const { srcEvent: srcEvent  } = event;
        return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
    }
    isDragging() {
        return this._interactionState.isDragging || false;
    }
    blockEvents(timeout) {
        const timer = setTimeout(()=>{
            if (this._eventStartBlocked === timer) this._eventStartBlocked = null;
        }, timeout);
        this._eventStartBlocked = timer;
    }
    setProps(props) {
        if (props.dragMode) this.dragMode = props.dragMode;
        this.props = props;
        if (!("transitionInterpolator" in props)) props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;
        this.transitionManager.processViewStateChange(props);
        const { inertia: inertia  } = props;
        this.inertia = Number.isFinite(inertia) ? inertia : inertia === true ? $9a93059544335596$var$DEFAULT_INERTIA : 0;
        const { scrollZoom: scrollZoom = true , dragPan: dragPan = true , dragRotate: dragRotate = true , doubleClickZoom: doubleClickZoom = true , touchZoom: touchZoom = true , touchRotate: touchRotate = false , keyboard: keyboard = true  } = props;
        const isInteractive = Boolean(this.onViewStateChange);
        this.toggleEvents($9a93059544335596$var$EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
        this.toggleEvents($9a93059544335596$var$EVENT_TYPES.PAN, isInteractive && (dragPan || dragRotate));
        this.toggleEvents($9a93059544335596$var$EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
        this.toggleEvents($9a93059544335596$var$EVENT_TYPES.TRIPLE_PAN, isInteractive && touchRotate);
        this.toggleEvents($9a93059544335596$var$EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
        this.toggleEvents($9a93059544335596$var$EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
        this.scrollZoom = scrollZoom;
        this.dragPan = dragPan;
        this.dragRotate = dragRotate;
        this.doubleClickZoom = doubleClickZoom;
        this.touchZoom = touchZoom;
        this.touchRotate = touchRotate;
        this.keyboard = keyboard;
    }
    updateTransition() {
        this.transitionManager.updateTransition();
    }
    toggleEvents(eventNames, enabled) {
        if (this.eventManager) eventNames.forEach((eventName)=>{
            if (this._events[eventName] !== enabled) {
                this._events[eventName] = enabled;
                if (enabled) this.eventManager.on(eventName, this.handleEvent);
                else this.eventManager.off(eventName, this.handleEvent);
            }
        });
    }
    updateViewport(newControllerState, extraProps = null, interactionState = {}) {
        const viewState = {
            ...newControllerState.getViewportProps(),
            ...extraProps
        };
        const changed = this.controllerState !== newControllerState;
        this.state = newControllerState.getState();
        this._setInteractionState(interactionState);
        if (changed) {
            const oldViewState = this.controllerState && this.controllerState.getViewportProps();
            if (this.onViewStateChange) this.onViewStateChange({
                viewState: viewState,
                interactionState: this._interactionState,
                oldViewState: oldViewState
            });
        }
    }
    _onTransition(params) {
        this.onViewStateChange({
            ...params,
            interactionState: this._interactionState
        });
    }
    _setInteractionState(newStates) {
        Object.assign(this._interactionState, newStates);
        this.onStateChange(this._interactionState);
    }
    _onPanStart(event) {
        const pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) return false;
        let alternateMode = this.isFunctionKeyPressed(event) || event.rightButton || false;
        if (this.invertPan || this.dragMode === "pan") alternateMode = !alternateMode;
        const newControllerState = this.controllerState[alternateMode ? "panStart" : "rotateStart"]({
            pos: pos
        });
        this._panMove = alternateMode;
        this.updateViewport(newControllerState, $9a93059544335596$var$NO_TRANSITION_PROPS, {
            isDragging: true
        });
        return true;
    }
    _onPan(event) {
        if (!this.isDragging()) return false;
        return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);
    }
    _onPanEnd(event) {
        if (!this.isDragging()) return false;
        return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);
    }
    _onPanMove(event) {
        if (!this.dragPan) return false;
        const pos = this.getCenter(event);
        const newControllerState = this.controllerState.pan({
            pos: pos
        });
        this.updateViewport(newControllerState, $9a93059544335596$var$NO_TRANSITION_PROPS, {
            isDragging: true,
            isPanning: true
        });
        return true;
    }
    _onPanMoveEnd(event) {
        const { inertia: inertia  } = this;
        if (this.dragPan && inertia && event.velocity) {
            const pos = this.getCenter(event);
            const endPos = [
                pos[0] + event.velocityX * inertia / 2,
                pos[1] + event.velocityY * inertia / 2
            ];
            const newControllerState = this.controllerState.pan({
                pos: endPos
            }).panEnd();
            this.updateViewport(newControllerState, {
                ...this._getTransitionProps(),
                transitionDuration: inertia,
                transitionEasing: $9a93059544335596$var$INERTIA_EASING
            }, {
                isDragging: false,
                isPanning: true
            });
        } else {
            const newControllerState = this.controllerState.panEnd();
            this.updateViewport(newControllerState, null, {
                isDragging: false,
                isPanning: false
            });
        }
        return true;
    }
    _onPanRotate(event) {
        if (!this.dragRotate) return false;
        const pos = this.getCenter(event);
        const newControllerState = this.controllerState.rotate({
            pos: pos
        });
        this.updateViewport(newControllerState, $9a93059544335596$var$NO_TRANSITION_PROPS, {
            isDragging: true,
            isRotating: true
        });
        return true;
    }
    _onPanRotateEnd(event) {
        const { inertia: inertia  } = this;
        if (this.dragRotate && inertia && event.velocity) {
            const pos = this.getCenter(event);
            const endPos = [
                pos[0] + event.velocityX * inertia / 2,
                pos[1] + event.velocityY * inertia / 2
            ];
            const newControllerState = this.controllerState.rotate({
                pos: endPos
            }).rotateEnd();
            this.updateViewport(newControllerState, {
                ...this._getTransitionProps(),
                transitionDuration: inertia,
                transitionEasing: $9a93059544335596$var$INERTIA_EASING
            }, {
                isDragging: false,
                isRotating: true
            });
        } else {
            const newControllerState = this.controllerState.rotateEnd();
            this.updateViewport(newControllerState, null, {
                isDragging: false,
                isRotating: false
            });
        }
        return true;
    }
    _onWheel(event) {
        if (!this.scrollZoom) return false;
        event.srcEvent.preventDefault();
        const pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) return false;
        const { speed: speed = 0.01 , smooth: smooth = false  } = this.scrollZoom === true ? {} : this.scrollZoom;
        const { delta: delta  } = event;
        let scale = 2 / (1 + Math.exp(-Math.abs(delta * speed)));
        if (delta < 0 && scale !== 0) scale = 1 / scale;
        const newControllerState = this.controllerState.zoom({
            pos: pos,
            scale: scale
        });
        this.updateViewport(newControllerState, {
            ...this._getTransitionProps({
                around: pos
            }),
            transitionDuration: smooth ? 250 : 1
        }, {
            isZooming: true,
            isPanning: true
        });
        return true;
    }
    _onTriplePanStart(event) {
        const pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) return false;
        const newControllerState = this.controllerState.rotateStart({
            pos: pos
        });
        this.updateViewport(newControllerState, $9a93059544335596$var$NO_TRANSITION_PROPS, {
            isDragging: true
        });
        return true;
    }
    _onTriplePan(event) {
        if (!this.touchRotate) return false;
        if (!this.isDragging()) return false;
        const pos = this.getCenter(event);
        pos[0] -= event.deltaX;
        const newControllerState = this.controllerState.rotate({
            pos: pos
        });
        this.updateViewport(newControllerState, $9a93059544335596$var$NO_TRANSITION_PROPS, {
            isDragging: true,
            isRotating: true
        });
        return true;
    }
    _onTriplePanEnd(event) {
        if (!this.isDragging()) return false;
        const { inertia: inertia  } = this;
        if (this.touchRotate && inertia && event.velocityY) {
            const pos = this.getCenter(event);
            const endPos = [
                pos[0],
                pos[1] += event.velocityY * inertia / 2
            ];
            const newControllerState = this.controllerState.rotate({
                pos: endPos
            });
            this.updateViewport(newControllerState, {
                ...this._getTransitionProps(),
                transitionDuration: inertia,
                transitionEasing: $9a93059544335596$var$INERTIA_EASING
            }, {
                isDragging: false,
                isRotating: true
            });
            this.blockEvents(inertia);
        } else {
            const newControllerState = this.controllerState.rotateEnd();
            this.updateViewport(newControllerState, null, {
                isDragging: false,
                isRotating: false
            });
        }
        return true;
    }
    _onPinchStart(event) {
        const pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) return false;
        const newControllerState = this.controllerState.zoomStart({
            pos: pos
        }).rotateStart({
            pos: pos
        });
        $9a93059544335596$var$pinchEventWorkaround._startPinchRotation = event.rotation;
        $9a93059544335596$var$pinchEventWorkaround._lastPinchEvent = event;
        this.updateViewport(newControllerState, $9a93059544335596$var$NO_TRANSITION_PROPS, {
            isDragging: true
        });
        return true;
    }
    _onPinch(event) {
        if (!this.touchZoom && !this.touchRotate) return false;
        if (!this.isDragging()) return false;
        let newControllerState = this.controllerState;
        if (this.touchZoom) {
            const { scale: scale  } = event;
            const pos = this.getCenter(event);
            newControllerState = newControllerState.zoom({
                pos: pos,
                scale: scale
            });
        }
        if (this.touchRotate) {
            const { rotation: rotation  } = event;
            newControllerState = newControllerState.rotate({
                deltaAngleX: $9a93059544335596$var$pinchEventWorkaround._startPinchRotation - rotation
            });
        }
        this.updateViewport(newControllerState, $9a93059544335596$var$NO_TRANSITION_PROPS, {
            isDragging: true,
            isPanning: this.touchZoom,
            isZooming: this.touchZoom,
            isRotating: this.touchRotate
        });
        $9a93059544335596$var$pinchEventWorkaround._lastPinchEvent = event;
        return true;
    }
    _onPinchEnd(event) {
        if (!this.isDragging()) return false;
        const { inertia: inertia  } = this;
        const { _lastPinchEvent: _lastPinchEvent  } = $9a93059544335596$var$pinchEventWorkaround;
        if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
            const pos = this.getCenter(event);
            let newControllerState = this.controllerState.rotateEnd();
            const z = Math.log2(event.scale);
            const velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);
            const endScale = Math.pow(2, z + velocityZ * inertia / 2);
            newControllerState = newControllerState.zoom({
                pos: pos,
                scale: endScale
            }).zoomEnd();
            this.updateViewport(newControllerState, {
                ...this._getTransitionProps({
                    around: pos
                }),
                transitionDuration: inertia,
                transitionEasing: $9a93059544335596$var$INERTIA_EASING
            }, {
                isDragging: false,
                isPanning: this.touchZoom,
                isZooming: this.touchZoom,
                isRotating: false
            });
            this.blockEvents(inertia);
        } else {
            const newControllerState = this.controllerState.zoomEnd().rotateEnd();
            this.updateViewport(newControllerState, null, {
                isDragging: false,
                isPanning: false,
                isZooming: false,
                isRotating: false
            });
        }
        $9a93059544335596$var$pinchEventWorkaround._startPinchRotation = null;
        $9a93059544335596$var$pinchEventWorkaround._lastPinchEvent = null;
        return true;
    }
    _onDoubleTap(event) {
        if (!this.doubleClickZoom) return false;
        const pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) return false;
        const isZoomOut = this.isFunctionKeyPressed(event);
        const newControllerState = this.controllerState.zoom({
            pos: pos,
            scale: isZoomOut ? 0.5 : 2
        });
        this.updateViewport(newControllerState, this._getTransitionProps({
            around: pos
        }), {
            isZooming: true,
            isPanning: true
        });
        this.blockEvents(100);
        return true;
    }
    _onKeyDown(event) {
        if (!this.keyboard) return false;
        const funcKey = this.isFunctionKeyPressed(event);
        const { zoomSpeed: zoomSpeed , moveSpeed: moveSpeed , rotateSpeedX: rotateSpeedX , rotateSpeedY: rotateSpeedY  } = this.keyboard === true ? {} : this.keyboard;
        const { controllerState: controllerState  } = this;
        let newControllerState;
        const interactionState = {};
        switch(event.srcEvent.code){
            case "Minus":
                newControllerState = funcKey ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed) : controllerState.zoomOut(zoomSpeed);
                interactionState.isZooming = true;
                break;
            case "Equal":
                newControllerState = funcKey ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed) : controllerState.zoomIn(zoomSpeed);
                interactionState.isZooming = true;
                break;
            case "ArrowLeft":
                if (funcKey) {
                    newControllerState = controllerState.rotateLeft(rotateSpeedX);
                    interactionState.isRotating = true;
                } else {
                    newControllerState = controllerState.moveLeft(moveSpeed);
                    interactionState.isPanning = true;
                }
                break;
            case "ArrowRight":
                if (funcKey) {
                    newControllerState = controllerState.rotateRight(rotateSpeedX);
                    interactionState.isRotating = true;
                } else {
                    newControllerState = controllerState.moveRight(moveSpeed);
                    interactionState.isPanning = true;
                }
                break;
            case "ArrowUp":
                if (funcKey) {
                    newControllerState = controllerState.rotateUp(rotateSpeedY);
                    interactionState.isRotating = true;
                } else {
                    newControllerState = controllerState.moveUp(moveSpeed);
                    interactionState.isPanning = true;
                }
                break;
            case "ArrowDown":
                if (funcKey) {
                    newControllerState = controllerState.rotateDown(rotateSpeedY);
                    interactionState.isRotating = true;
                } else {
                    newControllerState = controllerState.moveDown(moveSpeed);
                    interactionState.isPanning = true;
                }
                break;
            default:
                return false;
        }
        this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
        return true;
    }
    _getTransitionProps(opts) {
        const { transition: transition  } = this;
        if (!transition || !transition.transitionInterpolator) return $9a93059544335596$var$NO_TRANSITION_PROPS;
        return opts ? {
            ...transition,
            transitionInterpolator: new (0, $be3e6f41f904fd21$export$2e2bcd8739ae039)({
                ...opts,
                ...transition.transitionInterpolator.opts,
                makeViewport: this.controllerState.makeViewport
            })
        } : transition;
    }
}



class $56f07b62de053c52$export$2e2bcd8739ae039 {
    constructor(props, state){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_viewportProps", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_state", void 0);
        this._viewportProps = this.applyConstraints(props);
        this._state = state;
    }
    getViewportProps() {
        return this._viewportProps;
    }
    getState() {
        return this._state;
    }
}





const $67cdee9be4ca71e5$var$PITCH_MOUSE_THRESHOLD = 5;
const $67cdee9be4ca71e5$var$PITCH_ACCEL = 1.2;
class $67cdee9be4ca71e5$export$11a6af20c28b5410 extends (0, $56f07b62de053c52$export$2e2bcd8739ae039) {
    constructor(options){
        const { width: width , height: height , latitude: latitude , longitude: longitude , zoom: zoom , bearing: bearing = 0 , pitch: pitch = 0 , altitude: altitude = 1.5 , position: position = [
            0,
            0,
            0
        ] , maxZoom: maxZoom = 20 , minZoom: minZoom = 0 , maxPitch: maxPitch = 60 , minPitch: minPitch = 0 , startPanLngLat: startPanLngLat , startZoomLngLat: startZoomLngLat , startRotatePos: startRotatePos , startBearing: startBearing , startPitch: startPitch , startZoom: startZoom , normalize: normalize = true  } = options;
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(Number.isFinite(longitude));
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(Number.isFinite(latitude));
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(Number.isFinite(zoom));
        super({
            width: width,
            height: height,
            latitude: latitude,
            longitude: longitude,
            zoom: zoom,
            bearing: bearing,
            pitch: pitch,
            altitude: altitude,
            maxZoom: maxZoom,
            minZoom: minZoom,
            maxPitch: maxPitch,
            minPitch: minPitch,
            normalize: normalize,
            position: position
        }, {
            startPanLngLat: startPanLngLat,
            startZoomLngLat: startZoomLngLat,
            startRotatePos: startRotatePos,
            startBearing: startBearing,
            startPitch: startPitch,
            startZoom: startZoom
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "makeViewport", void 0);
        this.makeViewport = options.makeViewport;
    }
    panStart({ pos: pos  }) {
        return this._getUpdatedState({
            startPanLngLat: this._unproject(pos)
        });
    }
    pan({ pos: pos , startPos: startPos  }) {
        const startPanLngLat = this.getState().startPanLngLat || this._unproject(startPos);
        if (!startPanLngLat) return this;
        const viewport = this.makeViewport(this.getViewportProps());
        const newProps = viewport.panByPosition(startPanLngLat, pos);
        return this._getUpdatedState(newProps);
    }
    panEnd() {
        return this._getUpdatedState({
            startPanLngLat: null
        });
    }
    rotateStart({ pos: pos  }) {
        return this._getUpdatedState({
            startRotatePos: pos,
            startBearing: this.getViewportProps().bearing,
            startPitch: this.getViewportProps().pitch
        });
    }
    rotate({ pos: pos , deltaAngleX: deltaAngleX = 0 , deltaAngleY: deltaAngleY = 0  }) {
        const { startRotatePos: startRotatePos , startBearing: startBearing , startPitch: startPitch  } = this.getState();
        if (!startRotatePos || startBearing === undefined || startPitch === undefined) return this;
        let newRotation;
        if (pos) newRotation = this._getNewRotation(pos, startRotatePos, startPitch, startBearing);
        else newRotation = {
            bearing: startBearing + deltaAngleX,
            pitch: startPitch + deltaAngleY
        };
        return this._getUpdatedState(newRotation);
    }
    rotateEnd() {
        return this._getUpdatedState({
            startBearing: null,
            startPitch: null
        });
    }
    zoomStart({ pos: pos  }) {
        return this._getUpdatedState({
            startZoomLngLat: this._unproject(pos),
            startZoom: this.getViewportProps().zoom
        });
    }
    zoom({ pos: pos , startPos: startPos , scale: scale  }) {
        let { startZoom: startZoom , startZoomLngLat: startZoomLngLat  } = this.getState();
        if (!startZoomLngLat) {
            startZoom = this.getViewportProps().zoom;
            startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
        }
        if (!startZoomLngLat) return this;
        const { maxZoom: maxZoom , minZoom: minZoom  } = this.getViewportProps();
        let zoom = startZoom + Math.log2(scale);
        zoom = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(zoom, minZoom, maxZoom);
        const zoomedViewport = this.makeViewport({
            ...this.getViewportProps(),
            zoom: zoom
        });
        return this._getUpdatedState({
            zoom: zoom,
            ...zoomedViewport.panByPosition(startZoomLngLat, pos)
        });
    }
    zoomEnd() {
        return this._getUpdatedState({
            startZoomLngLat: null,
            startZoom: null
        });
    }
    zoomIn(speed = 2) {
        return this._zoomFromCenter(speed);
    }
    zoomOut(speed = 2) {
        return this._zoomFromCenter(1 / speed);
    }
    moveLeft(speed = 100) {
        return this._panFromCenter([
            speed,
            0
        ]);
    }
    moveRight(speed = 100) {
        return this._panFromCenter([
            -speed,
            0
        ]);
    }
    moveUp(speed = 100) {
        return this._panFromCenter([
            0,
            speed
        ]);
    }
    moveDown(speed = 100) {
        return this._panFromCenter([
            0,
            -speed
        ]);
    }
    rotateLeft(speed = 15) {
        return this._getUpdatedState({
            bearing: this.getViewportProps().bearing - speed
        });
    }
    rotateRight(speed = 15) {
        return this._getUpdatedState({
            bearing: this.getViewportProps().bearing + speed
        });
    }
    rotateUp(speed = 10) {
        return this._getUpdatedState({
            pitch: this.getViewportProps().pitch + speed
        });
    }
    rotateDown(speed = 10) {
        return this._getUpdatedState({
            pitch: this.getViewportProps().pitch - speed
        });
    }
    shortestPathFrom(viewState) {
        const fromProps = viewState.getViewportProps();
        const props = {
            ...this.getViewportProps()
        };
        const { bearing: bearing , longitude: longitude  } = props;
        if (Math.abs(bearing - fromProps.bearing) > 180) props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
        if (Math.abs(longitude - fromProps.longitude) > 180) props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
        return props;
    }
    applyConstraints(props) {
        const { maxZoom: maxZoom , minZoom: minZoom , zoom: zoom  } = props;
        props.zoom = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(zoom, minZoom, maxZoom);
        const { maxPitch: maxPitch , minPitch: minPitch , pitch: pitch  } = props;
        props.pitch = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(pitch, minPitch, maxPitch);
        const { normalize: normalize = true  } = props;
        if (normalize) Object.assign(props, (0, $a727f0775314f814$export$2e2bcd8739ae039)(props));
        return props;
    }
    _zoomFromCenter(scale) {
        const { width: width , height: height  } = this.getViewportProps();
        return this.zoom({
            pos: [
                width / 2,
                height / 2
            ],
            scale: scale
        });
    }
    _panFromCenter(offset) {
        const { width: width , height: height  } = this.getViewportProps();
        return this.pan({
            startPos: [
                width / 2,
                height / 2
            ],
            pos: [
                width / 2 + offset[0],
                height / 2 + offset[1]
            ]
        });
    }
    _getUpdatedState(newProps) {
        return new this.constructor({
            makeViewport: this.makeViewport,
            ...this.getViewportProps(),
            ...this.getState(),
            ...newProps
        });
    }
    _unproject(pos) {
        const viewport = this.makeViewport(this.getViewportProps());
        return pos && viewport.unproject(pos);
    }
    _getNewRotation(pos, startPos, startPitch, startBearing) {
        const deltaX = pos[0] - startPos[0];
        const deltaY = pos[1] - startPos[1];
        const centerY = pos[1];
        const startY = startPos[1];
        const { width: width , height: height  } = this.getViewportProps();
        const deltaScaleX = deltaX / width;
        let deltaScaleY = 0;
        if (deltaY > 0) {
            if (Math.abs(height - startY) > $67cdee9be4ca71e5$var$PITCH_MOUSE_THRESHOLD) deltaScaleY = deltaY / (startY - height) * $67cdee9be4ca71e5$var$PITCH_ACCEL;
        } else if (deltaY < 0) {
            if (startY > $67cdee9be4ca71e5$var$PITCH_MOUSE_THRESHOLD) deltaScaleY = 1 - centerY / startY;
        }
        deltaScaleY = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(deltaScaleY, -1, 1);
        const { minPitch: minPitch , maxPitch: maxPitch  } = this.getViewportProps();
        const bearing = startBearing + 180 * deltaScaleX;
        let pitch = startPitch;
        if (deltaScaleY > 0) pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
        else if (deltaScaleY < 0) pitch = startPitch - deltaScaleY * (minPitch - startPitch);
        return {
            pitch: pitch,
            bearing: bearing
        };
    }
}
class $67cdee9be4ca71e5$export$2e2bcd8739ae039 extends (0, $9a93059544335596$export$2e2bcd8739ae039) {
    constructor(...args){
        super(...args);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "ControllerState", $67cdee9be4ca71e5$export$11a6af20c28b5410);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transition", {
            transitionDuration: 300,
            transitionInterpolator: new (0, $be3e6f41f904fd21$export$2e2bcd8739ae039)({
                transitionProps: {
                    compare: [
                        "longitude",
                        "latitude",
                        "zoom",
                        "bearing",
                        "pitch",
                        "position"
                    ],
                    required: [
                        "longitude",
                        "latitude",
                        "zoom"
                    ]
                }
            })
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "dragMode", "pan");
    }
    setProps(props) {
        props.position = props.position || [
            0,
            0,
            0
        ];
        const oldProps = this.props;
        super.setProps(props);
        const dimensionChanged = !oldProps || oldProps.height !== props.height;
        if (dimensionChanged) this.updateViewport(new this.ControllerState({
            makeViewport: this.makeViewport,
            ...props,
            ...this.state
        }));
    }
}


class $d73daa375e65bcb3$export$2e2bcd8739ae039 extends (0, $f435da35b0feb027$export$2e2bcd8739ae039) {
    get ViewportType() {
        return 0, $4ac7d89cb7f1c4ad$export$2e2bcd8739ae039;
    }
    get ControllerType() {
        return 0, $67cdee9be4ca71e5$export$2e2bcd8739ae039;
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($d73daa375e65bcb3$export$2e2bcd8739ae039, "displayName", "MapView");







const $f48ccf05d22c92a4$var$DEFAULT_LIGHT_COLOR = [
    255,
    255,
    255
];
const $f48ccf05d22c92a4$var$DEFAULT_LIGHT_INTENSITY = 1.0;
let $f48ccf05d22c92a4$var$idCount = 0;
class $f48ccf05d22c92a4$export$af279bfef9ec2c96 {
    constructor(props = {}){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "color", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "intensity", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "type", "ambient");
        const { color: color = $f48ccf05d22c92a4$var$DEFAULT_LIGHT_COLOR  } = props;
        const { intensity: intensity = $f48ccf05d22c92a4$var$DEFAULT_LIGHT_INTENSITY  } = props;
        this.id = props.id || "ambient-".concat($f48ccf05d22c92a4$var$idCount++);
        this.color = color;
        this.intensity = intensity;
    }
}




const $26151c4aae5387e4$var$DEFAULT_LIGHT_COLOR = [
    255,
    255,
    255
];
const $26151c4aae5387e4$var$DEFAULT_LIGHT_INTENSITY = 1.0;
const $26151c4aae5387e4$var$DEFAULT_LIGHT_DIRECTION = [
    0.0,
    0.0,
    -1
];
let $26151c4aae5387e4$var$idCount = 0;
class $26151c4aae5387e4$export$3fea33cc9972c868 {
    constructor(props = {}){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "color", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "intensity", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "type", "directional");
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "direction", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "shadow", void 0);
        const { color: color = $26151c4aae5387e4$var$DEFAULT_LIGHT_COLOR  } = props;
        const { intensity: intensity = $26151c4aae5387e4$var$DEFAULT_LIGHT_INTENSITY  } = props;
        const { direction: direction = $26151c4aae5387e4$var$DEFAULT_LIGHT_DIRECTION  } = props;
        const { _shadow: _shadow = false  } = props;
        this.id = props.id || "directional-".concat($26151c4aae5387e4$var$idCount++);
        this.color = color;
        this.intensity = intensity;
        this.type = "directional";
        this.direction = new (0, $9c6695c39a874609$export$2e2bcd8739ae039)(direction).normalize().toArray();
        this.shadow = _shadow;
    }
    getProjectedLight(opts) {
        return this;
    }
}





class $9818e5fdfdc2540b$export$2e2bcd8739ae039 {
    constructor(gl, props = {
        id: "pass"
    }){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "gl", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", void 0);
        const { id: id  } = props;
        this.id = id;
        this.gl = gl;
        this.props = {
            ...props
        };
    }
    setProps(props) {
        Object.assign(this.props, props);
    }
    render(params) {}
    cleanup() {}
}



class $b1756d854624bf2b$export$2e2bcd8739ae039 extends (0, $9818e5fdfdc2540b$export$2e2bcd8739ae039) {
    render(options) {
        const gl = this.gl;
        (0, $54220aa8b6471f1a$export$60752c4a8a24d484)(gl, {
            framebuffer: options.target
        });
        return this._drawLayers(options);
    }
    _drawLayers(options) {
        const { target: target , moduleParameters: moduleParameters , viewports: viewports , views: views , onViewportActive: onViewportActive , clearCanvas: clearCanvas = true  } = options;
        options.pass = options.pass || "unknown";
        const gl = this.gl;
        if (clearCanvas) $b1756d854624bf2b$var$clearGLCanvas(gl);
        const renderStats = [];
        for (const viewport of viewports){
            const view = views && views[viewport.id];
            onViewportActive(viewport);
            const drawLayerParams = this._getDrawLayerParams(viewport, options);
            const subViewports = viewport.subViewports || [
                viewport
            ];
            for (const subViewport of subViewports){
                const stats = this._drawLayersInViewport(gl, {
                    target: target,
                    moduleParameters: moduleParameters,
                    viewport: subViewport,
                    view: view,
                    pass: options.pass,
                    layers: options.layers
                }, drawLayerParams);
                renderStats.push(stats);
            }
        }
        return renderStats;
    }
    _getDrawLayerParams(viewport, { layers: layers , pass: pass , layerFilter: layerFilter , cullRect: cullRect , effects: effects , moduleParameters: moduleParameters  }) {
        const drawLayerParams = [];
        const indexResolver = $b1756d854624bf2b$export$8510ed7ba103de75();
        const drawContext = {
            layer: layers[0],
            viewport: viewport,
            isPicking: pass.startsWith("picking"),
            renderPass: pass,
            cullRect: cullRect
        };
        const layerFilterCache = {};
        for(let layerIndex = 0; layerIndex < layers.length; layerIndex++){
            const layer = layers[layerIndex];
            const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);
            const layerParam = {
                shouldDrawLayer: shouldDrawLayer
            };
            if (shouldDrawLayer) {
                layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);
                layerParam.moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);
                layerParam.layerParameters = this.getLayerParameters(layer, layerIndex, viewport);
            }
            drawLayerParams[layerIndex] = layerParam;
        }
        return drawLayerParams;
    }
    _drawLayersInViewport(gl, { layers: layers , moduleParameters: globalModuleParameters , pass: pass , target: target , viewport: viewport , view: view  }, drawLayerParams) {
        const glViewport = $b1756d854624bf2b$var$getGLViewport(gl, {
            moduleParameters: globalModuleParameters,
            target: target,
            viewport: viewport
        });
        if (view && view.props.clear) {
            const clearOpts = view.props.clear === true ? {
                color: true,
                depth: true
            } : view.props.clear;
            (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(gl, {
                scissorTest: true,
                scissor: glViewport
            }, ()=>(0, $9d2da77370080708$export$42ffd38884aecdac)(gl, clearOpts));
        }
        const renderStatus = {
            totalCount: layers.length,
            visibleCount: 0,
            compositeCount: 0,
            pickableCount: 0
        };
        (0, $54220aa8b6471f1a$export$60752c4a8a24d484)(gl, {
            viewport: glViewport
        });
        for(let layerIndex = 0; layerIndex < layers.length; layerIndex++){
            const layer = layers[layerIndex];
            const { shouldDrawLayer: shouldDrawLayer , layerRenderIndex: layerRenderIndex , moduleParameters: moduleParameters , layerParameters: layerParameters  } = drawLayerParams[layerIndex];
            if (shouldDrawLayer && layer.props.pickable) renderStatus.pickableCount++;
            if (layer.isComposite) renderStatus.compositeCount++;
            else if (shouldDrawLayer) {
                renderStatus.visibleCount++;
                moduleParameters.viewport = viewport;
                try {
                    layer._drawLayer({
                        moduleParameters: moduleParameters,
                        uniforms: {
                            layerIndex: layerRenderIndex
                        },
                        parameters: layerParameters
                    });
                } catch (err) {
                    layer.raiseError(err, "drawing ".concat(layer, " to ").concat(pass));
                }
            }
        }
        return renderStatus;
    }
    shouldDrawLayer(layer) {
        return true;
    }
    getModuleParameters(layer, effects) {
        return null;
    }
    getLayerParameters(layer, layerIndex, viewport) {
        return layer.props.parameters;
    }
    _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {
        const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);
        if (!shouldDrawLayer) return false;
        drawContext.layer = layer;
        let parent = layer.parent;
        while(parent){
            if (!parent.props.visible || !parent.filterSubLayer(drawContext)) return false;
            drawContext.layer = parent;
            parent = parent.parent;
        }
        if (layerFilter) {
            const rootLayerId = drawContext.layer.id;
            if (!(rootLayerId in layerFilterCache)) layerFilterCache[rootLayerId] = layerFilter(drawContext);
            if (!layerFilterCache[rootLayerId]) return false;
        }
        layer.activateViewport(drawContext.viewport);
        return true;
    }
    _getModuleParameters(layer, effects, pass, overrides) {
        var _layer$internalState;
        const moduleParameters = Object.assign(Object.create(((_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.propsInTransition) || layer.props), {
            autoWrapLongitude: layer.wrapLongitude,
            viewport: layer.context.viewport,
            mousePosition: layer.context.mousePosition,
            pickingActive: 0,
            devicePixelRatio: (0, $294e503c6396a3ff$export$df40057290e74703)(this.gl)
        });
        if (effects) for (const effect of effects){
            var _effect$getModulePara;
            Object.assign(moduleParameters, (_effect$getModulePara = effect.getModuleParameters) === null || _effect$getModulePara === void 0 ? void 0 : _effect$getModulePara.call(effect, layer));
        }
        return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);
    }
}
function $b1756d854624bf2b$export$8510ed7ba103de75(startIndex = 0, layerIndices = {}) {
    const resolvers = {};
    const resolveLayerIndex = (layer, isDrawn)=>{
        const indexOverride = layer.props._offset;
        const layerId = layer.id;
        const parentId = layer.parent && layer.parent.id;
        let index;
        if (parentId && !(parentId in layerIndices)) resolveLayerIndex(layer.parent, false);
        if (parentId in resolvers) {
            const resolver = resolvers[parentId] = resolvers[parentId] || $b1756d854624bf2b$export$8510ed7ba103de75(layerIndices[parentId], layerIndices);
            index = resolver(layer, isDrawn);
            resolvers[layerId] = resolver;
        } else if (Number.isFinite(indexOverride)) {
            index = indexOverride + (layerIndices[parentId] || 0);
            resolvers[layerId] = null;
        } else index = startIndex;
        if (isDrawn && index >= startIndex) startIndex = index + 1;
        layerIndices[layerId] = index;
        return index;
    };
    return resolveLayerIndex;
}
function $b1756d854624bf2b$var$getGLViewport(gl, { moduleParameters: moduleParameters , target: target , viewport: viewport  }) {
    const useTarget = target && target.id !== "default-framebuffer";
    const pixelRatio = moduleParameters && moduleParameters.devicePixelRatio || (0, $294e503c6396a3ff$export$df40057290e74703)(gl);
    const height = useTarget ? target.height : gl.drawingBufferHeight;
    const dimensions = viewport;
    return [
        dimensions.x * pixelRatio,
        height - (dimensions.y + dimensions.height) * pixelRatio,
        dimensions.width * pixelRatio,
        dimensions.height * pixelRatio
    ];
}
function $b1756d854624bf2b$var$clearGLCanvas(gl) {
    const width = gl.drawingBufferWidth;
    const height = gl.drawingBufferHeight;
    (0, $54220aa8b6471f1a$export$60752c4a8a24d484)(gl, {
        viewport: [
            0,
            0,
            width,
            height
        ]
    });
    gl.clear(16640);
}



class $82ba7828a81ad8c8$export$2e2bcd8739ae039 extends (0, $b1756d854624bf2b$export$2e2bcd8739ae039) {
    constructor(gl, props){
        super(gl, props);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "shadowMap", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "depthBuffer", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "fbo", void 0);
        this.shadowMap = new (0, $df31c887249e3faa$export$2e2bcd8739ae039)(gl, {
            width: 1,
            height: 1,
            parameters: {
                [10241]: 9729,
                [10240]: 9729,
                [10242]: 33071,
                [10243]: 33071
            }
        });
        this.depthBuffer = new (0, $0082476f18a250b0$export$2e2bcd8739ae039)(gl, {
            format: 33189,
            width: 1,
            height: 1
        });
        this.fbo = new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(gl, {
            id: "shadowmap",
            width: 1,
            height: 1,
            attachments: {
                [36064]: this.shadowMap,
                [36096]: this.depthBuffer
            }
        });
    }
    render(params) {
        const target = this.fbo;
        (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(this.gl, {
            depthRange: [
                0,
                1
            ],
            depthTest: true,
            blend: false,
            clearColor: [
                1,
                1,
                1,
                1
            ]
        }, ()=>{
            const viewport = params.viewports[0];
            const pixelRatio = (0, $294e503c6396a3ff$export$df40057290e74703)(this.gl);
            const width = viewport.width * pixelRatio;
            const height = viewport.height * pixelRatio;
            if (width !== target.width || height !== target.height) target.resize({
                width: width,
                height: height
            });
            super.render({
                ...params,
                target: target,
                pass: "shadow"
            });
        });
    }
    shouldDrawLayer(layer) {
        return layer.props.shadowEnabled !== false;
    }
    getModuleParameters() {
        return {
            drawToShadowMap: true
        };
    }
    delete() {
        if (this.fbo) {
            this.fbo.delete();
            this.fbo = null;
        }
        if (this.shadowMap) {
            this.shadowMap.delete();
            this.shadowMap = null;
        }
        if (this.depthBuffer) {
            this.depthBuffer.delete();
            this.depthBuffer = null;
        }
    }
}







const $030e4e4ffe0eebc5$var$vs = "\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n";
const $030e4e4ffe0eebc5$var$fs = "\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n";
const $030e4e4ffe0eebc5$var$getMemoizedViewportCenterPosition = (0, $1ccdae01919b6bce$export$2e2bcd8739ae039)($030e4e4ffe0eebc5$var$getViewportCenterPosition);
const $030e4e4ffe0eebc5$var$getMemoizedViewProjectionMatrices = (0, $1ccdae01919b6bce$export$2e2bcd8739ae039)($030e4e4ffe0eebc5$var$getViewProjectionMatrices);
const $030e4e4ffe0eebc5$var$DEFAULT_SHADOW_COLOR = [
    0,
    0,
    0,
    1.0
];
const $030e4e4ffe0eebc5$var$VECTOR_TO_POINT_MATRIX = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0
];
function $030e4e4ffe0eebc5$var$screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
    const [x, y, z] = xyz;
    const coord = (0, $f5ef504cb5091e21$export$d0eff18eb06add5f)([
        x,
        y,
        z
    ], pixelUnprojectionMatrix);
    if (Number.isFinite(z)) return coord;
    return [
        coord[0],
        coord[1],
        0
    ];
}
function $030e4e4ffe0eebc5$var$getViewportCenterPosition({ viewport: viewport , center: center  }) {
    return new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)(viewport.viewProjectionMatrix).invert().transform(center);
}
function $030e4e4ffe0eebc5$var$getViewProjectionMatrices({ viewport: viewport , shadowMatrices: shadowMatrices  }) {
    const projectionMatrices = [];
    const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;
    const farZ = viewport.isGeospatial ? undefined : 1;
    const corners = [
        [
            0,
            0,
            farZ
        ],
        [
            viewport.width,
            0,
            farZ
        ],
        [
            0,
            viewport.height,
            farZ
        ],
        [
            viewport.width,
            viewport.height,
            farZ
        ],
        [
            0,
            0,
            -1
        ],
        [
            viewport.width,
            0,
            -1
        ],
        [
            0,
            viewport.height,
            -1
        ],
        [
            viewport.width,
            viewport.height,
            -1
        ]
    ].map((pixel)=>$030e4e4ffe0eebc5$var$screenToCommonSpace(pixel, pixelUnprojectionMatrix));
    for (const shadowMatrix of shadowMatrices){
        const viewMatrix = shadowMatrix.clone().translate(new (0, $9c6695c39a874609$export$2e2bcd8739ae039)(viewport.center).negate());
        const positions = corners.map((corner)=>viewMatrix.transform(corner));
        const projectionMatrix = new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)().ortho({
            left: Math.min(...positions.map((position)=>position[0])),
            right: Math.max(...positions.map((position)=>position[0])),
            bottom: Math.min(...positions.map((position)=>position[1])),
            top: Math.max(...positions.map((position)=>position[1])),
            near: Math.min(...positions.map((position)=>-position[2])),
            far: Math.max(...positions.map((position)=>-position[2]))
        });
        projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
    }
    return projectionMatrices;
}
function $030e4e4ffe0eebc5$var$createShadowUniforms(opts, context) {
    const { shadowEnabled: shadowEnabled = true  } = opts;
    if (!shadowEnabled || !opts.shadowMatrices || !opts.shadowMatrices.length) return {
        shadow_uDrawShadowMap: false,
        shadow_uUseShadowMap: false
    };
    const uniforms = {
        shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),
        shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
        shadow_uColor: opts.shadowColor || $030e4e4ffe0eebc5$var$DEFAULT_SHADOW_COLOR,
        shadow_uLightId: opts.shadowLightId || 0,
        shadow_uLightCount: opts.shadowMatrices.length
    };
    const center = $030e4e4ffe0eebc5$var$getMemoizedViewportCenterPosition({
        viewport: opts.viewport,
        center: context.project_uCenter
    });
    const projectCenters = [];
    const viewProjectionMatrices = $030e4e4ffe0eebc5$var$getMemoizedViewProjectionMatrices({
        shadowMatrices: opts.shadowMatrices,
        viewport: opts.viewport
    }).slice();
    for(let i = 0; i < opts.shadowMatrices.length; i++){
        const viewProjectionMatrix = viewProjectionMatrices[i];
        const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new (0, $9c6695c39a874609$export$2e2bcd8739ae039)(opts.viewport.center).negate());
        if (context.project_uCoordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT && context.project_uProjectionMode === (0, $b42a5b9aa3b1a41f$export$3697aaebd269a548).WEB_MERCATOR) {
            viewProjectionMatrices[i] = viewProjectionMatrixCentered;
            projectCenters[i] = center;
        } else {
            viewProjectionMatrices[i] = viewProjectionMatrix.clone().multiplyRight($030e4e4ffe0eebc5$var$VECTOR_TO_POINT_MATRIX);
            projectCenters[i] = viewProjectionMatrixCentered.transform(center);
        }
    }
    for(let i1 = 0; i1 < viewProjectionMatrices.length; i1++){
        uniforms["shadow_uViewProjectionMatrices[".concat(i1, "]")] = viewProjectionMatrices[i1];
        uniforms["shadow_uProjectCenters[".concat(i1, "]")] = projectCenters[i1];
        if (opts.shadowMaps && opts.shadowMaps.length > 0) uniforms["shadow_uShadowMap".concat(i1)] = opts.shadowMaps[i1];
        else uniforms["shadow_uShadowMap".concat(i1)] = opts.dummyShadowMap;
    }
    return uniforms;
}
var $030e4e4ffe0eebc5$export$2e2bcd8739ae039 = {
    name: "shadow",
    dependencies: [
        (0, $669f9ad1259ddfee$export$2e2bcd8739ae039)
    ],
    vs: $030e4e4ffe0eebc5$var$vs,
    fs: $030e4e4ffe0eebc5$var$fs,
    inject: {
        "vs:DECKGL_FILTER_GL_POSITION": "\n    position = shadow_setVertexPosition(geometry.position);\n    ",
        "fs:DECKGL_FILTER_COLOR": "\n    color = shadow_filterShadowColor(color);\n    "
    },
    getUniforms: (opts = {}, context = {})=>{
        if ("viewport" in opts && (opts.drawToShadowMap || opts.shadowMaps && opts.shadowMaps.length > 0)) return $030e4e4ffe0eebc5$var$createShadowUniforms(opts, context);
        return {};
    }
};


const $70e78b90cf44affe$var$DEFAULT_AMBIENT_LIGHT_PROPS = {
    color: [
        255,
        255,
        255
    ],
    intensity: 1.0
};
const $70e78b90cf44affe$var$DEFAULT_DIRECTIONAL_LIGHT_PROPS = [
    {
        color: [
            255,
            255,
            255
        ],
        intensity: 1.0,
        direction: [
            -1,
            3,
            -1
        ]
    },
    {
        color: [
            255,
            255,
            255
        ],
        intensity: 0.9,
        direction: [
            1,
            -8,
            -2.5
        ]
    }
];
const $70e78b90cf44affe$var$DEFAULT_SHADOW_COLOR = [
    0,
    0,
    0,
    200 / 255
];
class $70e78b90cf44affe$export$2e2bcd8739ae039 {
    constructor(props = {}){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", "lighting-effect");
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "shadowColor", $70e78b90cf44affe$var$DEFAULT_SHADOW_COLOR);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "shadow", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "ambientLight", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "directionalLights", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pointLights", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "shadowPasses", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "shadowMaps", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "dummyShadowMap", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "programManager", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "shadowMatrices", void 0);
        for(const key in props){
            const lightSource = props[key];
            switch(lightSource.type){
                case "ambient":
                    this.ambientLight = lightSource;
                    break;
                case "directional":
                    this.directionalLights.push(lightSource);
                    break;
                case "point":
                    this.pointLights.push(lightSource);
                    break;
                default:
            }
        }
        this._applyDefaultLights();
        this.shadow = this.directionalLights.some((light)=>light.shadow);
    }
    preRender(gl, { layers: layers , layerFilter: layerFilter , viewports: viewports , onViewportActive: onViewportActive , views: views  }) {
        if (!this.shadow) return;
        this.shadowMatrices = this._calculateMatrices();
        if (this.shadowPasses.length === 0) this._createShadowPasses(gl);
        if (!this.programManager) {
            this.programManager = (0, $389aec4f13e2bfb5$export$2e2bcd8739ae039).getDefaultProgramManager(gl);
            if (0, $030e4e4ffe0eebc5$export$2e2bcd8739ae039) this.programManager.addDefaultModule((0, $030e4e4ffe0eebc5$export$2e2bcd8739ae039));
        }
        if (!this.dummyShadowMap) this.dummyShadowMap = new (0, $df31c887249e3faa$export$2e2bcd8739ae039)(gl, {
            width: 1,
            height: 1
        });
        for(let i = 0; i < this.shadowPasses.length; i++){
            const shadowPass = this.shadowPasses[i];
            shadowPass.render({
                layers: layers,
                layerFilter: layerFilter,
                viewports: viewports,
                onViewportActive: onViewportActive,
                views: views,
                moduleParameters: {
                    shadowLightId: i,
                    dummyShadowMap: this.dummyShadowMap,
                    shadowMatrices: this.shadowMatrices
                }
            });
        }
    }
    getModuleParameters(layer) {
        const parameters = this.shadow ? {
            shadowMaps: this.shadowMaps,
            dummyShadowMap: this.dummyShadowMap,
            shadowColor: this.shadowColor,
            shadowMatrices: this.shadowMatrices
        } : {};
        parameters.lightSources = {
            ambientLight: this.ambientLight,
            directionalLights: this.directionalLights.map((directionalLight)=>directionalLight.getProjectedLight({
                    layer: layer
                })),
            pointLights: this.pointLights.map((pointLight)=>pointLight.getProjectedLight({
                    layer: layer
                }))
        };
        return parameters;
    }
    cleanup() {
        for (const shadowPass of this.shadowPasses)shadowPass.delete();
        this.shadowPasses.length = 0;
        this.shadowMaps.length = 0;
        if (this.dummyShadowMap) {
            this.dummyShadowMap.delete();
            this.dummyShadowMap = null;
        }
        if (this.shadow && this.programManager) {
            this.programManager.removeDefaultModule((0, $030e4e4ffe0eebc5$export$2e2bcd8739ae039));
            this.programManager = null;
        }
    }
    _calculateMatrices() {
        const lightMatrices = [];
        for (const light of this.directionalLights){
            const viewMatrix = new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)().lookAt({
                eye: new (0, $9c6695c39a874609$export$2e2bcd8739ae039)(light.direction).negate()
            });
            lightMatrices.push(viewMatrix);
        }
        return lightMatrices;
    }
    _createShadowPasses(gl) {
        for(let i = 0; i < this.directionalLights.length; i++){
            const shadowPass = new (0, $82ba7828a81ad8c8$export$2e2bcd8739ae039)(gl);
            this.shadowPasses[i] = shadowPass;
            this.shadowMaps[i] = shadowPass.shadowMap;
        }
    }
    _applyDefaultLights() {
        const { ambientLight: ambientLight , pointLights: pointLights , directionalLights: directionalLights  } = this;
        if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
            this.ambientLight = new (0, $f48ccf05d22c92a4$export$af279bfef9ec2c96)($70e78b90cf44affe$var$DEFAULT_AMBIENT_LIGHT_PROPS);
            this.directionalLights.push(new (0, $26151c4aae5387e4$export$3fea33cc9972c868)($70e78b90cf44affe$var$DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new (0, $26151c4aae5387e4$export$3fea33cc9972c868)($70e78b90cf44affe$var$DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));
        }
    }
}









class $b8b5894efb4b3eb3$export$2e2bcd8739ae039 extends (0, $b1756d854624bf2b$export$2e2bcd8739ae039) {
    constructor(gl, props){
        super(gl, props);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "maskMap", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "fbo", void 0);
        const { mapSize: mapSize = 2048  } = props;
        this.maskMap = new (0, $df31c887249e3faa$export$2e2bcd8739ae039)(gl, {
            width: mapSize,
            height: mapSize,
            parameters: {
                [10241]: 9729,
                [10240]: 9729,
                [10242]: 33071,
                [10243]: 33071
            }
        });
        this.fbo = new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(gl, {
            id: "maskmap",
            width: mapSize,
            height: mapSize,
            attachments: {
                [36064]: this.maskMap
            }
        });
    }
    render(options) {
        const gl = this.gl;
        const colorMask = [
            false,
            false,
            false,
            false
        ];
        colorMask[options.channel] = true;
        return (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(gl, {
            clearColor: [
                255,
                255,
                255,
                255
            ],
            blend: true,
            blendFunc: [
                0,
                1
            ],
            blendEquation: 32778,
            colorMask: colorMask,
            depthTest: false
        }, ()=>super.render({
                ...options,
                target: this.fbo,
                pass: "mask"
            }));
    }
    shouldDrawLayer(layer) {
        return layer.props.operation === (0, $b42a5b9aa3b1a41f$export$b56168d831461ce2).MASK;
    }
    delete() {
        this.fbo.delete();
        this.maskMap.delete();
    }
}









const $9a3d69191761b73c$var$viewMatrix = new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)().lookAt({
    eye: [
        0,
        0,
        1
    ]
});
function $9a3d69191761b73c$var$getProjectionMatrix({ width: width , height: height , near: near , far: far , padding: padding  }) {
    let left = -width / 2;
    let right = width / 2;
    let bottom = -height / 2;
    let top = height / 2;
    if (padding) {
        const { left: l = 0 , right: r = 0 , top: t = 0 , bottom: b = 0  } = padding;
        const offsetX = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)((l + width - r) / 2, 0, width) - width / 2;
        const offsetY = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)((t + height - b) / 2, 0, height) - height / 2;
        left -= offsetX;
        right -= offsetX;
        bottom += offsetY;
        top += offsetY;
    }
    return new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)().ortho({
        left: left,
        right: right,
        bottom: bottom,
        top: top,
        near: near,
        far: far
    });
}
class $9a3d69191761b73c$export$2e2bcd8739ae039 extends (0, $bdb7668fd52e659a$export$2e2bcd8739ae039) {
    constructor(props){
        const { width: width , height: height , near: near = 0.1 , far: far = 1000 , zoom: zoom = 0 , target: target = [
            0,
            0,
            0
        ] , padding: padding = null , flipY: flipY = true  } = props;
        const zoomX = Array.isArray(zoom) ? zoom[0] : zoom;
        const zoomY = Array.isArray(zoom) ? zoom[1] : zoom;
        const zoom_ = Math.min(zoomX, zoomY);
        const scale = Math.pow(2, zoom_);
        let distanceScales;
        if (zoomX !== zoomY) {
            const scaleX = Math.pow(2, zoomX);
            const scaleY = Math.pow(2, zoomY);
            distanceScales = {
                unitsPerMeter: [
                    scaleX / scale,
                    scaleY / scale,
                    1
                ],
                metersPerUnit: [
                    scale / scaleX,
                    scale / scaleY,
                    1
                ]
            };
        }
        super({
            ...props,
            longitude: undefined,
            position: target,
            viewMatrix: $9a3d69191761b73c$var$viewMatrix.clone().scale([
                scale,
                scale * (flipY ? -1 : 1),
                scale
            ]),
            projectionMatrix: $9a3d69191761b73c$var$getProjectionMatrix({
                width: width || 1,
                height: height || 1,
                padding: padding,
                near: near,
                far: far
            }),
            zoom: zoom_,
            distanceScales: distanceScales
        });
    }
    projectFlat([X, Y]) {
        const { unitsPerMeter: unitsPerMeter  } = this.distanceScales;
        return [
            X * unitsPerMeter[0],
            Y * unitsPerMeter[1]
        ];
    }
    unprojectFlat([x, y]) {
        const { metersPerUnit: metersPerUnit  } = this.distanceScales;
        return [
            x * metersPerUnit[0],
            y * metersPerUnit[1]
        ];
    }
    panByPosition(coords, pixel) {
        const fromLocation = (0, $f5ef504cb5091e21$export$d0eff18eb06add5f)(pixel, this.pixelUnprojectionMatrix);
        const toLocation = this.projectFlat(coords);
        const translate = $fceb3370258170b6$export$e16d8520af44a096([], toLocation, $fceb3370258170b6$export$aef51622e549b8b0([], fromLocation));
        const newCenter = $fceb3370258170b6$export$e16d8520af44a096([], this.center, translate);
        return {
            target: this.unprojectFlat(newCenter)
        };
    }
}











class $5b780d9404959b95$export$b17d281980b58efa extends (0, $56f07b62de053c52$export$2e2bcd8739ae039) {
    constructor(options){
        const { width: width , height: height , rotationX: rotationX = 0 , rotationOrbit: rotationOrbit = 0 , target: target = [
            0,
            0,
            0
        ] , zoom: zoom = 0 , minRotationX: minRotationX = -90 , maxRotationX: maxRotationX = 90 , minZoom: minZoom = -Infinity , maxZoom: maxZoom = Infinity , startPanPosition: startPanPosition , startRotatePos: startRotatePos , startRotationX: startRotationX , startRotationOrbit: startRotationOrbit , startZoomPosition: startZoomPosition , startZoom: startZoom  } = options;
        super({
            width: width,
            height: height,
            rotationX: rotationX,
            rotationOrbit: rotationOrbit,
            target: target,
            zoom: zoom,
            minRotationX: minRotationX,
            maxRotationX: maxRotationX,
            minZoom: minZoom,
            maxZoom: maxZoom
        }, {
            startPanPosition: startPanPosition,
            startRotatePos: startRotatePos,
            startRotationX: startRotationX,
            startRotationOrbit: startRotationOrbit,
            startZoomPosition: startZoomPosition,
            startZoom: startZoom
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "makeViewport", void 0);
        this.makeViewport = options.makeViewport;
    }
    panStart({ pos: pos  }) {
        return this._getUpdatedState({
            startPanPosition: this._unproject(pos)
        });
    }
    pan({ pos: pos , startPosition: startPosition  }) {
        const startPanPosition = this.getState().startPanPosition || startPosition;
        if (!startPanPosition) return this;
        const viewport = this.makeViewport(this.getViewportProps());
        const newProps = viewport.panByPosition(startPanPosition, pos);
        return this._getUpdatedState(newProps);
    }
    panEnd() {
        return this._getUpdatedState({
            startPanPosition: null
        });
    }
    rotateStart({ pos: pos  }) {
        return this._getUpdatedState({
            startRotatePos: pos,
            startRotationX: this.getViewportProps().rotationX,
            startRotationOrbit: this.getViewportProps().rotationOrbit
        });
    }
    rotate({ pos: pos , deltaAngleX: deltaAngleX = 0 , deltaAngleY: deltaAngleY = 0  }) {
        const { startRotatePos: startRotatePos , startRotationX: startRotationX , startRotationOrbit: startRotationOrbit  } = this.getState();
        const { width: width , height: height  } = this.getViewportProps();
        if (!startRotatePos || startRotationX === undefined || startRotationOrbit === undefined) return this;
        let newRotation;
        if (pos) {
            let deltaScaleX = (pos[0] - startRotatePos[0]) / width;
            const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
            if (startRotationX < -90 || startRotationX > 90) deltaScaleX *= -1;
            newRotation = {
                rotationX: startRotationX + deltaScaleY * 180,
                rotationOrbit: startRotationOrbit + deltaScaleX * 180
            };
        } else newRotation = {
            rotationX: startRotationX + deltaAngleY,
            rotationOrbit: startRotationOrbit + deltaAngleX
        };
        return this._getUpdatedState(newRotation);
    }
    rotateEnd() {
        return this._getUpdatedState({
            startRotationX: null,
            startRotationOrbit: null
        });
    }
    shortestPathFrom(viewState) {
        const fromProps = viewState.getViewportProps();
        const props = {
            ...this.getViewportProps()
        };
        const { rotationOrbit: rotationOrbit  } = props;
        if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;
        return props;
    }
    zoomStart({ pos: pos  }) {
        return this._getUpdatedState({
            startZoomPosition: this._unproject(pos),
            startZoom: this.getViewportProps().zoom
        });
    }
    zoom({ pos: pos , startPos: startPos , scale: scale  }) {
        let { startZoom: startZoom , startZoomPosition: startZoomPosition  } = this.getState();
        if (!startZoomPosition) {
            startZoom = this.getViewportProps().zoom;
            startZoomPosition = this._unproject(startPos) || this._unproject(pos);
        }
        if (!startZoomPosition) return this;
        const newZoom = this._calculateNewZoom({
            scale: scale,
            startZoom: startZoom
        });
        const zoomedViewport = this.makeViewport({
            ...this.getViewportProps(),
            zoom: newZoom
        });
        return this._getUpdatedState({
            zoom: newZoom,
            ...zoomedViewport.panByPosition(startZoomPosition, pos)
        });
    }
    zoomEnd() {
        return this._getUpdatedState({
            startZoomPosition: null,
            startZoom: null
        });
    }
    zoomIn(speed = 2) {
        return this._getUpdatedState({
            zoom: this._calculateNewZoom({
                scale: speed
            })
        });
    }
    zoomOut(speed = 2) {
        return this._getUpdatedState({
            zoom: this._calculateNewZoom({
                scale: 1 / speed
            })
        });
    }
    moveLeft(speed = 50) {
        return this._panFromCenter([
            -speed,
            0
        ]);
    }
    moveRight(speed = 50) {
        return this._panFromCenter([
            speed,
            0
        ]);
    }
    moveUp(speed = 50) {
        return this._panFromCenter([
            0,
            -speed
        ]);
    }
    moveDown(speed = 50) {
        return this._panFromCenter([
            0,
            speed
        ]);
    }
    rotateLeft(speed = 15) {
        return this._getUpdatedState({
            rotationOrbit: this.getViewportProps().rotationOrbit - speed
        });
    }
    rotateRight(speed = 15) {
        return this._getUpdatedState({
            rotationOrbit: this.getViewportProps().rotationOrbit + speed
        });
    }
    rotateUp(speed = 10) {
        return this._getUpdatedState({
            rotationX: this.getViewportProps().rotationX - speed
        });
    }
    rotateDown(speed = 10) {
        return this._getUpdatedState({
            rotationX: this.getViewportProps().rotationX + speed
        });
    }
    _unproject(pos) {
        const viewport = this.makeViewport(this.getViewportProps());
        return pos && viewport.unproject(pos);
    }
    _calculateNewZoom({ scale: scale , startZoom: startZoom  }) {
        const { maxZoom: maxZoom , minZoom: minZoom  } = this.getViewportProps();
        if (startZoom === undefined) startZoom = this.getViewportProps().zoom;
        const zoom = startZoom + Math.log2(scale);
        return (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(zoom, minZoom, maxZoom);
    }
    _panFromCenter(offset) {
        const { width: width , height: height , target: target  } = this.getViewportProps();
        return this.pan({
            startPosition: target,
            pos: [
                width / 2 + offset[0],
                height / 2 + offset[1]
            ]
        });
    }
    _getUpdatedState(newProps) {
        return new this.constructor({
            makeViewport: this.makeViewport,
            ...this.getViewportProps(),
            ...this.getState(),
            ...newProps
        });
    }
    applyConstraints(props) {
        const { maxZoom: maxZoom , minZoom: minZoom , zoom: zoom , maxRotationX: maxRotationX , minRotationX: minRotationX , rotationOrbit: rotationOrbit  } = props;
        props.zoom = Array.isArray(zoom) ? [
            (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(zoom[0], minZoom, maxZoom),
            (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(zoom[1], minZoom, maxZoom)
        ] : (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(zoom, minZoom, maxZoom);
        props.rotationX = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(props.rotationX, minRotationX, maxRotationX);
        if (rotationOrbit < -180 || rotationOrbit > 180) props.rotationOrbit = (0, $97790275b37bd567$export$842a2cf37af977e1)(rotationOrbit + 180, 360) - 180;
        return props;
    }
}
class $5b780d9404959b95$export$2e2bcd8739ae039 extends (0, $9a93059544335596$export$2e2bcd8739ae039) {
    constructor(...args){
        super(...args);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "ControllerState", $5b780d9404959b95$export$b17d281980b58efa);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transition", {
            transitionDuration: 300,
            transitionInterpolator: new (0, $be3e6f41f904fd21$export$2e2bcd8739ae039)({
                transitionProps: {
                    compare: [
                        "target",
                        "zoom",
                        "rotationX",
                        "rotationOrbit"
                    ],
                    required: [
                        "target",
                        "zoom"
                    ]
                }
            })
        });
    }
}



class $ab1daa2b350c5b59$var$OrthographicState extends (0, $5b780d9404959b95$export$b17d281980b58efa) {
    constructor(props){
        super(props);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "zoomAxis", void 0);
        this.zoomAxis = props.zoomAxis || "all";
    }
    _calculateNewZoom({ scale: scale , startZoom: startZoom  }) {
        const { maxZoom: maxZoom , minZoom: minZoom  } = this.getViewportProps();
        if (startZoom === undefined) startZoom = this.getViewportProps().zoom;
        let deltaZoom = Math.log2(scale);
        if (Array.isArray(startZoom)) {
            let [newZoomX, newZoomY] = startZoom;
            switch(this.zoomAxis){
                case "X":
                    newZoomX = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(newZoomX + deltaZoom, minZoom, maxZoom);
                    break;
                case "Y":
                    newZoomY = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(newZoomY + deltaZoom, minZoom, maxZoom);
                    break;
                default:
                    let z = Math.min(newZoomX + deltaZoom, newZoomY + deltaZoom);
                    if (z < minZoom) deltaZoom += minZoom - z;
                    z = Math.max(newZoomX + deltaZoom, newZoomY + deltaZoom);
                    if (z > maxZoom) deltaZoom += maxZoom - z;
                    newZoomX += deltaZoom;
                    newZoomY += deltaZoom;
            }
            return [
                newZoomX,
                newZoomY
            ];
        }
        return (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(startZoom + deltaZoom, minZoom, maxZoom);
    }
}
class $ab1daa2b350c5b59$export$2e2bcd8739ae039 extends (0, $9a93059544335596$export$2e2bcd8739ae039) {
    constructor(...args){
        super(...args);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "ControllerState", $ab1daa2b350c5b59$var$OrthographicState);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transition", {
            transitionDuration: 300,
            transitionInterpolator: new (0, $be3e6f41f904fd21$export$2e2bcd8739ae039)([
                "target",
                "zoom"
            ])
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "dragMode", "pan");
    }
    _onPanRotate() {
        return false;
    }
}


class $dc21c358ed1a7258$export$2e2bcd8739ae039 extends (0, $f435da35b0feb027$export$2e2bcd8739ae039) {
    get ViewportType() {
        return 0, $9a3d69191761b73c$export$2e2bcd8739ae039;
    }
    get ControllerType() {
        return 0, $ab1daa2b350c5b59$export$2e2bcd8739ae039;
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($dc21c358ed1a7258$export$2e2bcd8739ae039, "displayName", "OrthographicView");




function $9d65382866ab2814$export$b63ee16b61fa2407({ layers: layers , viewport: viewport  }) {
    let bounds = null;
    for (const layer of layers){
        const subLayerBounds = layer.getBounds();
        if (subLayerBounds) {
            if (bounds) {
                bounds[0] = Math.min(bounds[0], subLayerBounds[0][0]);
                bounds[1] = Math.min(bounds[1], subLayerBounds[0][1]);
                bounds[2] = Math.max(bounds[2], subLayerBounds[1][0]);
                bounds[3] = Math.max(bounds[3], subLayerBounds[1][1]);
            } else bounds = [
                subLayerBounds[0][0],
                subLayerBounds[0][1],
                subLayerBounds[1][0],
                subLayerBounds[1][1]
            ];
        }
    }
    const viewportBounds = viewport.getBounds();
    if (!bounds) return viewportBounds;
    const paddedBounds = $9d65382866ab2814$var$_doubleBounds(viewportBounds);
    if (bounds[2] - bounds[0] < paddedBounds[2] - paddedBounds[0] || bounds[3] - bounds[1] < paddedBounds[3] - paddedBounds[1]) return bounds;
    bounds[0] = Math.max(bounds[0], paddedBounds[0]);
    bounds[1] = Math.max(bounds[1], paddedBounds[1]);
    bounds[2] = Math.min(bounds[2], paddedBounds[2]);
    bounds[3] = Math.min(bounds[3], paddedBounds[3]);
    return bounds;
}
function $9d65382866ab2814$export$c2166da56ef13b51({ bounds: bounds , viewport: viewport , width: width , height: height  }) {
    if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) return null;
    const padding = 1;
    width -= padding * 2;
    height -= padding * 2;
    if (viewport instanceof (0, $4ac7d89cb7f1c4ad$export$2e2bcd8739ae039)) {
        const { longitude: longitude , latitude: latitude , zoom: zoom  } = (0, $7401923064b435ee$export$2e2bcd8739ae039)({
            width: width,
            height: height,
            bounds: [
                [
                    bounds[0],
                    bounds[1]
                ],
                [
                    bounds[2],
                    bounds[3]
                ]
            ],
            maxZoom: 20
        });
        return new (0, $4ac7d89cb7f1c4ad$export$2e2bcd8739ae039)({
            longitude: longitude,
            latitude: latitude,
            zoom: zoom,
            x: padding,
            y: padding,
            width: width,
            height: height
        });
    }
    const center = [
        (bounds[0] + bounds[2]) / 2,
        (bounds[1] + bounds[3]) / 2,
        0
    ];
    const scale = Math.min(20, width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));
    return new (0, $dc21c358ed1a7258$export$2e2bcd8739ae039)({
        x: padding,
        y: padding
    }).makeViewport({
        width: width,
        height: height,
        viewState: {
            target: center,
            zoom: Math.log2(scale)
        }
    });
}
function $9d65382866ab2814$var$_doubleBounds(bounds) {
    const size = {
        x: bounds[2] - bounds[0],
        y: bounds[3] - bounds[1]
    };
    const center = {
        x: bounds[0] + 0.5 * size.x,
        y: bounds[1] + 0.5 * size.y
    };
    return [
        center.x - size.x,
        center.y - size.y,
        center.x + size.x,
        center.y + size.y
    ];
}



class $1db2fd26802cc688$export$2e2bcd8739ae039 {
    constructor(){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", "mask-effect");
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "useInPicking", true);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "dummyMaskMap", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "channels", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "masks", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "maskPass", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "maskMap", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "lastViewport", void 0);
    }
    preRender(gl, { layers: layers , layerFilter: layerFilter , viewports: viewports , onViewportActive: onViewportActive , views: views  }) {
        if (!this.dummyMaskMap) this.dummyMaskMap = new (0, $df31c887249e3faa$export$2e2bcd8739ae039)(gl, {
            width: 1,
            height: 1
        });
        const maskLayers = layers.filter((l)=>l.props.visible && l.props.operation === (0, $b42a5b9aa3b1a41f$export$b56168d831461ce2).MASK);
        if (maskLayers.length === 0) {
            this.masks = null;
            this.channels.length = 0;
            return;
        }
        this.masks = {};
        if (!this.maskPass) {
            this.maskPass = new (0, $b8b5894efb4b3eb3$export$2e2bcd8739ae039)(gl, {
                id: "default-mask"
            });
            this.maskMap = this.maskPass.maskMap;
        }
        const channelMap = this._sortMaskChannels(maskLayers);
        const viewport = viewports[0];
        const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);
        for(const maskId in channelMap)this._renderChannel(channelMap[maskId], {
            layerFilter: layerFilter,
            onViewportActive: onViewportActive,
            views: views,
            viewport: viewport,
            viewportChanged: viewportChanged
        });
    }
    _renderChannel(channelInfo, { layerFilter: layerFilter , onViewportActive: onViewportActive , views: views , viewport: viewport , viewportChanged: viewportChanged  }) {
        const oldChannelInfo = this.channels[channelInfo.index];
        if (!oldChannelInfo) return;
        const maskChanged = channelInfo === oldChannelInfo || oldChannelInfo.layers.length !== channelInfo.layers.length || channelInfo.layerBounds.some((b, i)=>b !== oldChannelInfo.layerBounds[i]);
        channelInfo.bounds = oldChannelInfo.bounds;
        channelInfo.maskBounds = oldChannelInfo.maskBounds;
        this.channels[channelInfo.index] = channelInfo;
        if (maskChanged || viewportChanged) {
            this.lastViewport = viewport;
            channelInfo.bounds = (0, $9d65382866ab2814$export$b63ee16b61fa2407)({
                layers: channelInfo.layers,
                viewport: viewport
            });
            if (maskChanged || !(0, $53a37c44451cea56$export$e9bab7fafb253603)(channelInfo.bounds, oldChannelInfo.bounds)) {
                const { maskPass: maskPass , maskMap: maskMap  } = this;
                const maskViewport = (0, $9d65382866ab2814$export$c2166da56ef13b51)({
                    bounds: channelInfo.bounds,
                    viewport: viewport,
                    width: maskMap.width,
                    height: maskMap.height
                });
                channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [
                    0,
                    0,
                    1,
                    1
                ];
                maskPass.render({
                    pass: "mask",
                    channel: channelInfo.index,
                    layers: channelInfo.layers,
                    layerFilter: layerFilter,
                    viewports: maskViewport ? [
                        maskViewport
                    ] : [],
                    onViewportActive: onViewportActive,
                    views: views,
                    moduleParameters: {
                        devicePixelRatio: 1
                    }
                });
            }
        }
        this.masks[channelInfo.id] = {
            index: channelInfo.index,
            bounds: channelInfo.maskBounds,
            coordinateOrigin: channelInfo.coordinateOrigin,
            coordinateSystem: channelInfo.coordinateSystem
        };
    }
    _sortMaskChannels(maskLayers) {
        const channelMap = {};
        let channelCount = 0;
        for (const layer of maskLayers){
            const { id: id  } = layer.root;
            let channelInfo = channelMap[id];
            if (!channelInfo) {
                if (++channelCount > 4) {
                    (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("Too many mask layers. The max supported is 4")();
                    continue;
                }
                channelInfo = {
                    id: id,
                    index: this.channels.findIndex((c)=>(c === null || c === void 0 ? void 0 : c.id) === id),
                    layers: [],
                    layerBounds: [],
                    coordinateOrigin: layer.root.props.coordinateOrigin,
                    coordinateSystem: layer.root.props.coordinateSystem
                };
                channelMap[id] = channelInfo;
            }
            channelInfo.layers.push(layer);
            channelInfo.layerBounds.push(layer.getBounds());
        }
        for(let i = 0; i < 4; i++){
            const channelInfo = this.channels[i];
            if (!channelInfo || !(channelInfo.id in channelMap)) this.channels[i] = null;
        }
        for(const maskId in channelMap){
            const channelInfo = channelMap[maskId];
            if (channelInfo.index < 0) {
                channelInfo.index = this.channels.findIndex((c)=>!c);
                this.channels[channelInfo.index] = channelInfo;
            }
        }
        return channelMap;
    }
    getModuleParameters() {
        return {
            maskMap: this.masks ? this.maskMap : this.dummyMaskMap,
            maskChannels: this.masks
        };
    }
    cleanup() {
        if (this.dummyMaskMap) {
            this.dummyMaskMap.delete();
            this.dummyMaskMap = undefined;
        }
        if (this.maskPass) {
            this.maskPass.delete();
            this.maskPass = undefined;
            this.maskMap = undefined;
        }
        this.lastViewport = undefined;
        this.masks = null;
        this.channels.length = 0;
    }
}


const $6a78b0e959df691c$var$DEFAULT_LIGHTING_EFFECT = new (0, $70e78b90cf44affe$export$2e2bcd8739ae039)();
class $6a78b0e959df691c$export$2e2bcd8739ae039 {
    constructor(){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "effects", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_internalEffects", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_needsRedraw", void 0);
        this.effects = [];
        this._internalEffects = [];
        this._needsRedraw = "Initial render";
        this.setEffects();
    }
    setProps(props) {
        if ("effects" in props) {
            if (props.effects.length !== this.effects.length || !(0, $70a948cba88c73a3$export$9cb4719e2e525b7a)(props.effects, this.effects)) {
                this.setEffects(props.effects);
                this._needsRedraw = "effects changed";
            }
        }
    }
    needsRedraw(opts = {
        clearRedrawFlags: false
    }) {
        const redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) this._needsRedraw = false;
        return redraw;
    }
    getEffects() {
        return this._internalEffects;
    }
    finalize() {
        this.cleanup();
    }
    setEffects(effects = []) {
        this.cleanup();
        this.effects = effects;
        this._internalEffects = effects.slice();
        this._internalEffects.push(new (0, $1db2fd26802cc688$export$2e2bcd8739ae039)());
        if (!effects.some((effect)=>effect instanceof (0, $70e78b90cf44affe$export$2e2bcd8739ae039))) this._internalEffects.push($6a78b0e959df691c$var$DEFAULT_LIGHTING_EFFECT);
    }
    cleanup() {
        for (const effect of this.effects)effect.cleanup();
        for (const effect1 of this._internalEffects)effect1.cleanup();
        this.effects.length = 0;
        this._internalEffects.length = 0;
    }
}





class $9b7315ba3a82d7e0$export$2e2bcd8739ae039 extends (0, $b1756d854624bf2b$export$2e2bcd8739ae039) {
    shouldDrawLayer(layer) {
        return layer.props.operation === (0, $b42a5b9aa3b1a41f$export$b56168d831461ce2).DRAW;
    }
}







const $7ea8e8d62e8ae777$var$PICKING_PARAMETERS = {
    blendFunc: [
        1,
        0,
        32771,
        0
    ],
    blendEquation: 32774
};
class $7ea8e8d62e8ae777$export$2e2bcd8739ae039 extends (0, $b1756d854624bf2b$export$2e2bcd8739ae039) {
    constructor(...args){
        super(...args);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pickZ", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_colors", null);
    }
    render(props) {
        if (props.pickingFBO) return this._drawPickingBuffer(props);
        return super.render(props);
    }
    _drawPickingBuffer({ layers: layers , layerFilter: layerFilter , views: views , viewports: viewports , onViewportActive: onViewportActive , pickingFBO: pickingFBO , deviceRect: { x: x , y: y , width: width , height: height  } , cullRect: cullRect , effects: effects , pass: pass = "picking" , pickZ: pickZ  }) {
        const gl = this.gl;
        this.pickZ = pickZ;
        const encodedColors = pickZ ? null : {
            byLayer: new Map(),
            byAlpha: []
        };
        this._colors = encodedColors;
        const renderStatus = (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(gl, {
            scissorTest: true,
            scissor: [
                x,
                y,
                width,
                height
            ],
            clearColor: [
                0,
                0,
                0,
                0
            ],
            depthMask: true,
            depthTest: true,
            depthRange: [
                0,
                1
            ],
            colorMask: [
                true,
                true,
                true,
                true
            ],
            ...$7ea8e8d62e8ae777$var$PICKING_PARAMETERS,
            blend: !pickZ
        }, ()=>super.render({
                target: pickingFBO,
                layers: layers,
                layerFilter: layerFilter,
                views: views,
                viewports: viewports,
                onViewportActive: onViewportActive,
                cullRect: cullRect,
                effects: effects === null || effects === void 0 ? void 0 : effects.filter((e)=>e.useInPicking),
                pass: pass
            }));
        this._colors = null;
        const decodePickingColor = encodedColors && $7ea8e8d62e8ae777$var$decodeColor.bind(null, encodedColors);
        return {
            decodePickingColor: decodePickingColor,
            stats: renderStatus
        };
    }
    shouldDrawLayer(layer) {
        return layer.props.pickable && layer.props.operation === (0, $b42a5b9aa3b1a41f$export$b56168d831461ce2).DRAW;
    }
    getModuleParameters() {
        return {
            pickingActive: 1,
            pickingAttribute: this.pickZ,
            lightSources: {}
        };
    }
    getLayerParameters(layer, layerIndex, viewport) {
        const pickParameters = {
            ...layer.props.parameters
        };
        if (!this._colors) pickParameters.blend = false;
        else {
            Object.assign(pickParameters, $7ea8e8d62e8ae777$var$PICKING_PARAMETERS);
            pickParameters.blend = true;
            pickParameters.blendColor = $7ea8e8d62e8ae777$var$encodeColor(this._colors, layer, viewport);
        }
        return pickParameters;
    }
}
function $7ea8e8d62e8ae777$var$encodeColor(encoded, layer, viewport) {
    const { byLayer: byLayer , byAlpha: byAlpha  } = encoded;
    let a;
    let entry = byLayer.get(layer);
    if (entry) {
        entry.viewports.push(viewport);
        a = entry.a;
    } else {
        a = byLayer.size + 1;
        if (a <= 255) {
            entry = {
                a: a,
                layer: layer,
                viewports: [
                    viewport
                ]
            };
            byLayer.set(layer, entry);
            byAlpha[a] = entry;
        } else {
            (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("Too many pickable layers, only picking the first 255")();
            a = 0;
        }
    }
    return [
        0,
        0,
        0,
        a / 255
    ];
}
function $7ea8e8d62e8ae777$var$decodeColor(encoded, pickedColor) {
    const entry = encoded.byAlpha[pickedColor[3]];
    return entry && {
        pickedLayer: entry.layer,
        pickedViewports: entry.viewports,
        pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)
    };
}



const $44be24ae5116c7d5$var$TRACE_RENDER_LAYERS = "deckRenderer.renderLayers";
class $44be24ae5116c7d5$export$2e2bcd8739ae039 {
    constructor(gl){
        this.gl = gl;
        this.layerFilter = null;
        this.drawPickingColors = false;
        this.drawLayersPass = new (0, $9b7315ba3a82d7e0$export$2e2bcd8739ae039)(gl);
        this.pickLayersPass = new (0, $7ea8e8d62e8ae777$export$2e2bcd8739ae039)(gl);
        this.renderCount = 0;
        this._needsRedraw = "Initial render";
        this.renderBuffers = [];
        this.lastPostProcessEffect = null;
    }
    setProps(props) {
        if ("layerFilter" in props && this.layerFilter !== props.layerFilter) {
            this.layerFilter = props.layerFilter;
            this._needsRedraw = "layerFilter changed";
        }
        if ("drawPickingColors" in props && this.drawPickingColors !== props.drawPickingColors) {
            this.drawPickingColors = props.drawPickingColors;
            this._needsRedraw = "drawPickingColors changed";
        }
    }
    renderLayers(opts) {
        const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
        opts.layerFilter = opts.layerFilter || this.layerFilter;
        opts.effects = opts.effects || [];
        opts.target = opts.target || (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039).getDefaultFramebuffer(this.gl);
        this._preRender(opts.effects, opts);
        const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : opts.target;
        const renderStats = layerPass.render({
            ...opts,
            target: outputBuffer
        });
        this._postRender(opts.effects, opts);
        this.renderCount++;
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($44be24ae5116c7d5$var$TRACE_RENDER_LAYERS, this, renderStats, opts);
    }
    needsRedraw(opts = {
        clearRedrawFlags: false
    }) {
        const redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) this._needsRedraw = false;
        return redraw;
    }
    finalize() {
        const { renderBuffers: renderBuffers  } = this;
        for (const buffer of renderBuffers)buffer.delete();
        renderBuffers.length = 0;
    }
    _preRender(effects, opts) {
        let lastPostProcessEffect = null;
        for (const effect of effects){
            effect.preRender(this.gl, opts);
            if (effect.postRender) lastPostProcessEffect = effect;
        }
        if (lastPostProcessEffect) this._resizeRenderBuffers();
        this.lastPostProcessEffect = lastPostProcessEffect;
    }
    _resizeRenderBuffers() {
        const { renderBuffers: renderBuffers  } = this;
        if (renderBuffers.length === 0) renderBuffers.push(new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(this.gl), new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(this.gl));
        for (const buffer of renderBuffers)buffer.resize();
    }
    _postRender(effects, opts) {
        const { renderBuffers: renderBuffers  } = this;
        const params = {
            inputBuffer: renderBuffers[0],
            swapBuffer: renderBuffers[1],
            target: null
        };
        for (const effect of effects)if (effect.postRender) {
            if (effect === this.lastPostProcessEffect) {
                params.target = opts.target;
                effect.postRender(this.gl, params);
                break;
            }
            const buffer = effect.postRender(this.gl, params);
            params.inputBuffer = buffer;
            params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];
        }
    }
}






const $7bec4d100b868a63$var$NO_PICKED_OBJECT = {
    pickedColor: null,
    pickedObjectIndex: -1
};
function $7bec4d100b868a63$export$e05a34ecba4eb9c3({ pickedColors: pickedColors , decodePickingColor: decodePickingColor , deviceX: deviceX , deviceY: deviceY , deviceRadius: deviceRadius , deviceRect: deviceRect  }) {
    const { x: x , y: y , width: width , height: height  } = deviceRect;
    let minSquareDistanceToCenter = deviceRadius * deviceRadius;
    let closestPixelIndex = -1;
    let i = 0;
    for(let row = 0; row < height; row++){
        const dy = row + y - deviceY;
        const dy2 = dy * dy;
        if (dy2 > minSquareDistanceToCenter) i += 4 * width;
        else for(let col = 0; col < width; col++){
            const pickedLayerIndex = pickedColors[i + 3] - 1;
            if (pickedLayerIndex >= 0) {
                const dx = col + x - deviceX;
                const d2 = dx * dx + dy2;
                if (d2 <= minSquareDistanceToCenter) {
                    minSquareDistanceToCenter = d2;
                    closestPixelIndex = i;
                }
            }
            i += 4;
        }
    }
    if (closestPixelIndex >= 0) {
        const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
        const pickedObject = decodePickingColor(pickedColor);
        if (pickedObject) {
            const dy = Math.floor(closestPixelIndex / 4 / width);
            const dx = closestPixelIndex / 4 - dy * width;
            return {
                ...pickedObject,
                pickedColor: pickedColor,
                pickedX: x + dx,
                pickedY: y + dy
            };
        }
        (0, $146cba582e8c799f$export$2e2bcd8739ae039).error("Picked non-existent layer. Is picking buffer corrupt?")();
    }
    return $7bec4d100b868a63$var$NO_PICKED_OBJECT;
}
function $7bec4d100b868a63$export$f950d2b96083ede4({ pickedColors: pickedColors , decodePickingColor: decodePickingColor  }) {
    const uniqueColors = new Map();
    if (pickedColors) for(let i = 0; i < pickedColors.length; i += 4){
        const pickedLayerIndex = pickedColors[i + 3] - 1;
        if (pickedLayerIndex >= 0) {
            const pickedColor = pickedColors.slice(i, i + 4);
            const colorKey = pickedColor.join(",");
            if (!uniqueColors.has(colorKey)) {
                const pickedObject = decodePickingColor(pickedColor);
                if (pickedObject) uniqueColors.set(colorKey, {
                    ...pickedObject,
                    color: pickedColor
                });
                else (0, $146cba582e8c799f$export$2e2bcd8739ae039).error("Picked non-existent layer. Is picking buffer corrupt?")();
            }
        }
    }
    return Array.from(uniqueColors.values());
}


function $52af7c9fc3561b1c$export$ac275af7ad62fedf({ pickInfo: pickInfo , viewports: viewports , pixelRatio: pixelRatio , x: x , y: y , z: z  }) {
    let pickedViewport = viewports[0];
    if (viewports.length > 1) pickedViewport = $52af7c9fc3561b1c$var$getViewportFromCoordinates((pickInfo === null || pickInfo === void 0 ? void 0 : pickInfo.pickedViewports) || viewports, {
        x: x,
        y: y
    });
    let coordinate;
    if (pickedViewport) {
        const point = [
            x - pickedViewport.x,
            y - pickedViewport.y
        ];
        if (z !== undefined) point[2] = z;
        coordinate = pickedViewport.unproject(point);
    }
    return {
        color: null,
        layer: null,
        viewport: pickedViewport,
        index: -1,
        picked: false,
        x: x,
        y: y,
        pixel: [
            x,
            y
        ],
        coordinate: coordinate,
        devicePixel: pickInfo && "pickedX" in pickInfo ? [
            pickInfo.pickedX,
            pickInfo.pickedY
        ] : undefined,
        pixelRatio: pixelRatio
    };
}
function $52af7c9fc3561b1c$export$5169f687738446ff(opts) {
    const { pickInfo: pickInfo , lastPickedInfo: lastPickedInfo , mode: mode , layers: layers  } = opts;
    const { pickedColor: pickedColor , pickedLayer: pickedLayer , pickedObjectIndex: pickedObjectIndex  } = pickInfo;
    const affectedLayers = pickedLayer ? [
        pickedLayer
    ] : [];
    if (mode === "hover") {
        const lastPickedPixelIndex = lastPickedInfo.index;
        const lastPickedLayerId = lastPickedInfo.layerId;
        const pickedLayerId = pickedLayer ? pickedLayer.props.id : null;
        if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedPixelIndex) {
            if (pickedLayerId !== lastPickedLayerId) {
                const lastPickedLayer = layers.find((layer)=>layer.props.id === lastPickedLayerId);
                if (lastPickedLayer) affectedLayers.unshift(lastPickedLayer);
            }
            lastPickedInfo.layerId = pickedLayerId;
            lastPickedInfo.index = pickedObjectIndex;
            lastPickedInfo.info = null;
        }
    }
    const baseInfo = $52af7c9fc3561b1c$export$ac275af7ad62fedf(opts);
    const infos = new Map();
    infos.set(null, baseInfo);
    affectedLayers.forEach((layer)=>{
        let info = {
            ...baseInfo
        };
        if (layer === pickedLayer) {
            info.color = pickedColor;
            info.index = pickedObjectIndex;
            info.picked = true;
        }
        info = $52af7c9fc3561b1c$export$8ad0e0d5dfb9b541({
            layer: layer,
            info: info,
            mode: mode
        });
        const rootLayer = info.layer;
        if (layer === pickedLayer && mode === "hover") lastPickedInfo.info = info;
        infos.set(rootLayer.id, info);
        if (mode === "hover") rootLayer.updateAutoHighlight(info);
    });
    return infos;
}
function $52af7c9fc3561b1c$export$8ad0e0d5dfb9b541({ layer: layer , info: info , mode: mode  }) {
    while(layer && info){
        const sourceLayer = info.layer || null;
        info.sourceLayer = sourceLayer;
        info.layer = layer;
        info = layer.getPickingInfo({
            info: info,
            mode: mode,
            sourceLayer: sourceLayer
        });
        layer = layer.parent;
    }
    return info;
}
function $52af7c9fc3561b1c$var$getViewportFromCoordinates(viewports, pixel) {
    for(let i = viewports.length - 1; i >= 0; i--){
        const viewport = viewports[i];
        if (viewport.containsPixel(pixel)) return viewport;
    }
    return viewports[0];
}


class $846591e5a404f643$export$2e2bcd8739ae039 {
    constructor(gl){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "gl", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pickingFBO", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "depthFBO", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pickLayersPass", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "layerFilter", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "lastPickedInfo", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_pickable", true);
        this.gl = gl;
        this.pickLayersPass = new (0, $7ea8e8d62e8ae777$export$2e2bcd8739ae039)(gl);
        this.lastPickedInfo = {
            index: -1,
            layerId: null,
            info: null
        };
    }
    setProps(props) {
        if ("layerFilter" in props) this.layerFilter = props.layerFilter;
        if ("_pickable" in props) this._pickable = props._pickable;
    }
    finalize() {
        if (this.pickingFBO) this.pickingFBO.delete();
        if (this.depthFBO) {
            this.depthFBO.color.delete();
            this.depthFBO.delete();
        }
    }
    pickObject(opts) {
        return this._pickClosestObject(opts);
    }
    pickObjects(opts) {
        return this._pickVisibleObjects(opts);
    }
    getLastPickedObject({ x: x , y: y , layers: layers , viewports: viewports  }, lastPickedInfo = this.lastPickedInfo.info) {
        const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
        const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;
        const layer = lastPickedLayerId ? layers.find((l)=>l.id === lastPickedLayerId) : null;
        const viewport = lastPickedViewportId && viewports.find((v)=>v.id === lastPickedViewportId) || viewports[0];
        const coordinate = viewport && viewport.unproject([
            x - viewport.x,
            y - viewport.y
        ]);
        const info = {
            x: x,
            y: y,
            viewport: viewport,
            coordinate: coordinate,
            layer: layer
        };
        return {
            ...lastPickedInfo,
            ...info
        };
    }
    _resizeBuffer() {
        var _this$pickingFBO, _this$depthFBO;
        const { gl: gl  } = this;
        if (!this.pickingFBO) {
            this.pickingFBO = new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(gl);
            if ((0, $a0e9e15bc57c4882$export$2e2bcd8739ae039).isSupported(gl, {
                colorBufferFloat: true
            })) {
                const depthFBO = new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(gl);
                depthFBO.attach({
                    [36064]: new (0, $df31c887249e3faa$export$2e2bcd8739ae039)(gl, {
                        format: (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? 34836 : 6408,
                        type: 5126
                    })
                });
                this.depthFBO = depthFBO;
            }
        }
        (_this$pickingFBO = this.pickingFBO) === null || _this$pickingFBO === void 0 || _this$pickingFBO.resize({
            width: gl.canvas.width,
            height: gl.canvas.height
        });
        (_this$depthFBO = this.depthFBO) === null || _this$depthFBO === void 0 || _this$depthFBO.resize({
            width: gl.canvas.width,
            height: gl.canvas.height
        });
    }
    _getPickable(layers) {
        if (this._pickable === false) return null;
        const pickableLayers = layers.filter((layer)=>layer.isPickable() && !layer.isComposite);
        return pickableLayers.length ? pickableLayers : null;
    }
    _pickClosestObject({ layers: layers , views: views , viewports: viewports , x: x , y: y , radius: radius = 0 , depth: depth = 1 , mode: mode = "query" , unproject3D: unproject3D , onViewportActive: onViewportActive , effects: effects  }) {
        const pickableLayers = this._getPickable(layers);
        const pixelRatio = (0, $294e503c6396a3ff$export$df40057290e74703)(this.gl);
        if (!pickableLayers) return {
            result: [],
            emptyInfo: (0, $52af7c9fc3561b1c$export$ac275af7ad62fedf)({
                viewports: viewports,
                x: x,
                y: y,
                pixelRatio: pixelRatio
            })
        };
        this._resizeBuffer();
        const devicePixelRange = (0, $294e503c6396a3ff$export$af080a4e21b7825c)(this.gl, [
            x,
            y
        ], true);
        const devicePixel = [
            devicePixelRange.x + Math.floor(devicePixelRange.width / 2),
            devicePixelRange.y + Math.floor(devicePixelRange.height / 2)
        ];
        const deviceRadius = Math.round(radius * pixelRatio);
        const { width: width , height: height  } = this.pickingFBO;
        const deviceRect = this._getPickingRect({
            deviceX: devicePixel[0],
            deviceY: devicePixel[1],
            deviceRadius: deviceRadius,
            deviceWidth: width,
            deviceHeight: height
        });
        const cullRect = {
            x: x - radius,
            y: y - radius,
            width: radius * 2 + 1,
            height: radius * 2 + 1
        };
        let infos;
        const result = [];
        const affectedLayers = new Set();
        for(let i = 0; i < depth; i++){
            let pickInfo;
            if (deviceRect) {
                const pickedResult = this._drawAndSample({
                    layers: pickableLayers,
                    views: views,
                    viewports: viewports,
                    onViewportActive: onViewportActive,
                    deviceRect: deviceRect,
                    cullRect: cullRect,
                    effects: effects,
                    pass: "picking:".concat(mode)
                });
                pickInfo = (0, $7bec4d100b868a63$export$e05a34ecba4eb9c3)({
                    ...pickedResult,
                    deviceX: devicePixel[0],
                    deviceY: devicePixel[1],
                    deviceRadius: deviceRadius,
                    deviceRect: deviceRect
                });
            } else pickInfo = {
                pickedColor: null,
                pickedObjectIndex: -1
            };
            let z;
            if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
                const pickedResultPass2 = this._drawAndSample({
                    layers: [
                        pickInfo.pickedLayer
                    ],
                    views: views,
                    viewports: viewports,
                    onViewportActive: onViewportActive,
                    deviceRect: {
                        x: pickInfo.pickedX,
                        y: pickInfo.pickedY,
                        width: 1,
                        height: 1
                    },
                    cullRect: cullRect,
                    effects: effects,
                    pass: "picking:".concat(mode, ":z")
                }, true);
                z = pickedResultPass2.pickedColors[0];
            }
            if (pickInfo.pickedLayer && i + 1 < depth) {
                affectedLayers.add(pickInfo.pickedLayer);
                pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);
            }
            infos = (0, $52af7c9fc3561b1c$export$5169f687738446ff)({
                pickInfo: pickInfo,
                lastPickedInfo: this.lastPickedInfo,
                mode: mode,
                layers: pickableLayers,
                viewports: viewports,
                x: x,
                y: y,
                z: z,
                pixelRatio: pixelRatio
            });
            for (const info of infos.values())if (info.layer) result.push(info);
            if (!pickInfo.pickedColor) break;
        }
        for (const layer of affectedLayers)layer.restorePickingColors();
        return {
            result: result,
            emptyInfo: infos.get(null)
        };
    }
    _pickVisibleObjects({ layers: layers , views: views , viewports: viewports , x: x , y: y , width: width = 1 , height: height = 1 , mode: mode = "query" , maxObjects: maxObjects = null , onViewportActive: onViewportActive , effects: effects  }) {
        const pickableLayers = this._getPickable(layers);
        if (!pickableLayers) return [];
        this._resizeBuffer();
        const pixelRatio = (0, $294e503c6396a3ff$export$df40057290e74703)(this.gl);
        const leftTop = (0, $294e503c6396a3ff$export$af080a4e21b7825c)(this.gl, [
            x,
            y
        ], true);
        const deviceLeft = leftTop.x;
        const deviceTop = leftTop.y + leftTop.height;
        const rightBottom = (0, $294e503c6396a3ff$export$af080a4e21b7825c)(this.gl, [
            x + width,
            y + height
        ], true);
        const deviceRight = rightBottom.x + rightBottom.width;
        const deviceBottom = rightBottom.y;
        const deviceRect = {
            x: deviceLeft,
            y: deviceBottom,
            width: deviceRight - deviceLeft,
            height: deviceTop - deviceBottom
        };
        const pickedResult = this._drawAndSample({
            layers: pickableLayers,
            views: views,
            viewports: viewports,
            onViewportActive: onViewportActive,
            deviceRect: deviceRect,
            cullRect: {
                x: x,
                y: y,
                width: width,
                height: height
            },
            effects: effects,
            pass: "picking:".concat(mode)
        });
        const pickInfos = (0, $7bec4d100b868a63$export$f950d2b96083ede4)(pickedResult);
        const uniqueInfos = new Map();
        const isMaxObjects = Number.isFinite(maxObjects);
        for(let i = 0; i < pickInfos.length; i++){
            if (isMaxObjects && maxObjects && uniqueInfos.size >= maxObjects) break;
            const pickInfo = pickInfos[i];
            let info = {
                color: pickInfo.pickedColor,
                layer: null,
                index: pickInfo.pickedObjectIndex,
                picked: true,
                x: x,
                y: y,
                pixelRatio: pixelRatio
            };
            info = (0, $52af7c9fc3561b1c$export$8ad0e0d5dfb9b541)({
                layer: pickInfo.pickedLayer,
                info: info,
                mode: mode
            });
            if (!uniqueInfos.has(info.object)) uniqueInfos.set(info.object, info);
        }
        return Array.from(uniqueInfos.values());
    }
    _drawAndSample({ layers: layers , views: views , viewports: viewports , onViewportActive: onViewportActive , deviceRect: deviceRect , cullRect: cullRect , effects: effects , pass: pass  }, pickZ = false) {
        const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
        const { decodePickingColor: decodePickingColor  } = this.pickLayersPass.render({
            layers: layers,
            layerFilter: this.layerFilter,
            views: views,
            viewports: viewports,
            onViewportActive: onViewportActive,
            pickingFBO: pickingFBO,
            deviceRect: deviceRect,
            cullRect: cullRect,
            effects: effects,
            pass: pass,
            pickZ: pickZ
        });
        const { x: x , y: y , width: width , height: height  } = deviceRect;
        const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
        (0, $c192e756436d1779$export$f9f2f48e7f9faaa5)(pickingFBO, {
            sourceX: x,
            sourceY: y,
            sourceWidth: width,
            sourceHeight: height,
            target: pickedColors
        });
        return {
            pickedColors: pickedColors,
            decodePickingColor: decodePickingColor
        };
    }
    _getPickingRect({ deviceX: deviceX , deviceY: deviceY , deviceRadius: deviceRadius , deviceWidth: deviceWidth , deviceHeight: deviceHeight  }) {
        const x = Math.max(0, deviceX - deviceRadius);
        const y = Math.max(0, deviceY - deviceRadius);
        const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;
        const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;
        if (width <= 0 || height <= 0) return null;
        return {
            x: x,
            y: y,
            width: width,
            height: height
        };
    }
}



const $0ce0aac1c3cdf79a$var$defaultStyle = {
    zIndex: "1",
    position: "absolute",
    pointerEvents: "none",
    color: "#a0a7b4",
    backgroundColor: "#29323c",
    padding: "10px",
    top: "0",
    left: "0",
    display: "none"
};
class $0ce0aac1c3cdf79a$export$2e2bcd8739ae039 {
    constructor(canvas){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "el", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "isVisible", false);
        const canvasParent = canvas.parentElement;
        if (canvasParent) {
            this.el = document.createElement("div");
            this.el.className = "deck-tooltip";
            Object.assign(this.el.style, $0ce0aac1c3cdf79a$var$defaultStyle);
            canvasParent.appendChild(this.el);
        }
    }
    setTooltip(displayInfo, x, y) {
        const el = this.el;
        if (!el) return;
        if (typeof displayInfo === "string") el.innerText = displayInfo;
        else if (!displayInfo) {
            this.isVisible = false;
            el.style.display = "none";
            return;
        } else {
            if (displayInfo.text) el.innerText = displayInfo.text;
            if (displayInfo.html) el.innerHTML = displayInfo.html;
            if (displayInfo.className) el.className = displayInfo.className;
            Object.assign(el.style, displayInfo.style);
        }
        this.isVisible = true;
        el.style.display = "block";
        el.style.transform = "translate(".concat(x, "px, ").concat(y, "px)");
    }
    remove() {
        if (this.el) {
            this.el.remove();
            this.el = null;
        }
    }
}






const $6ac05cc9715692e0$export$a4ad2735b021c132 = "3.2.5";




const { _parseImageNode: $aa0764cc8dcd9b15$var$_parseImageNode  } = globalThis;
const $aa0764cc8dcd9b15$var$IMAGE_SUPPORTED = typeof Image !== "undefined";
const $aa0764cc8dcd9b15$var$IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
const $aa0764cc8dcd9b15$var$NODE_IMAGE_SUPPORTED = Boolean($aa0764cc8dcd9b15$var$_parseImageNode);
const $aa0764cc8dcd9b15$var$DATA_SUPPORTED = (0, $4684b3280a916bc3$export$4e09c449d6c407f7) ? true : $aa0764cc8dcd9b15$var$NODE_IMAGE_SUPPORTED;
function $aa0764cc8dcd9b15$export$b6d6c5f9d0d9c212(type) {
    switch(type){
        case "auto":
            return $aa0764cc8dcd9b15$var$IMAGE_BITMAP_SUPPORTED || $aa0764cc8dcd9b15$var$IMAGE_SUPPORTED || $aa0764cc8dcd9b15$var$DATA_SUPPORTED;
        case "imagebitmap":
            return $aa0764cc8dcd9b15$var$IMAGE_BITMAP_SUPPORTED;
        case "image":
            return $aa0764cc8dcd9b15$var$IMAGE_SUPPORTED;
        case "data":
            return $aa0764cc8dcd9b15$var$DATA_SUPPORTED;
        default:
            throw new Error("@loaders.gl/images: image ".concat(type, " not supported in this environment"));
    }
}
function $aa0764cc8dcd9b15$export$2b0a859319ebc411() {
    if ($aa0764cc8dcd9b15$var$IMAGE_BITMAP_SUPPORTED) return "imagebitmap";
    if ($aa0764cc8dcd9b15$var$IMAGE_SUPPORTED) return "image";
    if ($aa0764cc8dcd9b15$var$DATA_SUPPORTED) return "data";
    throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}


function $da2179cf94f5991c$export$fb85bc5d6d9ef19b(image) {
    return Boolean($da2179cf94f5991c$var$getImageTypeOrNull(image));
}
function $da2179cf94f5991c$export$2d0b7dd5ef39c509(image) {
    switch($da2179cf94f5991c$export$b8e3c51900b5ca88(image)){
        case "imagebitmap":
            image.close();
            break;
        default:
    }
}
function $da2179cf94f5991c$export$b8e3c51900b5ca88(image) {
    const format = $da2179cf94f5991c$var$getImageTypeOrNull(image);
    if (!format) throw new Error("Not an image");
    return format;
}
function $da2179cf94f5991c$export$ada5537b2c061996(image) {
    return $da2179cf94f5991c$export$d93c68e129326488(image);
}
function $da2179cf94f5991c$export$d93c68e129326488(image) {
    switch($da2179cf94f5991c$export$b8e3c51900b5ca88(image)){
        case "data":
            return image;
        case "image":
        case "imagebitmap":
            const canvas = document.createElement("canvas");
            const context = canvas.getContext("2d");
            if (!context) throw new Error("getImageData");
            canvas.width = image.width;
            canvas.height = image.height;
            context.drawImage(image, 0, 0);
            return context.getImageData(0, 0, image.width, image.height);
        default:
            throw new Error("getImageData");
    }
}
function $da2179cf94f5991c$var$getImageTypeOrNull(image) {
    if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) return "imagebitmap";
    if (typeof Image !== "undefined" && image instanceof Image) return "image";
    if (image && typeof image === "object" && image.data && image.width && image.height) return "data";
    return null;
}


const $015d5caac190482a$var$SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
const $015d5caac190482a$var$SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
function $015d5caac190482a$export$165b39ed277223c2(url) {
    return url && ($015d5caac190482a$var$SVG_DATA_URL_PATTERN.test(url) || $015d5caac190482a$var$SVG_URL_PATTERN.test(url));
}
function $015d5caac190482a$export$d1c0f60cd342a54(arrayBuffer, url) {
    if ($015d5caac190482a$export$165b39ed277223c2(url)) {
        const textDecoder = new TextDecoder();
        let xmlText = textDecoder.decode(arrayBuffer);
        try {
            if (typeof unescape === "function" && typeof encodeURIComponent === "function") xmlText = unescape(encodeURIComponent(xmlText));
        } catch (error) {
            throw new Error(error.message);
        }
        const src = "data:image/svg+xml;base64,".concat(btoa(xmlText));
        return src;
    }
    return $015d5caac190482a$export$37610328929d7521(arrayBuffer, url);
}
function $015d5caac190482a$export$37610328929d7521(arrayBuffer, url) {
    if ($015d5caac190482a$export$165b39ed277223c2(url)) throw new Error("SVG cannot be parsed directly to imagebitmap");
    return new Blob([
        new Uint8Array(arrayBuffer)
    ]);
}


async function $1d0090429568bf29$export$2e2bcd8739ae039(arrayBuffer, options, url) {
    const blobOrDataUrl = (0, $015d5caac190482a$export$d1c0f60cd342a54)(arrayBuffer, url);
    const URL = self.URL || self.webkitURL;
    const objectUrl = typeof blobOrDataUrl !== "string" && URL.createObjectURL(blobOrDataUrl);
    try {
        return await $1d0090429568bf29$export$2f2a1d2adfedb145(objectUrl || blobOrDataUrl, options);
    } finally{
        if (objectUrl) URL.revokeObjectURL(objectUrl);
    }
}
async function $1d0090429568bf29$export$2f2a1d2adfedb145(url, options) {
    const image = new Image();
    image.src = url;
    if (options.image && options.image.decode && image.decode) {
        await image.decode();
        return image;
    }
    return await new Promise((resolve, reject)=>{
        try {
            image.onload = ()=>resolve(image);
            image.onerror = (err)=>reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
        } catch (error) {
            reject(error);
        }
    });
}




const $a8272a33ac9d2a51$var$EMPTY_OBJECT = {};
let $a8272a33ac9d2a51$var$imagebitmapOptionsSupported = true;
async function $a8272a33ac9d2a51$export$2e2bcd8739ae039(arrayBuffer, options, url) {
    let blob;
    if ((0, $015d5caac190482a$export$165b39ed277223c2)(url)) {
        const image = await (0, $1d0090429568bf29$export$2e2bcd8739ae039)(arrayBuffer, options, url);
        blob = image;
    } else blob = (0, $015d5caac190482a$export$37610328929d7521)(arrayBuffer, url);
    const imagebitmapOptions = options && options.imagebitmap;
    return await $a8272a33ac9d2a51$var$safeCreateImageBitmap(blob, imagebitmapOptions);
}
async function $a8272a33ac9d2a51$var$safeCreateImageBitmap(blob, imagebitmapOptions = null) {
    if ($a8272a33ac9d2a51$var$isEmptyObject(imagebitmapOptions) || !$a8272a33ac9d2a51$var$imagebitmapOptionsSupported) imagebitmapOptions = null;
    if (imagebitmapOptions) try {
        return await createImageBitmap(blob, imagebitmapOptions);
    } catch (error) {
        console.warn(error);
        $a8272a33ac9d2a51$var$imagebitmapOptionsSupported = false;
    }
    return await createImageBitmap(blob);
}
function $a8272a33ac9d2a51$var$isEmptyObject(object) {
    for(const key in object || $a8272a33ac9d2a51$var$EMPTY_OBJECT)return false;
    return true;
}



const $b08c3d5f2810bbd6$var$BIG_ENDIAN = false;
const $b08c3d5f2810bbd6$var$LITTLE_ENDIAN = true;
function $b08c3d5f2810bbd6$export$6dae8baa11df6159(binaryData) {
    const dataView = $b08c3d5f2810bbd6$var$toDataView(binaryData);
    return $b08c3d5f2810bbd6$var$getPngMetadata(dataView) || $b08c3d5f2810bbd6$var$getJpegMetadata(dataView) || $b08c3d5f2810bbd6$var$getGifMetadata(dataView) || $b08c3d5f2810bbd6$export$1e6b8ff544bd73cb(dataView);
}
function $b08c3d5f2810bbd6$var$getPngMetadata(binaryData) {
    const dataView = $b08c3d5f2810bbd6$var$toDataView(binaryData);
    const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, $b08c3d5f2810bbd6$var$BIG_ENDIAN) === 0x89504e47;
    if (!isPng) return null;
    return {
        mimeType: "image/png",
        width: dataView.getUint32(16, $b08c3d5f2810bbd6$var$BIG_ENDIAN),
        height: dataView.getUint32(20, $b08c3d5f2810bbd6$var$BIG_ENDIAN)
    };
}
function $b08c3d5f2810bbd6$var$getGifMetadata(binaryData) {
    const dataView = $b08c3d5f2810bbd6$var$toDataView(binaryData);
    const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, $b08c3d5f2810bbd6$var$BIG_ENDIAN) === 0x47494638;
    if (!isGif) return null;
    return {
        mimeType: "image/gif",
        width: dataView.getUint16(6, $b08c3d5f2810bbd6$var$LITTLE_ENDIAN),
        height: dataView.getUint16(8, $b08c3d5f2810bbd6$var$LITTLE_ENDIAN)
    };
}
function $b08c3d5f2810bbd6$export$1e6b8ff544bd73cb(binaryData) {
    const dataView = $b08c3d5f2810bbd6$var$toDataView(binaryData);
    const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, $b08c3d5f2810bbd6$var$BIG_ENDIAN) === 0x424d && dataView.getUint32(2, $b08c3d5f2810bbd6$var$LITTLE_ENDIAN) === dataView.byteLength;
    if (!isBmp) return null;
    return {
        mimeType: "image/bmp",
        width: dataView.getUint32(18, $b08c3d5f2810bbd6$var$LITTLE_ENDIAN),
        height: dataView.getUint32(22, $b08c3d5f2810bbd6$var$LITTLE_ENDIAN)
    };
}
function $b08c3d5f2810bbd6$var$getJpegMetadata(binaryData) {
    const dataView = $b08c3d5f2810bbd6$var$toDataView(binaryData);
    const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, $b08c3d5f2810bbd6$var$BIG_ENDIAN) === 0xffd8 && dataView.getUint8(2) === 0xff;
    if (!isJpeg) return null;
    const { tableMarkers: tableMarkers , sofMarkers: sofMarkers  } = $b08c3d5f2810bbd6$var$getJpegMarkers();
    let i = 2;
    while(i + 9 < dataView.byteLength){
        const marker = dataView.getUint16(i, $b08c3d5f2810bbd6$var$BIG_ENDIAN);
        if (sofMarkers.has(marker)) return {
            mimeType: "image/jpeg",
            height: dataView.getUint16(i + 5, $b08c3d5f2810bbd6$var$BIG_ENDIAN),
            width: dataView.getUint16(i + 7, $b08c3d5f2810bbd6$var$BIG_ENDIAN)
        };
        if (!tableMarkers.has(marker)) return null;
        i += 2;
        i += dataView.getUint16(i, $b08c3d5f2810bbd6$var$BIG_ENDIAN);
    }
    return null;
}
function $b08c3d5f2810bbd6$var$getJpegMarkers() {
    const tableMarkers = new Set([
        0xffdb,
        0xffc4,
        0xffcc,
        0xffdd,
        0xfffe
    ]);
    for(let i = 0xffe0; i < 0xfff0; ++i)tableMarkers.add(i);
    const sofMarkers = new Set([
        0xffc0,
        0xffc1,
        0xffc2,
        0xffc3,
        0xffc5,
        0xffc6,
        0xffc7,
        0xffc9,
        0xffca,
        0xffcb,
        0xffcd,
        0xffce,
        0xffcf,
        0xffde
    ]);
    return {
        tableMarkers: tableMarkers,
        sofMarkers: sofMarkers
    };
}
function $b08c3d5f2810bbd6$var$toDataView(data) {
    if (data instanceof DataView) return data;
    if (ArrayBuffer.isView(data)) return new DataView(data.buffer);
    if (data instanceof ArrayBuffer) return new DataView(data);
    throw new Error("toDataView");
}


async function $5992765fc8a62fc2$export$2e2bcd8739ae039(arrayBuffer, options) {
    const { mimeType: mimeType  } = (0, $b08c3d5f2810bbd6$export$6dae8baa11df6159)(arrayBuffer) || {};
    const _parseImageNode = globalThis._parseImageNode;
    (0, $e2d3345494943a51$export$a7a9523472993e97)(_parseImageNode);
    return await _parseImageNode(arrayBuffer, mimeType);
}


async function $cd314c20e1568fab$export$2e2bcd8739ae039(arrayBuffer, options, context) {
    options = options || {};
    const imageOptions = options.image || {};
    const imageType = imageOptions.type || "auto";
    const { url: url  } = context || {};
    const loadType = $cd314c20e1568fab$var$getLoadableImageType(imageType);
    let image;
    switch(loadType){
        case "imagebitmap":
            image = await (0, $a8272a33ac9d2a51$export$2e2bcd8739ae039)(arrayBuffer, options, url);
            break;
        case "image":
            image = await (0, $1d0090429568bf29$export$2e2bcd8739ae039)(arrayBuffer, options, url);
            break;
        case "data":
            image = await (0, $5992765fc8a62fc2$export$2e2bcd8739ae039)(arrayBuffer, options);
            break;
        default:
            (0, $e2d3345494943a51$export$a7a9523472993e97)(false);
    }
    if (imageType === "data") image = (0, $da2179cf94f5991c$export$d93c68e129326488)(image);
    return image;
}
function $cd314c20e1568fab$var$getLoadableImageType(type) {
    switch(type){
        case "auto":
        case "data":
            return (0, $aa0764cc8dcd9b15$export$2b0a859319ebc411)();
        default:
            (0, $aa0764cc8dcd9b15$export$b6d6c5f9d0d9c212)(type);
            return type;
    }
}



const $c5b13686f235cd74$var$EXTENSIONS = [
    "png",
    "jpg",
    "jpeg",
    "gif",
    "webp",
    "bmp",
    "ico",
    "svg"
];
const $c5b13686f235cd74$var$MIME_TYPES = [
    "image/png",
    "image/jpeg",
    "image/gif",
    "image/webp",
    "image/bmp",
    "image/vnd.microsoft.icon",
    "image/svg+xml"
];
const $c5b13686f235cd74$var$DEFAULT_IMAGE_LOADER_OPTIONS = {
    image: {
        type: "auto",
        decode: true
    }
};
const $c5b13686f235cd74$export$8905ce1c7a2464a1 = {
    id: "image",
    module: "images",
    name: "Images",
    version: (0, $6ac05cc9715692e0$export$a4ad2735b021c132),
    mimeTypes: $c5b13686f235cd74$var$MIME_TYPES,
    extensions: $c5b13686f235cd74$var$EXTENSIONS,
    parse: (0, $cd314c20e1568fab$export$2e2bcd8739ae039),
    tests: [
        (arrayBuffer)=>Boolean((0, $b08c3d5f2810bbd6$export$6dae8baa11df6159)(new DataView(arrayBuffer)))
    ],
    options: $c5b13686f235cd74$var$DEFAULT_IMAGE_LOADER_OPTIONS
};
const $c5b13686f235cd74$export$249a824650b4f45f = $c5b13686f235cd74$export$8905ce1c7a2464a1;





function $bb2666eab5426e5e$var$isJSON(text) {
    const firstChar = text[0];
    const lastChar = text[text.length - 1];
    return firstChar === "{" && lastChar === "}" || firstChar === "[" && lastChar === "]";
}
var $bb2666eab5426e5e$export$2e2bcd8739ae039 = {
    id: "JSON",
    name: "JSON",
    module: "",
    version: "",
    options: {},
    extensions: [
        "json",
        "geojson"
    ],
    mimeTypes: [
        "application/json",
        "application/geo+json"
    ],
    testText: $bb2666eab5426e5e$var$isJSON,
    parseTextSync: JSON.parse
};


const $fb7f1a5ab7b23558$var$version = "8.8.4";
const $fb7f1a5ab7b23558$var$existingVersion = globalThis.deck && globalThis.deck.VERSION;
if ($fb7f1a5ab7b23558$var$existingVersion && $fb7f1a5ab7b23558$var$existingVersion !== $fb7f1a5ab7b23558$var$version) throw new Error("deck.gl - multiple versions detected: ".concat($fb7f1a5ab7b23558$var$existingVersion, " vs ").concat($fb7f1a5ab7b23558$var$version));
if (!$fb7f1a5ab7b23558$var$existingVersion) {
    (0, $146cba582e8c799f$export$2e2bcd8739ae039).log(1, "deck.gl ".concat($fb7f1a5ab7b23558$var$version))();
    globalThis.deck = {
        ...globalThis.deck,
        VERSION: $fb7f1a5ab7b23558$var$version,
        version: $fb7f1a5ab7b23558$var$version,
        log: $146cba582e8c799f$export$2e2bcd8739ae039,
        _registerLoggers: (0, $e34c41f170d77ab6$export$6503ec6e8aabbaf)
    };
    (0, $74a7778b58c84a5d$export$74069a1a10fa28e5)([
        (0, $bb2666eab5426e5e$export$2e2bcd8739ae039),
        [
            (0, $c5b13686f235cd74$export$8905ce1c7a2464a1),
            {
                imagebitmap: {
                    premultiplyAlpha: "none"
                }
            }
        ]
    ]);
}
var $fb7f1a5ab7b23558$export$2e2bcd8739ae039 = globalThis.deck;





var $9232896258c69fa7$exports = {};
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */ (function(window, document, exportName, undefined) {
    "use strict";
    var VENDOR_PREFIXES = [
        "",
        "webkit",
        "Moz",
        "MS",
        "ms",
        "o"
    ];
    var TEST_ELEMENT = document.createElement("div");
    var TYPE_FUNCTION = "function";
    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;
    /**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */ function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }
    /**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */ function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }
    /**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */ function each(obj, iterator, context) {
        var i;
        if (!obj) return;
        if (obj.forEach) obj.forEach(iterator, context);
        else if (obj.length !== undefined) {
            i = 0;
            while(i < obj.length){
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else for(i in obj)obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
    }
    /**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */ function deprecate(method, name, message) {
        var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
        return function() {
            var e = new Error("get-stack-trace");
            var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
            var log = window.console && (window.console.warn || window.console.log);
            if (log) log.call(window.console, deprecationMessage, stack);
            return method.apply(this, arguments);
        };
    }
    /**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */ var assign;
    if (typeof Object.assign !== "function") assign = function assign(target) {
        if (target === undefined || target === null) throw new TypeError("Cannot convert undefined or null to object");
        var output = Object(target);
        for(var index = 1; index < arguments.length; index++){
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for(var nextKey in source)if (source.hasOwnProperty(nextKey)) output[nextKey] = source[nextKey];
            }
        }
        return output;
    };
    else assign = Object.assign;
    /**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */ var extend = deprecate(function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while(i < keys.length){
            if (!merge || merge && dest[keys[i]] === undefined) dest[keys[i]] = src[keys[i]];
            i++;
        }
        return dest;
    }, "extend", "Use `assign`.");
    /**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */ var merge1 = deprecate(function merge(dest, src) {
        return extend(dest, src, true);
    }, "merge", "Use `assign`.");
    /**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */ function inherit(child, base, properties) {
        var baseP = base.prototype, childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) assign(childP, properties);
    }
    /**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */ function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }
    /**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */ function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) return val.apply(args ? args[0] || undefined : undefined, args);
        return val;
    }
    /**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */ function ifUndefined(val1, val2) {
        return val1 === undefined ? val2 : val1;
    }
    /**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */ function addEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.addEventListener(type, handler, false);
        });
    }
    /**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */ function removeEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.removeEventListener(type, handler, false);
        });
    }
    /**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */ function hasParent(node, parent) {
        while(node){
            if (node == parent) return true;
            node = node.parentNode;
        }
        return false;
    }
    /**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */ function inStr(str, find) {
        return str.indexOf(find) > -1;
    }
    /**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */ function splitStr(str) {
        return str.trim().split(/\s+/g);
    }
    /**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */ function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) return src.indexOf(find);
        else {
            var i = 0;
            while(i < src.length){
                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) return i;
                i++;
            }
            return -1;
        }
    }
    /**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */ function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }
    /**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */ function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while(i < src.length){
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) results.push(src[i]);
            values[i] = val;
            i++;
        }
        if (sort) {
            if (!key) results = results.sort();
            else results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
        return results;
    }
    /**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */ function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while(i < VENDOR_PREFIXES.length){
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) return prop;
            i++;
        }
        return undefined;
    }
    /**
 * get a unique id
 * @returns {number} uniqueId
 */ var _uniqueId = 1;
    function uniqueId() {
        return _uniqueId++;
    }
    /**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */ function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window;
    }
    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
    var SUPPORT_TOUCH = "ontouchstart" in window;
    var SUPPORT_POINTER_EVENTS = prefixed(window, "PointerEvent") !== undefined;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
    var INPUT_TYPE_TOUCH = "touch";
    var INPUT_TYPE_PEN = "pen";
    var INPUT_TYPE_MOUSE = "mouse";
    var INPUT_TYPE_KINECT = "kinect";
    var COMPUTE_INTERVAL = 25;
    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;
    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;
    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
    var PROPS_XY = [
        "x",
        "y"
    ];
    var PROPS_CLIENT_XY = [
        "clientX",
        "clientY"
    ];
    /**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */ function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [
                manager
            ])) self.handler(ev);
        };
        this.init();
    }
    Input.prototype = {
        /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */ handler: function() {},
        /**
     * bind the events
     */ init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        /**
     * unbind the events
     */ destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
    };
    /**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */ function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) Type = inputClass;
        else if (SUPPORT_POINTER_EVENTS) Type = PointerEventInput;
        else if (SUPPORT_ONLY_TOUCH) Type = TouchInput;
        else if (!SUPPORT_TOUCH) Type = MouseInput;
        else Type = TouchMouseInput;
        return new Type(manager, inputHandler);
    }
    /**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */ function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) manager.session = {};
        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;
        // compute scale, rotation etc
        computeInputData(manager, input);
        // emit secret event
        manager.emit("hammer.input", input);
        manager.recognize(input);
        manager.session.prevInput = input;
    }
    /**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */ function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        // store the first input to calculate the distance and direction
        if (!session.firstInput) session.firstInput = simpleCloneInputData(input);
        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) session.firstMultiple = simpleCloneInputData(input);
        else if (pointersLength === 1) session.firstMultiple = false;
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input);
        // find the correct target
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) target = input.srcEvent.target;
        input.target = target;
    }
    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }
    /**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */ function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
        } else {
            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }
    /**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */ function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;
        while(i < input.pointers.length){
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }
        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }
    /**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */ function getCenter(pointers) {
        var pointersLength = pointers.length;
        // no need to loop when only one touch
        if (pointersLength === 1) return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
        var x = 0, y = 0, i = 0;
        while(i < pointersLength){
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }
        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }
    /**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */ function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }
    /**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */ function getDirection(x, y) {
        if (x === y) return DIRECTION_NONE;
        if (abs(x) >= abs(y)) return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }
    /**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */ function getDistance(p1, p2, props) {
        if (!props) props = PROPS_XY;
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
    }
    /**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */ function getAngle(p1, p2, props) {
        if (!props) props = PROPS_XY;
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }
    /**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */ function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }
    /**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */ function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }
    var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
    };
    var MOUSE_ELEMENT_EVENTS = "mousedown";
    var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
    /**
 * Mouse events input
 * @constructor
 * @extends Input
 */ function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false; // mousedown state
        Input.apply(this, arguments);
    }
    inherit(MouseInput, Input, {
        /**
     * handle mouse events
     * @param {Object} ev
     */ handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP[ev.type];
            // on start we want to have the left mouse button down
            if (eventType & INPUT_START && ev.button === 0) this.pressed = true;
            if (eventType & INPUT_MOVE && ev.which !== 1) eventType = INPUT_END;
            // mouse must be down
            if (!this.pressed) return;
            if (eventType & INPUT_END) this.pressed = false;
            this.callback(this.manager, eventType, {
                pointers: [
                    ev
                ],
                changedPointers: [
                    ev
                ],
                pointerType: INPUT_TYPE_MOUSE,
                srcEvent: ev
            });
        }
    });
    var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
    };
    // in IE10 the pointer types is defined as an enum
    var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
    };
    var POINTER_ELEMENT_EVENTS = "pointerdown";
    var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
    // IE10 has prefixed support, and case-sensitive
    if (window.MSPointerEvent && !window.PointerEvent) {
        POINTER_ELEMENT_EVENTS = "MSPointerDown";
        POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
    }
    /**
 * Pointer events input
 * @constructor
 * @extends Input
 */ function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
    }
    inherit(PointerEventInput, Input, {
        /**
     * handle mouse events
     * @param {Object} ev
     */ handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
            var isTouch = pointerType == INPUT_TYPE_TOUCH;
            // get index of the event in the store
            var storeIndex = inArray(store, ev.pointerId, "pointerId");
            // start and mouse must be down
            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                if (storeIndex < 0) {
                    store.push(ev);
                    storeIndex = store.length - 1;
                }
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) removePointer = true;
            // it not found, so the pointer hasn't been down (so it's probably a hover)
            if (storeIndex < 0) return;
            // update the event in the store
            store[storeIndex] = ev;
            this.callback(this.manager, eventType, {
                pointers: store,
                changedPointers: [
                    ev
                ],
                pointerType: pointerType,
                srcEvent: ev
            });
            if (removePointer) // remove from the store
            store.splice(storeIndex, 1);
        }
    });
    var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
    var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
    /**
 * Touch events input
 * @constructor
 * @extends Input
 */ function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
    }
    inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
            // should we handle the touch events?
            if (type === INPUT_START) this.started = true;
            if (!this.started) return;
            var touches = normalizeSingleTouches.call(this, ev, type);
            // when done, reset the started state
            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) this.started = false;
            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });
    /**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */ function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) all = uniqueArray(all.concat(changed), "identifier", true);
        return [
            all,
            changed
        ];
    }
    var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
    /**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */ function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
    }
    inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) return;
            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });
    /**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */ function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [
                allTouches,
                allTouches
            ];
        }
        var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
        // get target touches from touches
        targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target);
        });
        // collect touches
        if (type === INPUT_START) {
            i = 0;
            while(i < targetTouches.length){
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }
        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;
        while(i < changedTouches.length){
            if (targetIds[changedTouches[i].identifier]) changedTargetTouches.push(changedTouches[i]);
            // cleanup removed touches
            if (type & (INPUT_END | INPUT_CANCEL)) delete targetIds[changedTouches[i].identifier];
            i++;
        }
        if (!changedTargetTouches.length) return;
        return [
            // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
            uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
            changedTargetTouches
        ];
    }
    /**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */ var DEDUP_TIMEOUT = 2500;
    var DEDUP_DISTANCE = 25;
    function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
        this.primaryTouch = null;
        this.lastTouches = [];
    }
    inherit(TouchMouseInput, Input, {
        /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */ handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) return;
            // when we're in a touch event, record touches to  de-dupe synthetic mouse event
            if (isTouch) recordTouches.call(this, inputEvent, inputData);
            else if (isMouse && isSyntheticEvent.call(this, inputData)) return;
            this.callback(manager, inputEvent, inputData);
        },
        /**
     * remove the event listeners
     */ destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
        }
    });
    function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) setLastTouch.call(this, eventData);
    }
    function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];
        if (touch.identifier === this.primaryTouch) {
            var lastTouch = {
                x: touch.clientX,
                y: touch.clientY
            };
            this.lastTouches.push(lastTouch);
            var lts = this.lastTouches;
            var removeLastTouch = function() {
                var i = lts.indexOf(lastTouch);
                if (i > -1) lts.splice(i, 1);
            };
            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
    }
    function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
        for(var i = 0; i < this.lastTouches.length; i++){
            var t = this.lastTouches[i];
            var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) return true;
        }
        return false;
    }
    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
    // magical touchAction value
    var TOUCH_ACTION_COMPUTE = "compute";
    var TOUCH_ACTION_AUTO = "auto";
    var TOUCH_ACTION_MANIPULATION = "manipulation"; // not implemented
    var TOUCH_ACTION_NONE = "none";
    var TOUCH_ACTION_PAN_X = "pan-x";
    var TOUCH_ACTION_PAN_Y = "pan-y";
    var TOUCH_ACTION_MAP = getTouchActionProps();
    /**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */ function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }
    TouchAction.prototype = {
        /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */ set: function(value) {
            // find out the touch-action by the event handlers
            if (value == TOUCH_ACTION_COMPUTE) value = this.compute();
            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            this.actions = value.toLowerCase().trim();
        },
        /**
     * just re-set the touchAction value
     */ update: function() {
            this.set(this.manager.options.touchAction);
        },
        /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */ compute: function() {
            var actions = [];
            each(this.manager.recognizers, function(recognizer) {
                if (boolOrFn(recognizer.options.enable, [
                    recognizer
                ])) actions = actions.concat(recognizer.getTouchAction());
            });
            return cleanTouchActions(actions.join(" "));
        },
        /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */ preventDefaults: function(input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;
            // if the touch action did prevented once this session
            if (this.manager.session.prevented) {
                srcEvent.preventDefault();
                return;
            }
            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
            if (hasNone) {
                //do not prevent defaults if this is a tap gesture
                var isTapPointer = input.pointers.length === 1;
                var isTapMovement = input.distance < 2;
                var isTapTouchTime = input.deltaTime < 250;
                if (isTapPointer && isTapMovement && isTapTouchTime) return;
            }
            if (hasPanX && hasPanY) // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) return this.preventSrc(srcEvent);
        },
        /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */ preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
        }
    };
    /**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */ function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) return TOUCH_ACTION_NONE;
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        // if both pan-x and pan-y are set (different recognizers
        // for different directions, e.g. horizontal pan but vertical swipe?)
        // we need none (as otherwise with pan-x pan-y combined none of these
        // recognizers will work, since the browser would handle all panning
        if (hasPanX && hasPanY) return TOUCH_ACTION_NONE;
        // pan-x OR pan-y
        if (hasPanX || hasPanY) return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) return TOUCH_ACTION_MANIPULATION;
        return TOUCH_ACTION_AUTO;
    }
    function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) return false;
        var touchMap = {};
        var cssSupports = window.CSS && window.CSS.supports;
        [
            "auto",
            "manipulation",
            "pan-y",
            "pan-x",
            "pan-x pan-y",
            "none"
        ].forEach(function(val) {
            // If css.supports is not supported but there is native touch-action assume it supports
            // all values. This is the case for IE 10 and 11.
            touchMap[val] = cssSupports ? window.CSS.supports("touch-action", val) : true;
        });
        return touchMap;
    }
    /**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */ var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED = STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;
    /**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */ function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});
        this.id = uniqueId();
        this.manager = null;
        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
    }
    Recognizer.prototype = {
        /**
     * @virtual
     * @type {Object}
     */ defaults: {},
        /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */ set: function(options) {
            assign(this.options, options);
            // also update the touchAction, in case something changed about the directions/enabled state
            this.manager && this.manager.touchAction.update();
            return this;
        },
        /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */ recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) return this;
            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
                simultaneous[otherRecognizer.id] = otherRecognizer;
                otherRecognizer.recognizeWith(this);
            }
            return this;
        },
        /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */ dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) return this;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
        },
        /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */ requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "requireFailure", this)) return this;
            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
                requireFail.push(otherRecognizer);
                otherRecognizer.requireFailure(this);
            }
            return this;
        },
        /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */ dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) return this;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) this.requireFail.splice(index, 1);
            return this;
        },
        /**
     * has require failures boolean
     * @returns {boolean}
     */ hasRequireFailures: function() {
            return this.requireFail.length > 0;
        },
        /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */ canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
        },
        /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */ emit: function(input) {
            var self = this;
            var state = this.state;
            function emit(event) {
                self.manager.emit(event, input);
            }
            // 'panstart' and 'panmove'
            if (state < STATE_ENDED) emit(self.options.event + stateStr(state));
            emit(self.options.event); // simple 'eventName' events
            if (input.additionalEvent) emit(input.additionalEvent);
            // panend and pancancel
            if (state >= STATE_ENDED) emit(self.options.event + stateStr(state));
        },
        /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */ tryEmit: function(input) {
            if (this.canEmit()) return this.emit(input);
            // it's failing anyway
            this.state = STATE_FAILED;
        },
        /**
     * can we emit?
     * @returns {boolean}
     */ canEmit: function() {
            var i = 0;
            while(i < this.requireFail.length){
                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) return false;
                i++;
            }
            return true;
        },
        /**
     * update the recognizer
     * @param {Object} inputData
     */ recognize: function(inputData) {
            // make a new copy of the inputData
            // so we can change the inputData without messing up the other recognizers
            var inputDataClone = assign({}, inputData);
            // is is enabled and allow recognizing?
            if (!boolOrFn(this.options.enable, [
                this,
                inputDataClone
            ])) {
                this.reset();
                this.state = STATE_FAILED;
                return;
            }
            // reset when we've reached the end
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) this.state = STATE_POSSIBLE;
            this.state = this.process(inputDataClone);
            // the recognizer has recognized a gesture
            // so trigger an event
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) this.tryEmit(inputDataClone);
        },
        /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */ process: function(inputData) {},
        /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */ getTouchAction: function() {},
        /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */ reset: function() {}
    };
    /**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */ function stateStr(state) {
        if (state & STATE_CANCELLED) return "cancel";
        else if (state & STATE_ENDED) return "end";
        else if (state & STATE_CHANGED) return "move";
        else if (state & STATE_BEGAN) return "start";
        return "";
    }
    /**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */ function directionStr(direction) {
        if (direction == DIRECTION_DOWN) return "down";
        else if (direction == DIRECTION_UP) return "up";
        else if (direction == DIRECTION_LEFT) return "left";
        else if (direction == DIRECTION_RIGHT) return "right";
        return "";
    }
    /**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */ function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) return manager.get(otherRecognizer);
        return otherRecognizer;
    }
    /**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */ function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }
    inherit(AttrRecognizer, Recognizer, {
        /**
     * @namespace
     * @memberof AttrRecognizer
     */ defaults: {
            /**
         * @type {Number}
         * @default 1
         */ pointers: 1
        },
        /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */ attrTest: function(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */ process: function(input) {
            var state = this.state;
            var eventType = input.eventType;
            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);
            // on cancel input and we've recognized before, return STATE_CANCELLED
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) return state | STATE_CANCELLED;
            else if (isRecognized || isValid) {
                if (eventType & INPUT_END) return state | STATE_ENDED;
                else if (!(state & STATE_BEGAN)) return STATE_BEGAN;
                return state | STATE_CHANGED;
            }
            return STATE_FAILED;
        }
    });
    /**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */ function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
    }
    inherit(PanRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof PanRecognizer
     */ defaults: {
            event: "pan",
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
        },
        getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) actions.push(TOUCH_ACTION_PAN_Y);
            if (direction & DIRECTION_VERTICAL) actions.push(TOUCH_ACTION_PAN_X);
            return actions;
        },
        directionTest: function(input) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;
            // lock to axis?
            if (!(direction & options.direction)) {
                if (options.direction & DIRECTION_HORIZONTAL) {
                    direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    hasMoved = x != this.pX;
                    distance = Math.abs(input.deltaX);
                } else {
                    direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                    hasMoved = y != this.pY;
                    distance = Math.abs(input.deltaY);
                }
            }
            input.direction = direction;
            return hasMoved && distance > options.threshold && direction & options.direction;
        },
        attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function(input) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr(input.direction);
            if (direction) input.additionalEvent = this.options.event + direction;
            this._super.emit.call(this, input);
        }
    });
    /**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */ function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(PinchRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof PinchRecognizer
     */ defaults: {
            event: "pinch",
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [
                TOUCH_ACTION_NONE
            ];
        },
        attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function(input) {
            if (input.scale !== 1) {
                var inOut = input.scale < 1 ? "in" : "out";
                input.additionalEvent = this.options.event + inOut;
            }
            this._super.emit.call(this, input);
        }
    });
    /**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */ function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
    }
    inherit(PressRecognizer, Recognizer, {
        /**
     * @namespace
     * @memberof PressRecognizer
     */ defaults: {
            event: "press",
            pointers: 1,
            time: 251,
            threshold: 9 // a minimal movement is ok, but keep it low
        },
        getTouchAction: function() {
            return [
                TOUCH_ACTION_AUTO
            ];
        },
        process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;
            this._input = input;
            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) this.reset();
            else if (input.eventType & INPUT_START) {
                this.reset();
                this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                }, options.time, this);
            } else if (input.eventType & INPUT_END) return STATE_RECOGNIZED;
            return STATE_FAILED;
        },
        reset: function() {
            clearTimeout(this._timer);
        },
        emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) return;
            if (input && input.eventType & INPUT_END) this.manager.emit(this.options.event + "up", input);
            else {
                this._input.timeStamp = now();
                this.manager.emit(this.options.event, this._input);
            }
        }
    });
    /**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */ function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(RotateRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof RotateRecognizer
     */ defaults: {
            event: "rotate",
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [
                TOUCH_ACTION_NONE
            ];
        },
        attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
    });
    /**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */ function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(SwipeRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof SwipeRecognizer
     */ defaults: {
            event: "swipe",
            threshold: 10,
            velocity: 0.3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
        },
        getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;
            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) velocity = input.overallVelocity;
            else if (direction & DIRECTION_HORIZONTAL) velocity = input.overallVelocityX;
            else if (direction & DIRECTION_VERTICAL) velocity = input.overallVelocityY;
            return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },
        emit: function(input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) this.manager.emit(this.options.event + direction, input);
            this.manager.emit(this.options.event, input);
        }
    });
    /**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */ function TapRecognizer() {
        Recognizer.apply(this, arguments);
        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
    }
    inherit(TapRecognizer, Recognizer, {
        /**
     * @namespace
     * @memberof PinchRecognizer
     */ defaults: {
            event: "tap",
            pointers: 1,
            taps: 1,
            interval: 300,
            time: 250,
            threshold: 9,
            posThreshold: 10 // a multi-tap can be a bit off the initial position
        },
        getTouchAction: function() {
            return [
                TOUCH_ACTION_MANIPULATION
            ];
        },
        process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;
            this.reset();
            if (input.eventType & INPUT_START && this.count === 0) return this.failTimeout();
            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (validMovement && validTouchTime && validPointers) {
                if (input.eventType != INPUT_END) return this.failTimeout();
                var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
                this.pTime = input.timeStamp;
                this.pCenter = input.center;
                if (!validMultiTap || !validInterval) this.count = 1;
                else this.count += 1;
                this._input = input;
                // if tap count matches we have recognized it,
                // else it has began recognizing...
                var tapCount = this.count % options.taps;
                if (tapCount === 0) {
                    // no failing requirements, immediately trigger the tap event
                    // or wait as long as the multitap interval to trigger
                    if (!this.hasRequireFailures()) return STATE_RECOGNIZED;
                    else {
                        this._timer = setTimeoutContext(function() {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.interval, this);
                        return STATE_BEGAN;
                    }
                }
            }
            return STATE_FAILED;
        },
        failTimeout: function() {
            this._timer = setTimeoutContext(function() {
                this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
        },
        reset: function() {
            clearTimeout(this._timer);
        },
        emit: function() {
            if (this.state == STATE_RECOGNIZED) {
                this._input.tapCount = this.count;
                this.manager.emit(this.options.event, this._input);
            }
        }
    });
    /**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */ function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }
    /**
 * @const {string}
 */ Hammer.VERSION = "2.0.7";
    /**
 * default settings
 * @namespace
 */ Hammer.defaults = {
        /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */ domEvents: false,
        /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */ touchAction: TOUCH_ACTION_COMPUTE,
        /**
     * @type {Boolean}
     * @default true
     */ enable: true,
        /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */ inputTarget: null,
        /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */ inputClass: null,
        /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */ preset: [
            // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
            [
                RotateRecognizer,
                {
                    enable: false
                }
            ],
            [
                PinchRecognizer,
                {
                    enable: false
                },
                [
                    "rotate"
                ]
            ],
            [
                SwipeRecognizer,
                {
                    direction: DIRECTION_HORIZONTAL
                }
            ],
            [
                PanRecognizer,
                {
                    direction: DIRECTION_HORIZONTAL
                },
                [
                    "swipe"
                ]
            ],
            [
                TapRecognizer
            ],
            [
                TapRecognizer,
                {
                    event: "doubletap",
                    taps: 2
                },
                [
                    "tap"
                ]
            ],
            [
                PressRecognizer
            ]
        ],
        /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */ cssProps: {
            /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */ userSelect: "none",
            /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */ touchSelect: "none",
            /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */ touchCallout: "none",
            /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */ contentZooming: "none",
            /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */ userDrag: "none",
            /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */ tapHighlightColor: "rgba(0,0,0,0)"
        }
    };
    var STOP = 1;
    var FORCED_STOP = 2;
    /**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */ function Manager(element, options) {
        this.options = assign({}, Hammer.defaults, options || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(this.options.recognizers, function(item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }
    Manager.prototype = {
        /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */ set: function(options) {
            assign(this.options, options);
            // Options that need a little more setup
            if (options.touchAction) this.touchAction.update();
            if (options.inputTarget) {
                // Clean up existing event listeners and reinitialize
                this.input.destroy();
                this.input.target = options.inputTarget;
                this.input.init();
            }
            return this;
        },
        /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */ stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
        },
        /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */ recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) return;
            // run the touch-action polyfill
            this.touchAction.preventDefaults(inputData);
            var recognizer;
            var recognizers = this.recognizers;
            // this holds the recognizer that is being recognized.
            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
            // if no recognizer is detecting a thing, it is set to `null`
            var curRecognizer = session.curRecognizer;
            // reset when the last recognizer is recognized
            // or when we're in a new session
            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) curRecognizer = session.curRecognizer = null;
            var i = 0;
            while(i < recognizers.length){
                recognizer = recognizers[i];
                // find out if we are allowed try to recognize the input for this one.
                // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                //      that is being recognized.
                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                //      this can be setup with the `recognizeWith()` method on the recognizer.
                if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) recognizer.recognize(inputData);
                else recognizer.reset();
                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                // current active recognizer. but only if we don't already have an active recognizer
                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) curRecognizer = session.curRecognizer = recognizer;
                i++;
            }
        },
        /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */ get: function(recognizer) {
            if (recognizer instanceof Recognizer) return recognizer;
            var recognizers = this.recognizers;
            for(var i = 0; i < recognizers.length; i++){
                if (recognizers[i].options.event == recognizer) return recognizers[i];
            }
            return null;
        },
        /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */ add: function(recognizer) {
            if (invokeArrayArg(recognizer, "add", this)) return this;
            // remove existing
            var existing = this.get(recognizer.options.event);
            if (existing) this.remove(existing);
            this.recognizers.push(recognizer);
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer;
        },
        /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */ remove: function(recognizer) {
            if (invokeArrayArg(recognizer, "remove", this)) return this;
            recognizer = this.get(recognizer);
            // let's make sure this recognizer exists
            if (recognizer) {
                var recognizers = this.recognizers;
                var index = inArray(recognizers, recognizer);
                if (index !== -1) {
                    recognizers.splice(index, 1);
                    this.touchAction.update();
                }
            }
            return this;
        },
        /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */ on: function(events, handler) {
            if (events === undefined) return;
            if (handler === undefined) return;
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                handlers[event] = handlers[event] || [];
                handlers[event].push(handler);
            });
            return this;
        },
        /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */ off: function(events, handler) {
            if (events === undefined) return;
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                if (!handler) delete handlers[event];
                else handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            });
            return this;
        },
        /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */ emit: function(event, data) {
            // we also want to trigger dom events
            if (this.options.domEvents) triggerDomEvent(event, data);
            // no handlers, so skip it all
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) return;
            data.type = event;
            data.preventDefault = function() {
                data.srcEvent.preventDefault();
            };
            var i = 0;
            while(i < handlers.length){
                handlers[i](data);
                i++;
            }
        },
        /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */ destroy: function() {
            this.element && toggleCssProps(this, false);
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
        }
    };
    /**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */ function toggleCssProps(manager, add) {
        var element = manager.element;
        if (!element.style) return;
        var prop;
        each(manager.options.cssProps, function(value, name) {
            prop = prefixed(element.style, name);
            if (add) {
                manager.oldCssProps[prop] = element.style[prop];
                element.style[prop] = value;
            } else element.style[prop] = manager.oldCssProps[prop] || "";
        });
        if (!add) manager.oldCssProps = {};
    }
    /**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */ function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent("Event");
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }
    assign(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,
        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,
        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,
        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,
        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,
        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge1,
        extend: extend,
        assign: assign,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
    });
    // this prevents errors when Hammer is loaded in the presence of an AMD
    //  style loader but by script tag, not by the loader.
    var freeGlobal = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}; // jshint ignore:line
    freeGlobal.Hammer = Hammer;
    if (typeof define === "function" && define.amd) define(function() {
        return Hammer;
    });
    else if ($9232896258c69fa7$exports) $9232896258c69fa7$exports = Hammer;
    else window[exportName] = Hammer;
})(window, document, "Hammer");


/**
 * This file contains overrides the default
 * hammer.js functions to add our own utility
 */ /* eslint-disable */ /* Hammer.js constants */ const $35cf891399782003$var$INPUT_START = 1;
const $35cf891399782003$var$INPUT_MOVE = 2;
const $35cf891399782003$var$INPUT_END = 4;
const $35cf891399782003$var$MOUSE_INPUT_MAP = {
    mousedown: $35cf891399782003$var$INPUT_START,
    mousemove: $35cf891399782003$var$INPUT_MOVE,
    mouseup: $35cf891399782003$var$INPUT_END
};
/**
 * Helper function that returns true if any element in an array meets given criteria.
 * Because older browsers do not support `Array.prototype.some`
 * @params array {Array}
 * @params predict {Function}
 */ function $35cf891399782003$var$some(array, predict) {
    for(let i = 0; i < array.length; i++){
        if (predict(array[i])) return true;
    }
    return false;
}
function $35cf891399782003$export$feb1ac98c5ad1053(PointerEventInput) {
    const oldHandler = PointerEventInput.prototype.handler;
    // overrides PointerEventInput.handler to accept right mouse button
    PointerEventInput.prototype.handler = function handler(ev) {
        const store = this.store;
        // Allow non-left mouse buttons through
        if (ev.button > 0 && ev.type === "pointerdown") {
            if (!$35cf891399782003$var$some(store, (e)=>e.pointerId === ev.pointerId)) store.push(ev);
        }
        oldHandler.call(this, ev);
    };
}
function $35cf891399782003$export$adfd6dd2dd4d96db(MouseInput) {
    MouseInput.prototype.handler = function handler(ev) {
        let eventType = $35cf891399782003$var$MOUSE_INPUT_MAP[ev.type];
        // on start we want to have the mouse button down
        if (eventType & $35cf891399782003$var$INPUT_START && ev.button >= 0) this.pressed = true;
        if (eventType & $35cf891399782003$var$INPUT_MOVE && ev.which === 0) eventType = $35cf891399782003$var$INPUT_END;
        // mouse must be down
        if (!this.pressed) return;
        if (eventType & $35cf891399782003$var$INPUT_END) this.pressed = false;
        this.callback(this.manager, eventType, {
            pointers: [
                ev
            ],
            changedPointers: [
                ev
            ],
            pointerType: "mouse",
            srcEvent: ev
        });
    };
}


(0, $35cf891399782003$export$feb1ac98c5ad1053)((0, (/*@__PURE__*/$parcel$interopDefault($9232896258c69fa7$exports))).PointerEventInput);
(0, $35cf891399782003$export$adfd6dd2dd4d96db)((0, (/*@__PURE__*/$parcel$interopDefault($9232896258c69fa7$exports))).MouseInput);
const $44b838deaec206ae$export$d0d38e7dec7a1a61 = (0, (/*@__PURE__*/$parcel$interopDefault($9232896258c69fa7$exports))).Manager;
var $44b838deaec206ae$export$2e2bcd8739ae039 = (0, (/*@__PURE__*/$parcel$interopDefault($9232896258c69fa7$exports)));


class $7369164f897f54bf$export$2e2bcd8739ae039 {
    constructor(element, callback, options){
        this.element = element;
        this.callback = callback;
        this.options = {
            enable: true,
            ...options
        };
    }
}



const $368369ab2de6fcb8$export$2dfe3ccfbb9a4dca = (0, $44b838deaec206ae$export$2e2bcd8739ae039) ? [
    [
        (0, $44b838deaec206ae$export$2e2bcd8739ae039).Pan,
        {
            event: "tripan",
            pointers: 3,
            threshold: 0,
            enable: false
        }
    ],
    [
        (0, $44b838deaec206ae$export$2e2bcd8739ae039).Rotate,
        {
            enable: false
        }
    ],
    [
        (0, $44b838deaec206ae$export$2e2bcd8739ae039).Pinch,
        {
            enable: false
        }
    ],
    [
        (0, $44b838deaec206ae$export$2e2bcd8739ae039).Swipe,
        {
            enable: false
        }
    ],
    [
        (0, $44b838deaec206ae$export$2e2bcd8739ae039).Pan,
        {
            threshold: 0,
            enable: false
        }
    ],
    [
        (0, $44b838deaec206ae$export$2e2bcd8739ae039).Press,
        {
            enable: false
        }
    ],
    [
        (0, $44b838deaec206ae$export$2e2bcd8739ae039).Tap,
        {
            event: "doubletap",
            taps: 2,
            enable: false
        }
    ],
    // TODO - rename to 'tap' and 'singletap' in the next major release
    [
        (0, $44b838deaec206ae$export$2e2bcd8739ae039).Tap,
        {
            event: "anytap",
            enable: false
        }
    ],
    [
        (0, $44b838deaec206ae$export$2e2bcd8739ae039).Tap,
        {
            enable: false
        }
    ]
] : null;
const $368369ab2de6fcb8$export$3188734ead87a63d = {
    tripan: [
        "rotate",
        "pinch",
        "pan"
    ],
    rotate: [
        "pinch"
    ],
    pinch: [
        "pan"
    ],
    pan: [
        "press",
        "doubletap",
        "anytap",
        "tap"
    ],
    doubletap: [
        "anytap"
    ],
    anytap: [
        "tap"
    ]
};
const $368369ab2de6fcb8$export$3da361ddf819b1fc = {
    doubletap: [
        "tap"
    ]
};
const $368369ab2de6fcb8$export$7e5632c88be0a3be = {
    pointerdown: "pointerdown",
    pointermove: "pointermove",
    pointerup: "pointerup",
    touchstart: "pointerdown",
    touchmove: "pointermove",
    touchend: "pointerup",
    mousedown: "pointerdown",
    mousemove: "pointermove",
    mouseup: "pointerup"
};
const $368369ab2de6fcb8$export$dddb9e29f5b2e5aa = {
    KEY_EVENTS: [
        "keydown",
        "keyup"
    ],
    MOUSE_EVENTS: [
        "mousedown",
        "mousemove",
        "mouseup",
        "mouseover",
        "mouseout",
        "mouseleave"
    ],
    WHEEL_EVENTS: [
        // Chrome, Safari
        "wheel",
        // IE
        "mousewheel"
    ]
};
const $368369ab2de6fcb8$export$5e103639c5775d6b = {
    tap: "tap",
    anytap: "anytap",
    doubletap: "doubletap",
    press: "press",
    pinch: "pinch",
    pinchin: "pinch",
    pinchout: "pinch",
    pinchstart: "pinch",
    pinchmove: "pinch",
    pinchend: "pinch",
    pinchcancel: "pinch",
    rotate: "rotate",
    rotatestart: "rotate",
    rotatemove: "rotate",
    rotateend: "rotate",
    rotatecancel: "rotate",
    tripan: "tripan",
    tripanstart: "tripan",
    tripanmove: "tripan",
    tripanup: "tripan",
    tripandown: "tripan",
    tripanleft: "tripan",
    tripanright: "tripan",
    tripanend: "tripan",
    tripancancel: "tripan",
    pan: "pan",
    panstart: "pan",
    panmove: "pan",
    panup: "pan",
    pandown: "pan",
    panleft: "pan",
    panright: "pan",
    panend: "pan",
    pancancel: "pan",
    swipe: "swipe",
    swipeleft: "swipe",
    swiperight: "swipe",
    swipeup: "swipe",
    swipedown: "swipe"
};
const $368369ab2de6fcb8$export$580af412e0595c74 = {
    click: "tap",
    anyclick: "anytap",
    dblclick: "doubletap",
    mousedown: "pointerdown",
    mousemove: "pointermove",
    mouseup: "pointerup",
    mouseover: "pointerover",
    mouseout: "pointerout",
    mouseleave: "pointerleave"
};


const $03535674bc5b5a9a$export$3dcce53a3755dc8c = typeof navigator !== "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
const $03535674bc5b5a9a$export$8291e5b88f90ce4 = typeof window !== "undefined" ? window : $parcel$global;
const $03535674bc5b5a9a$export$90b4d2ff6acb88af = typeof $parcel$global !== "undefined" ? $parcel$global : window;
const $03535674bc5b5a9a$export$5a7bfc01df82fcd1 = typeof document !== "undefined" ? document : {};
/*
 * Detect whether passive option is supported by the current browser.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
   #Safely_detecting_option_support
 */ let $03535674bc5b5a9a$export$f972eb82d6211f6 = false;
/* eslint-disable accessor-pairs, no-empty */ try {
    const options = {
        // This function will be called when the browser
        // attempts to access the passive property.
        get passive () {
            $03535674bc5b5a9a$export$f972eb82d6211f6 = true;
            return true;
        }
    };
    $03535674bc5b5a9a$export$8291e5b88f90ce4.addEventListener("test", null, options);
    $03535674bc5b5a9a$export$8291e5b88f90ce4.removeEventListener("test", null);
} catch (err) {
    $03535674bc5b5a9a$export$f972eb82d6211f6 = false;
}


const $2f48018e669b380c$var$firefox = (0, $03535674bc5b5a9a$export$3dcce53a3755dc8c).indexOf("firefox") !== -1;
const { WHEEL_EVENTS: $2f48018e669b380c$var$WHEEL_EVENTS  } = (0, $368369ab2de6fcb8$export$dddb9e29f5b2e5aa);
const $2f48018e669b380c$var$EVENT_TYPE = "wheel";
// Constants for normalizing input delta
const $2f48018e669b380c$var$WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
const $2f48018e669b380c$var$WHEEL_DELTA_PER_LINE = 40;
// Slow down zoom if shift key is held for more precise zooming
const $2f48018e669b380c$var$SHIFT_MULTIPLIER = 0.25;
class $2f48018e669b380c$export$2e2bcd8739ae039 extends (0, $7369164f897f54bf$export$2e2bcd8739ae039) {
    constructor(element, callback, options){
        super(element, callback, options);
        /* eslint-disable complexity, max-statements */ this.handleEvent = (event)=>{
            if (!this.options.enable) return;
            let value = event.deltaY;
            if ((0, $03535674bc5b5a9a$export$8291e5b88f90ce4).WheelEvent) {
                // Firefox doubles the values on retina screens...
                if ($2f48018e669b380c$var$firefox && event.deltaMode === (0, $03535674bc5b5a9a$export$8291e5b88f90ce4).WheelEvent.DOM_DELTA_PIXEL) value /= (0, $03535674bc5b5a9a$export$8291e5b88f90ce4).devicePixelRatio;
                if (event.deltaMode === (0, $03535674bc5b5a9a$export$8291e5b88f90ce4).WheelEvent.DOM_DELTA_LINE) value *= $2f48018e669b380c$var$WHEEL_DELTA_PER_LINE;
            }
            if (value !== 0 && value % $2f48018e669b380c$var$WHEEL_DELTA_MAGIC_SCALER === 0) // This one is definitely a mouse wheel event.
            // Normalize this value to match trackpad.
            value = Math.floor(value / $2f48018e669b380c$var$WHEEL_DELTA_MAGIC_SCALER);
            if (event.shiftKey && value) value = value * $2f48018e669b380c$var$SHIFT_MULTIPLIER;
            this.callback({
                type: $2f48018e669b380c$var$EVENT_TYPE,
                center: {
                    x: event.clientX,
                    y: event.clientY
                },
                delta: -value,
                srcEvent: event,
                pointerType: "mouse",
                target: event.target
            });
        };
        this.events = (this.options.events || []).concat($2f48018e669b380c$var$WHEEL_EVENTS);
        this.events.forEach((event)=>element.addEventListener(event, this.handleEvent, (0, $03535674bc5b5a9a$export$f972eb82d6211f6) ? {
                passive: false
            } : false));
    }
    destroy() {
        this.events.forEach((event)=>this.element.removeEventListener(event, this.handleEvent));
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */ enableEventType(eventType, enabled) {
        if (eventType === $2f48018e669b380c$var$EVENT_TYPE) this.options.enable = enabled;
    }
}




const { MOUSE_EVENTS: $859b18b18dc30513$var$MOUSE_EVENTS  } = (0, $368369ab2de6fcb8$export$dddb9e29f5b2e5aa);
const $859b18b18dc30513$var$MOVE_EVENT_TYPE = "pointermove";
const $859b18b18dc30513$var$OVER_EVENT_TYPE = "pointerover";
const $859b18b18dc30513$var$OUT_EVENT_TYPE = "pointerout";
const $859b18b18dc30513$var$ENTER_EVENT_TYPE = "pointerenter";
const $859b18b18dc30513$var$LEAVE_EVENT_TYPE = "pointerleave";
class $859b18b18dc30513$export$2e2bcd8739ae039 extends (0, $7369164f897f54bf$export$2e2bcd8739ae039) {
    constructor(element, callback, options){
        super(element, callback, options);
        this.handleEvent = (event)=>{
            this.handleOverEvent(event);
            this.handleOutEvent(event);
            this.handleEnterEvent(event);
            this.handleLeaveEvent(event);
            this.handleMoveEvent(event);
        };
        this.pressed = false;
        const { enable: enable  } = this.options;
        this.enableMoveEvent = enable;
        this.enableLeaveEvent = enable;
        this.enableEnterEvent = enable;
        this.enableOutEvent = enable;
        this.enableOverEvent = enable;
        this.events = (this.options.events || []).concat($859b18b18dc30513$var$MOUSE_EVENTS);
        this.events.forEach((event)=>element.addEventListener(event, this.handleEvent));
    }
    destroy() {
        this.events.forEach((event)=>this.element.removeEventListener(event, this.handleEvent));
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */ enableEventType(eventType, enabled) {
        if (eventType === $859b18b18dc30513$var$MOVE_EVENT_TYPE) this.enableMoveEvent = enabled;
        if (eventType === $859b18b18dc30513$var$OVER_EVENT_TYPE) this.enableOverEvent = enabled;
        if (eventType === $859b18b18dc30513$var$OUT_EVENT_TYPE) this.enableOutEvent = enabled;
        if (eventType === $859b18b18dc30513$var$ENTER_EVENT_TYPE) this.enableEnterEvent = enabled;
        if (eventType === $859b18b18dc30513$var$LEAVE_EVENT_TYPE) this.enableLeaveEvent = enabled;
    }
    handleOverEvent(event) {
        if (this.enableOverEvent) {
            if (event.type === "mouseover") this._emit($859b18b18dc30513$var$OVER_EVENT_TYPE, event);
        }
    }
    handleOutEvent(event) {
        if (this.enableOutEvent) {
            if (event.type === "mouseout") this._emit($859b18b18dc30513$var$OUT_EVENT_TYPE, event);
        }
    }
    handleEnterEvent(event) {
        if (this.enableEnterEvent) {
            if (event.type === "mouseenter") this._emit($859b18b18dc30513$var$ENTER_EVENT_TYPE, event);
        }
    }
    handleLeaveEvent(event) {
        if (this.enableLeaveEvent) {
            if (event.type === "mouseleave") this._emit($859b18b18dc30513$var$LEAVE_EVENT_TYPE, event);
        }
    }
    handleMoveEvent(event) {
        if (this.enableMoveEvent) switch(event.type){
            case "mousedown":
                if (event.button >= 0) // Button is down
                this.pressed = true;
                break;
            case "mousemove":
                // Move events use `which` to track the button being pressed
                if (event.which === 0) // Button is not down
                this.pressed = false;
                if (!this.pressed) // Drag events are emitted by hammer already
                // we just need to emit the move event on hover
                this._emit($859b18b18dc30513$var$MOVE_EVENT_TYPE, event);
                break;
            case "mouseup":
                this.pressed = false;
                break;
            default:
        }
    }
    _emit(type, event) {
        this.callback({
            type: type,
            center: {
                x: event.clientX,
                y: event.clientY
            },
            srcEvent: event,
            pointerType: "mouse",
            target: event.target
        });
    }
}




const { KEY_EVENTS: $376b75237faf2ae2$var$KEY_EVENTS  } = (0, $368369ab2de6fcb8$export$dddb9e29f5b2e5aa);
const $376b75237faf2ae2$var$DOWN_EVENT_TYPE = "keydown";
const $376b75237faf2ae2$var$UP_EVENT_TYPE = "keyup";
class $376b75237faf2ae2$export$2e2bcd8739ae039 extends (0, $7369164f897f54bf$export$2e2bcd8739ae039) {
    constructor(element, callback, options){
        super(element, callback, options);
        this.handleEvent = (event)=>{
            // Ignore if focused on text input
            const targetElement = event.target || event.srcElement;
            if (targetElement.tagName === "INPUT" && targetElement.type === "text" || targetElement.tagName === "TEXTAREA") return;
            if (this.enableDownEvent && event.type === "keydown") this.callback({
                type: $376b75237faf2ae2$var$DOWN_EVENT_TYPE,
                srcEvent: event,
                key: event.key,
                target: event.target
            });
            if (this.enableUpEvent && event.type === "keyup") this.callback({
                type: $376b75237faf2ae2$var$UP_EVENT_TYPE,
                srcEvent: event,
                key: event.key,
                target: event.target
            });
        };
        this.enableDownEvent = this.options.enable;
        this.enableUpEvent = this.options.enable;
        this.events = (this.options.events || []).concat($376b75237faf2ae2$var$KEY_EVENTS);
        element.tabIndex = this.options.tabIndex || 0;
        element.style.outline = "none";
        this.events.forEach((event)=>element.addEventListener(event, this.handleEvent));
    }
    destroy() {
        this.events.forEach((event)=>this.element.removeEventListener(event, this.handleEvent));
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */ enableEventType(eventType, enabled) {
        if (eventType === $376b75237faf2ae2$var$DOWN_EVENT_TYPE) this.enableDownEvent = enabled;
        if (eventType === $376b75237faf2ae2$var$UP_EVENT_TYPE) this.enableUpEvent = enabled;
    }
}



const $8b4fbfbcbca96ee3$var$EVENT_TYPE = "contextmenu";
class $8b4fbfbcbca96ee3$export$2e2bcd8739ae039 extends (0, $7369164f897f54bf$export$2e2bcd8739ae039) {
    constructor(element, callback, options){
        super(element, callback, options);
        this.handleEvent = (event)=>{
            if (!this.options.enable) return;
            this.callback({
                type: $8b4fbfbcbca96ee3$var$EVENT_TYPE,
                center: {
                    x: event.clientX,
                    y: event.clientY
                },
                srcEvent: event,
                pointerType: "mouse",
                target: event.target
            });
        };
        element.addEventListener("contextmenu", this.handleEvent);
    }
    destroy() {
        this.element.removeEventListener("contextmenu", this.handleEvent);
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */ enableEventType(eventType, enabled) {
        if (eventType === $8b4fbfbcbca96ee3$var$EVENT_TYPE) this.options.enable = enabled;
    }
}


/* Constants */ const $4ff014f8ca280599$var$DOWN_EVENT = 1;
const $4ff014f8ca280599$var$MOVE_EVENT = 2;
const $4ff014f8ca280599$var$UP_EVENT = 4;
const $4ff014f8ca280599$var$MOUSE_EVENTS = {
    pointerdown: $4ff014f8ca280599$var$DOWN_EVENT,
    pointermove: $4ff014f8ca280599$var$MOVE_EVENT,
    pointerup: $4ff014f8ca280599$var$UP_EVENT,
    mousedown: $4ff014f8ca280599$var$DOWN_EVENT,
    mousemove: $4ff014f8ca280599$var$MOVE_EVENT,
    mouseup: $4ff014f8ca280599$var$UP_EVENT
};
// MouseEvent.which https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which
const $4ff014f8ca280599$var$MOUSE_EVENT_WHICH_LEFT = 1;
const $4ff014f8ca280599$var$MOUSE_EVENT_WHICH_MIDDLE = 2;
const $4ff014f8ca280599$var$MOUSE_EVENT_WHICH_RIGHT = 3;
// MouseEvent.button https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
const $4ff014f8ca280599$var$MOUSE_EVENT_BUTTON_LEFT = 0;
const $4ff014f8ca280599$var$MOUSE_EVENT_BUTTON_MIDDLE = 1;
const $4ff014f8ca280599$var$MOUSE_EVENT_BUTTON_RIGHT = 2;
// MouseEvent.buttons https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
const $4ff014f8ca280599$var$MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
const $4ff014f8ca280599$var$MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
const $4ff014f8ca280599$var$MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
function $4ff014f8ca280599$export$b439c24608871a9a(event) {
    const eventType = $4ff014f8ca280599$var$MOUSE_EVENTS[event.srcEvent.type];
    if (!eventType) // Not a mouse evet
    return null;
    const { buttons: buttons , button: button , which: which  } = event.srcEvent;
    let leftButton = false;
    let middleButton = false;
    let rightButton = false;
    if (// button is up, need to find out which one was pressed before
    eventType === $4ff014f8ca280599$var$UP_EVENT || eventType === $4ff014f8ca280599$var$MOVE_EVENT && !Number.isFinite(buttons)) {
        leftButton = which === $4ff014f8ca280599$var$MOUSE_EVENT_WHICH_LEFT;
        middleButton = which === $4ff014f8ca280599$var$MOUSE_EVENT_WHICH_MIDDLE;
        rightButton = which === $4ff014f8ca280599$var$MOUSE_EVENT_WHICH_RIGHT;
    } else if (eventType === $4ff014f8ca280599$var$MOVE_EVENT) {
        leftButton = Boolean(buttons & $4ff014f8ca280599$var$MOUSE_EVENT_BUTTONS_LEFT_MASK);
        middleButton = Boolean(buttons & $4ff014f8ca280599$var$MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
        rightButton = Boolean(buttons & $4ff014f8ca280599$var$MOUSE_EVENT_BUTTONS_RIGHT_MASK);
    } else if (eventType === $4ff014f8ca280599$var$DOWN_EVENT) {
        leftButton = button === $4ff014f8ca280599$var$MOUSE_EVENT_BUTTON_LEFT;
        middleButton = button === $4ff014f8ca280599$var$MOUSE_EVENT_BUTTON_MIDDLE;
        rightButton = button === $4ff014f8ca280599$var$MOUSE_EVENT_BUTTON_RIGHT;
    }
    return {
        leftButton: leftButton,
        middleButton: middleButton,
        rightButton: rightButton
    };
}
function $4ff014f8ca280599$export$456611cab2a1cf25(event, rootElement) {
    const center = event.center;
    // `center` is a hammer.js event property
    if (!center) // Not a gestural event
    return null;
    const rect = rootElement.getBoundingClientRect();
    // Fix scale for map affected by a CSS transform.
    // See https://stackoverflow.com/a/26893663/3528533
    const scaleX = rect.width / rootElement.offsetWidth || 1;
    const scaleY = rect.height / rootElement.offsetHeight || 1;
    // Calculate center relative to the root element
    const offsetCenter = {
        x: (center.x - rect.left - rootElement.clientLeft) / scaleX,
        y: (center.y - rect.top - rootElement.clientTop) / scaleY
    };
    return {
        center: center,
        offsetCenter: offsetCenter
    };
}


const $e66c1fd4b977e653$var$DEFAULT_OPTIONS = {
    srcElement: "root",
    priority: 0
};
class $e66c1fd4b977e653$export$2e2bcd8739ae039 {
    constructor(eventManager){
        /**
         * Handles hammerjs event
         */ this.handleEvent = (event)=>{
            if (this.isEmpty()) return;
            const mjolnirEvent = this._normalizeEvent(event);
            let target = event.srcEvent.target;
            while(target && target !== mjolnirEvent.rootElement){
                this._emit(mjolnirEvent, target);
                if (mjolnirEvent.handled) return;
                target = target.parentNode;
            }
            this._emit(mjolnirEvent, "root");
        };
        this.eventManager = eventManager;
        this.handlers = [];
        // Element -> handler map
        this.handlersByElement = new Map();
        this._active = false;
    }
    // Returns true if there are no non-passive handlers
    isEmpty() {
        return !this._active;
    }
    add(type, handler, options, once = false, passive = false) {
        const { handlers: handlers , handlersByElement: handlersByElement  } = this;
        let opts = $e66c1fd4b977e653$var$DEFAULT_OPTIONS;
        if (typeof options === "string" || options && options.addEventListener) // is DOM element, backward compatibility
        // @ts-ignore
        opts = {
            ...$e66c1fd4b977e653$var$DEFAULT_OPTIONS,
            srcElement: options
        };
        else if (options) opts = {
            ...$e66c1fd4b977e653$var$DEFAULT_OPTIONS,
            ...options
        };
        let entries = handlersByElement.get(opts.srcElement);
        if (!entries) {
            entries = [];
            handlersByElement.set(opts.srcElement, entries);
        }
        const entry = {
            type: type,
            handler: handler,
            srcElement: opts.srcElement,
            priority: opts.priority
        };
        if (once) entry.once = true;
        if (passive) entry.passive = true;
        handlers.push(entry);
        this._active = this._active || !entry.passive;
        // Sort handlers by descending priority
        // Handlers with the same priority are excuted in the order of registration
        let insertPosition = entries.length - 1;
        while(insertPosition >= 0){
            if (entries[insertPosition].priority >= entry.priority) break;
            insertPosition--;
        }
        entries.splice(insertPosition + 1, 0, entry);
    }
    remove(type, handler) {
        const { handlers: handlers , handlersByElement: handlersByElement  } = this;
        for(let i = handlers.length - 1; i >= 0; i--){
            const entry = handlers[i];
            if (entry.type === type && entry.handler === handler) {
                handlers.splice(i, 1);
                const entries = handlersByElement.get(entry.srcElement);
                entries.splice(entries.indexOf(entry), 1);
                if (entries.length === 0) handlersByElement.delete(entry.srcElement);
            }
        }
        this._active = handlers.some((entry)=>!entry.passive);
    }
    /**
     * Invoke handlers on a particular element
     */ _emit(event, srcElement) {
        const entries = this.handlersByElement.get(srcElement);
        if (entries) {
            let immediatePropagationStopped = false;
            // Prevents the current event from bubbling up
            const stopPropagation = ()=>{
                event.handled = true;
            };
            // Prevent any remaining listeners from being called
            const stopImmediatePropagation = ()=>{
                event.handled = true;
                immediatePropagationStopped = true;
            };
            const entriesToRemove = [];
            for(let i = 0; i < entries.length; i++){
                const { type: type , handler: handler , once: once  } = entries[i];
                handler({
                    ...event,
                    type: // @ts-ignore
                    type,
                    stopPropagation: stopPropagation,
                    stopImmediatePropagation: stopImmediatePropagation
                });
                if (once) entriesToRemove.push(entries[i]);
                if (immediatePropagationStopped) break;
            }
            for(let i1 = 0; i1 < entriesToRemove.length; i1++){
                const { type: type , handler: handler  } = entriesToRemove[i1];
                this.remove(type, handler);
            }
        }
    }
    /**
     * Normalizes hammerjs and custom events to have predictable fields.
     */ _normalizeEvent(event) {
        const rootElement = this.eventManager.getElement();
        return {
            ...event,
            ...(0, $4ff014f8ca280599$export$b439c24608871a9a)(event),
            ...(0, $4ff014f8ca280599$export$456611cab2a1cf25)(event, rootElement),
            preventDefault: ()=>{
                event.srcEvent.preventDefault();
            },
            stopImmediatePropagation: null,
            stopPropagation: null,
            handled: false,
            rootElement: rootElement
        };
    }
}



const $1e4596bb66c8c182$var$DEFAULT_OPTIONS = {
    // event handlers
    events: null,
    // custom recognizers
    recognizers: null,
    recognizerOptions: {},
    Manager: // Manager class
    $44b838deaec206ae$export$d0d38e7dec7a1a61,
    // allow browser default touch action
    // https://github.com/uber/react-map-gl/issues/506
    touchAction: "none",
    tabIndex: 0
};
class $1e4596bb66c8c182$export$2e2bcd8739ae039 {
    constructor(element = null, options){
        /**
         * Handle basic events using the 'hammer.input' Hammer.js API:
         * Before running Recognizers, Hammer emits a 'hammer.input' event
         * with the basic event info. This function emits all basic events
         * aliased to the "class" of event received.
         * See constants.BASIC_EVENT_CLASSES basic event class definitions.
         */ this._onBasicInput = (event)=>{
            const { srcEvent: srcEvent  } = event;
            const alias = (0, $368369ab2de6fcb8$export$7e5632c88be0a3be)[srcEvent.type];
            if (alias) // fire all events aliased to srcEvent.type
            this.manager.emit(alias, event);
        };
        /**
         * Handle events not supported by Hammer.js,
         * and pipe back out through same (Hammer) channel used by other events.
         */ this._onOtherEvent = (event)=>{
            // console.log('onotherevent', event.type, event)
            this.manager.emit(event.type, event);
        };
        this.options = {
            ...$1e4596bb66c8c182$var$DEFAULT_OPTIONS,
            ...options
        };
        this.events = new Map();
        this.setElement(element);
        // Register all passed events.
        const { events: events  } = this.options;
        if (events) this.on(events);
    }
    getElement() {
        return this.element;
    }
    setElement(element) {
        if (this.element) // unregister all events
        this.destroy();
        this.element = element;
        if (!element) return;
        const { options: options  } = this;
        const ManagerClass = options.Manager;
        this.manager = new ManagerClass(element, {
            touchAction: options.touchAction,
            recognizers: options.recognizers || (0, $368369ab2de6fcb8$export$2dfe3ccfbb9a4dca)
        }).on("hammer.input", this._onBasicInput);
        if (!options.recognizers) // Set default recognize withs
        // http://hammerjs.github.io/recognize-with/
        Object.keys((0, $368369ab2de6fcb8$export$3188734ead87a63d)).forEach((name)=>{
            const recognizer = this.manager.get(name);
            if (recognizer) (0, $368369ab2de6fcb8$export$3188734ead87a63d)[name].forEach((otherName)=>{
                recognizer.recognizeWith(otherName);
            });
        });
        // Set recognizer options
        for(const recognizerName in options.recognizerOptions){
            const recognizer = this.manager.get(recognizerName);
            if (recognizer) {
                const recognizerOption = options.recognizerOptions[recognizerName];
                // `enable` is managed by the event registrations
                delete recognizerOption.enable;
                recognizer.set(recognizerOption);
            }
        }
        // Handle events not handled by Hammer.js:
        // - mouse wheel
        // - pointer/touch/mouse move
        this.wheelInput = new (0, $2f48018e669b380c$export$2e2bcd8739ae039)(element, this._onOtherEvent, {
            enable: false
        });
        this.moveInput = new (0, $859b18b18dc30513$export$2e2bcd8739ae039)(element, this._onOtherEvent, {
            enable: false
        });
        this.keyInput = new (0, $376b75237faf2ae2$export$2e2bcd8739ae039)(element, this._onOtherEvent, {
            enable: false,
            tabIndex: options.tabIndex
        });
        this.contextmenuInput = new (0, $8b4fbfbcbca96ee3$export$2e2bcd8739ae039)(element, this._onOtherEvent, {
            enable: false
        });
        // Register all existing events
        for (const [eventAlias, eventRegistrar] of this.events)if (!eventRegistrar.isEmpty()) {
            // Enable recognizer for this event.
            this._toggleRecognizer(eventRegistrar.recognizerName, true);
            this.manager.on(eventAlias, eventRegistrar.handleEvent);
        }
    }
    // Tear down internal event management implementations.
    destroy() {
        if (this.element) {
            // wheelInput etc. are created in setElement() and therefore
            // cannot exist if there is no element
            this.wheelInput.destroy();
            this.moveInput.destroy();
            this.keyInput.destroy();
            this.contextmenuInput.destroy();
            this.manager.destroy();
            this.wheelInput = null;
            this.moveInput = null;
            this.keyInput = null;
            this.contextmenuInput = null;
            this.manager = null;
            this.element = null;
        }
    }
    /** Register an event handler function to be called on `event` */ on(event, handler, opts) {
        this._addEventHandler(event, handler, opts, false);
    }
    once(event, handler, opts) {
        this._addEventHandler(event, handler, opts, true);
    }
    watch(event, handler, opts) {
        this._addEventHandler(event, handler, opts, false, true);
    }
    off(event, handler) {
        this._removeEventHandler(event, handler);
    }
    /*
     * Enable/disable recognizer for the given event
     */ _toggleRecognizer(name, enabled) {
        const { manager: manager  } = this;
        if (!manager) return;
        const recognizer = manager.get(name);
        // @ts-ignore
        if (recognizer && recognizer.options.enable !== enabled) {
            recognizer.set({
                enable: enabled
            });
            const fallbackRecognizers = (0, $368369ab2de6fcb8$export$3da361ddf819b1fc)[name];
            if (fallbackRecognizers && !this.options.recognizers) // Set default require failures
            // http://hammerjs.github.io/require-failure/
            fallbackRecognizers.forEach((otherName)=>{
                const otherRecognizer = manager.get(otherName);
                if (enabled) {
                    // Wait for this recognizer to fail
                    otherRecognizer.requireFailure(name);
                    /**
                         * This seems to be a bug in hammerjs:
                         * requireFailure() adds both ways
                         * dropRequireFailure() only drops one way
                         * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/
                           recognizer-constructor.js#L136
                         */ recognizer.dropRequireFailure(otherName);
                } else // Do not wait for this recognizer to fail
                otherRecognizer.dropRequireFailure(name);
            });
        }
        this.wheelInput.enableEventType(name, enabled);
        this.moveInput.enableEventType(name, enabled);
        this.keyInput.enableEventType(name, enabled);
        this.contextmenuInput.enableEventType(name, enabled);
    }
    /**
     * Process the event registration for a single event + handler.
     */ _addEventHandler(event, handler, opts, once, passive) {
        if (typeof event !== "string") {
            // @ts-ignore
            opts = handler;
            // If `event` is a map, call `on()` for each entry.
            for(const eventName in event)this._addEventHandler(eventName, event[eventName], opts, once, passive);
            return;
        }
        const { manager: manager , events: events  } = this;
        // Alias to a recognized gesture as necessary.
        const eventAlias = (0, $368369ab2de6fcb8$export$580af412e0595c74)[event] || event;
        let eventRegistrar = events.get(eventAlias);
        if (!eventRegistrar) {
            eventRegistrar = new (0, $e66c1fd4b977e653$export$2e2bcd8739ae039)(this);
            events.set(eventAlias, eventRegistrar);
            // Enable recognizer for this event.
            eventRegistrar.recognizerName = (0, $368369ab2de6fcb8$export$5e103639c5775d6b)[eventAlias] || eventAlias;
            // Listen to the event
            if (manager) manager.on(eventAlias, eventRegistrar.handleEvent);
        }
        eventRegistrar.add(event, handler, opts, once, passive);
        if (!eventRegistrar.isEmpty()) this._toggleRecognizer(eventRegistrar.recognizerName, true);
    }
    /**
     * Process the event deregistration for a single event + handler.
     */ _removeEventHandler(event, handler) {
        if (typeof event !== "string") {
            // If `event` is a map, call `off()` for each entry.
            for(const eventName in event)this._removeEventHandler(eventName, event[eventName]);
            return;
        }
        const { events: events  } = this;
        // Alias to a recognized gesture as necessary.
        const eventAlias = (0, $368369ab2de6fcb8$export$580af412e0595c74)[event] || event;
        const eventRegistrar = events.get(eventAlias);
        if (!eventRegistrar) return;
        eventRegistrar.remove(event, handler);
        if (eventRegistrar.isEmpty()) {
            const { recognizerName: recognizerName  } = eventRegistrar;
            // Disable recognizer if no more handlers are attached to its events
            let isRecognizerUsed = false;
            for (const eh of events.values())if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
                isRecognizerUsed = true;
                break;
            }
            if (!isRecognizerUsed) this._toggleRecognizer(recognizerName, false);
        }
    }
}






function $4afbf505f2c4bce1$var$noop() {}
const $4afbf505f2c4bce1$var$getCursor = ({ isDragging: isDragging  })=>isDragging ? "grabbing" : "grab";
const $4afbf505f2c4bce1$var$defaultProps = {
    id: "",
    width: "100%",
    height: "100%",
    style: null,
    viewState: null,
    initialViewState: null,
    pickingRadius: 0,
    layerFilter: null,
    glOptions: {},
    parameters: {},
    parent: null,
    gl: null,
    canvas: null,
    layers: [],
    effects: [],
    views: null,
    controller: null,
    useDevicePixels: true,
    touchAction: "none",
    eventRecognizerOptions: {},
    _framebuffer: null,
    _animate: false,
    _pickable: true,
    _typedArrayManagerProps: {},
    _customRender: null,
    onWebGLInitialized: $4afbf505f2c4bce1$var$noop,
    onResize: $4afbf505f2c4bce1$var$noop,
    onViewStateChange: $4afbf505f2c4bce1$var$noop,
    onInteractionStateChange: $4afbf505f2c4bce1$var$noop,
    onBeforeRender: $4afbf505f2c4bce1$var$noop,
    onAfterRender: $4afbf505f2c4bce1$var$noop,
    onLoad: $4afbf505f2c4bce1$var$noop,
    onError: (error)=>(0, $146cba582e8c799f$export$2e2bcd8739ae039).error(error.message)(),
    onHover: null,
    onClick: null,
    onDragStart: null,
    onDrag: null,
    onDragEnd: null,
    _onMetrics: null,
    getCursor: $4afbf505f2c4bce1$var$getCursor,
    getTooltip: null,
    debug: false,
    drawPickingColors: false
};
class $4afbf505f2c4bce1$export$2e2bcd8739ae039 {
    constructor(props){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "width", 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "height", 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "userData", {});
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "canvas", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewManager", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "layerManager", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "effectManager", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "deckRenderer", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "deckPicker", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "eventManager", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "tooltip", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "metrics", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "animationLoop", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "stats", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewState", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "cursorState", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_needsRedraw", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_pickRequest", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_lastPointerDownInfo", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_metricsCounter", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_onPointerMove", (event)=>{
            const { _pickRequest: _pickRequest  } = this;
            if (event.type === "pointerleave") {
                _pickRequest.x = -1;
                _pickRequest.y = -1;
                _pickRequest.radius = 0;
            } else if (event.leftButton || event.rightButton) return;
            else {
                const pos = event.offsetCenter;
                if (!pos) return;
                _pickRequest.x = pos.x;
                _pickRequest.y = pos.y;
                _pickRequest.radius = this.props.pickingRadius;
            }
            if (this.layerManager) this.layerManager.context.mousePosition = {
                x: _pickRequest.x,
                y: _pickRequest.y
            };
            _pickRequest.event = event;
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_onEvent", (event)=>{
            const eventOptions = (0, $b42a5b9aa3b1a41f$export$fa3d5b535a2458a1)[event.type];
            const pos = event.offsetCenter;
            if (!eventOptions || !pos || !this.layerManager) return;
            const layers = this.layerManager.getLayers();
            const info = this.deckPicker.getLastPickedObject({
                x: pos.x,
                y: pos.y,
                layers: layers,
                viewports: this.getViewports(pos)
            }, this._lastPointerDownInfo);
            const { layer: layer  } = info;
            const layerHandler = layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);
            const rootHandler = this.props[eventOptions.handler];
            let handled = false;
            if (layerHandler) handled = layerHandler.call(layer, info, event);
            if (!handled && rootHandler) rootHandler(info, event);
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_onPointerDown", (event)=>{
            const pos = event.offsetCenter;
            const pickedInfo = this._pick("pickObject", "pickObject Time", {
                x: pos.x,
                y: pos.y,
                radius: this.props.pickingRadius
            });
            this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;
        });
        this.props = {
            ...$4afbf505f2c4bce1$var$defaultProps,
            ...props
        };
        props = this.props;
        this._needsRedraw = "Initial render";
        this._pickRequest = {
            mode: "hover",
            x: -1,
            y: -1,
            radius: 0,
            event: null
        };
        this.cursorState = {
            isHovering: false,
            isDragging: false
        };
        if (props.viewState && props.initialViewState) (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")();
        if ((0, $ef7c7b0387e72f27$export$2e2bcd8739ae039)() === "IE") (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("IE 11 is not supported")();
        this.viewState = props.initialViewState;
        if (!props.gl) {
            if (typeof document !== "undefined") this.canvas = this._createCanvas(props);
        }
        this.animationLoop = this._createAnimationLoop(props);
        this.stats = new (0, $2fb061cfbc5cb32d$export$2e2bcd8739ae039)({
            id: "deck.gl"
        });
        this.metrics = {
            fps: 0,
            setPropsTime: 0,
            updateAttributesTime: 0,
            framesRedrawn: 0,
            pickTime: 0,
            pickCount: 0,
            gpuTime: 0,
            gpuTimePerFrame: 0,
            cpuTime: 0,
            cpuTimePerFrame: 0,
            bufferMemory: 0,
            textureMemory: 0,
            renderbufferMemory: 0,
            gpuMemory: 0
        };
        this._metricsCounter = 0;
        this.setProps(props);
        if (props._typedArrayManagerProps) (0, $e0cd51e92519f55c$export$2e2bcd8739ae039).setOptions(props._typedArrayManagerProps);
        this.animationLoop.start();
    }
    finalize() {
        var _this$layerManager, _this$viewManager, _this$effectManager, _this$deckRenderer, _this$deckPicker, _this$eventManager, _this$tooltip;
        this.animationLoop.stop();
        this.animationLoop = null;
        this._lastPointerDownInfo = null;
        (_this$layerManager = this.layerManager) === null || _this$layerManager === void 0 || _this$layerManager.finalize();
        this.layerManager = null;
        (_this$viewManager = this.viewManager) === null || _this$viewManager === void 0 || _this$viewManager.finalize();
        this.viewManager = null;
        (_this$effectManager = this.effectManager) === null || _this$effectManager === void 0 || _this$effectManager.finalize();
        this.effectManager = null;
        (_this$deckRenderer = this.deckRenderer) === null || _this$deckRenderer === void 0 || _this$deckRenderer.finalize();
        this.deckRenderer = null;
        (_this$deckPicker = this.deckPicker) === null || _this$deckPicker === void 0 || _this$deckPicker.finalize();
        this.deckPicker = null;
        (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 || _this$eventManager.destroy();
        this.eventManager = null;
        (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 || _this$tooltip.remove();
        this.tooltip = null;
        if (!this.props.canvas && !this.props.gl && this.canvas) {
            var _this$canvas$parentEl;
            (_this$canvas$parentEl = this.canvas.parentElement) === null || _this$canvas$parentEl === void 0 || _this$canvas$parentEl.removeChild(this.canvas);
            this.canvas = null;
        }
    }
    setProps(props) {
        this.stats.get("setProps Time").timeStart();
        if ("onLayerHover" in props) (0, $146cba582e8c799f$export$2e2bcd8739ae039).removed("onLayerHover", "onHover")();
        if ("onLayerClick" in props) (0, $146cba582e8c799f$export$2e2bcd8739ae039).removed("onLayerClick", "onClick")();
        if (props.initialViewState && !(0, $70a948cba88c73a3$export$9cb4719e2e525b7a)(this.props.initialViewState, props.initialViewState)) this.viewState = props.initialViewState;
        Object.assign(this.props, props);
        this._setCanvasSize(this.props);
        const resolvedProps = Object.create(this.props);
        Object.assign(resolvedProps, {
            views: this._getViews(),
            width: this.width,
            height: this.height,
            viewState: this._getViewState()
        });
        this.animationLoop.setProps(resolvedProps);
        if (this.layerManager) {
            this.viewManager.setProps(resolvedProps);
            this.layerManager.activateViewport(this.getViewports()[0]);
            this.layerManager.setProps(resolvedProps);
            this.effectManager.setProps(resolvedProps);
            this.deckRenderer.setProps(resolvedProps);
            this.deckPicker.setProps(resolvedProps);
        }
        this.stats.get("setProps Time").timeEnd();
    }
    needsRedraw(opts = {
        clearRedrawFlags: false
    }) {
        if (!this.layerManager) return false;
        if (this.props._animate) return "Deck._animate";
        let redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) this._needsRedraw = false;
        const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
        const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
        const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
        const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
        redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
        return redraw;
    }
    redraw(reason) {
        if (!this.layerManager) return;
        let redrawReason = this.needsRedraw({
            clearRedrawFlags: true
        });
        redrawReason = reason || redrawReason;
        if (!redrawReason) return;
        this.stats.get("Redraw Count").incrementCount();
        if (this.props._customRender) this.props._customRender(redrawReason);
        else this._drawLayers(redrawReason);
    }
    get isInitialized() {
        return this.viewManager !== null;
    }
    getViews() {
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(this.viewManager);
        return this.viewManager.views;
    }
    getViewports(rect) {
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(this.viewManager);
        return this.viewManager.getViewports(rect);
    }
    pickObject(opts) {
        const infos = this._pick("pickObject", "pickObject Time", opts).result;
        return infos.length ? infos[0] : null;
    }
    pickMultipleObjects(opts) {
        opts.depth = opts.depth || 10;
        return this._pick("pickObject", "pickMultipleObjects Time", opts).result;
    }
    pickObjects(opts) {
        return this._pick("pickObjects", "pickObjects Time", opts);
    }
    _addResources(resources, forceUpdate = false) {
        for(const id in resources)this.layerManager.resourceManager.add({
            resourceId: id,
            data: resources[id],
            forceUpdate: forceUpdate
        });
    }
    _removeResources(resourceIds) {
        for (const id of resourceIds)this.layerManager.resourceManager.remove(id);
    }
    _pick(method, statKey, opts) {
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(this.deckPicker);
        const { stats: stats  } = this;
        stats.get("Pick Count").incrementCount();
        stats.get(statKey).timeStart();
        const infos = this.deckPicker[method]({
            layers: this.layerManager.getLayers(opts),
            views: this.viewManager.getViews(),
            viewports: this.getViewports(opts),
            onViewportActive: this.layerManager.activateViewport,
            effects: this.effectManager.getEffects(),
            ...opts
        });
        stats.get(statKey).timeEnd();
        return infos;
    }
    _createCanvas(props) {
        let canvas = props.canvas;
        if (typeof canvas === "string") {
            canvas = document.getElementById(canvas);
            (0, $828c58095cddb61a$export$2e2bcd8739ae039)(canvas);
        }
        if (!canvas) {
            canvas = document.createElement("canvas");
            canvas.id = props.id || "deckgl-overlay";
            const parent = props.parent || document.body;
            parent.appendChild(canvas);
        }
        Object.assign(canvas.style, props.style);
        return canvas;
    }
    _setCanvasSize(props) {
        if (!this.canvas) return;
        const { width: width , height: height  } = props;
        if (width || width === 0) {
            const cssWidth = Number.isFinite(width) ? "".concat(width, "px") : width;
            this.canvas.style.width = cssWidth;
        }
        if (height || height === 0) {
            var _props$style;
            const cssHeight = Number.isFinite(height) ? "".concat(height, "px") : height;
            this.canvas.style.position = ((_props$style = props.style) === null || _props$style === void 0 ? void 0 : _props$style.position) || "absolute";
            this.canvas.style.height = cssHeight;
        }
    }
    _updateCanvasSize() {
        const { canvas: canvas  } = this;
        if (!canvas) return;
        const newWidth = canvas.clientWidth || canvas.width;
        const newHeight = canvas.clientHeight || canvas.height;
        if (newWidth !== this.width || newHeight !== this.height) {
            var _this$viewManager2;
            this.width = newWidth;
            this.height = newHeight;
            (_this$viewManager2 = this.viewManager) === null || _this$viewManager2 === void 0 || _this$viewManager2.setProps({
                width: newWidth,
                height: newHeight
            });
            this.props.onResize({
                width: newWidth,
                height: newHeight
            });
        }
    }
    _createAnimationLoop(props) {
        const { width: width , height: height , gl: gl , glOptions: glOptions , debug: debug , onError: onError , onBeforeRender: onBeforeRender , onAfterRender: onAfterRender , useDevicePixels: useDevicePixels  } = props;
        return new (0, $8a761c509fabf16c$export$2e2bcd8739ae039)({
            width: width,
            height: height,
            useDevicePixels: useDevicePixels,
            autoResizeViewport: false,
            gl: gl,
            onCreateContext: (opts)=>(0, $f89b67ad8c6f5746$export$a32ea65c51ffebe7)({
                    ...glOptions,
                    ...opts,
                    canvas: this.canvas,
                    debug: debug,
                    onContextLost: ()=>this._onContextLost()
                }),
            onInitialize: (context)=>this._setGLContext(context.gl),
            onRender: this._onRenderFrame.bind(this),
            onBeforeRender: onBeforeRender,
            onAfterRender: onAfterRender,
            onError: onError
        });
    }
    _getViewState() {
        return this.props.viewState || this.viewState;
    }
    _getViews() {
        let views = this.props.views || [
            new (0, $d73daa375e65bcb3$export$2e2bcd8739ae039)({
                id: "default-view"
            })
        ];
        views = Array.isArray(views) ? views : [
            views
        ];
        if (views.length && this.props.controller) views[0].props.controller = this.props.controller;
        return views;
    }
    _onContextLost() {
        const { onError: onError  } = this.props;
        if (this.animationLoop && onError) onError(new Error("WebGL context is lost"));
    }
    _pickAndCallback() {
        const { _pickRequest: _pickRequest  } = this;
        if (_pickRequest.event) {
            const { result: result , emptyInfo: emptyInfo  } = this._pick("pickObject", "pickObject Time", _pickRequest);
            this.cursorState.isHovering = result.length > 0;
            let pickedInfo = emptyInfo;
            let handled = false;
            for (const info of result){
                var _info$layer;
                pickedInfo = info;
                handled = ((_info$layer = info.layer) === null || _info$layer === void 0 ? void 0 : _info$layer.onHover(info, _pickRequest.event)) || handled;
            }
            if (!handled && this.props.onHover) this.props.onHover(pickedInfo, _pickRequest.event);
            if (this.props.getTooltip && this.tooltip) {
                const displayInfo = this.props.getTooltip(pickedInfo);
                this.tooltip.setTooltip(displayInfo, pickedInfo.x, pickedInfo.y);
            }
            _pickRequest.event = null;
        }
    }
    _updateCursor() {
        const container = this.props.parent || this.canvas;
        if (container) container.style.cursor = this.props.getCursor(this.cursorState);
    }
    _setGLContext(gl) {
        if (this.layerManager) return;
        if (!this.canvas) {
            this.canvas = gl.canvas;
            (0, $f89b67ad8c6f5746$export$6b6cef073fe6a207)(gl, {
                enable: true,
                copyState: true
            });
        }
        this.tooltip = new (0, $0ce0aac1c3cdf79a$export$2e2bcd8739ae039)(this.canvas);
        (0, $54220aa8b6471f1a$export$60752c4a8a24d484)(gl, {
            blend: true,
            blendFunc: [
                770,
                771,
                1,
                771
            ],
            polygonOffsetFill: true,
            depthTest: true,
            depthFunc: 515
        });
        this.props.onWebGLInitialized(gl);
        const timeline = new (0, $bc7bc101e53b8e33$export$e6a97ba2cae5bb94)();
        timeline.play();
        this.animationLoop.attachTimeline(timeline);
        this.eventManager = new (0, $1e4596bb66c8c182$export$2e2bcd8739ae039)(this.props.parent || gl.canvas, {
            touchAction: this.props.touchAction,
            recognizerOptions: this.props.eventRecognizerOptions,
            events: {
                pointerdown: this._onPointerDown,
                pointermove: this._onPointerMove,
                pointerleave: this._onPointerMove
            }
        });
        for(const eventType in 0, $b42a5b9aa3b1a41f$export$fa3d5b535a2458a1)this.eventManager.on(eventType, this._onEvent);
        this.viewManager = new (0, $12d396d6877d881f$export$2e2bcd8739ae039)({
            timeline: timeline,
            eventManager: this.eventManager,
            onViewStateChange: this._onViewStateChange.bind(this),
            onInteractionStateChange: this._onInteractionStateChange.bind(this),
            views: this._getViews(),
            viewState: this._getViewState(),
            width: this.width,
            height: this.height
        });
        const viewport = this.viewManager.getViewports()[0];
        this.layerManager = new (0, $6a52b0a4ad5491f9$export$2e2bcd8739ae039)(gl, {
            deck: this,
            stats: this.stats,
            viewport: viewport,
            timeline: timeline
        });
        this.effectManager = new (0, $6a78b0e959df691c$export$2e2bcd8739ae039)();
        this.deckRenderer = new (0, $44be24ae5116c7d5$export$2e2bcd8739ae039)(gl);
        this.deckPicker = new (0, $846591e5a404f643$export$2e2bcd8739ae039)(gl);
        this.setProps(this.props);
        this._updateCanvasSize();
        this.props.onLoad();
    }
    _drawLayers(redrawReason, renderOptions) {
        const { gl: gl  } = this.layerManager.context;
        (0, $54220aa8b6471f1a$export$60752c4a8a24d484)(gl, this.props.parameters);
        this.props.onBeforeRender({
            gl: gl
        });
        this.deckRenderer.renderLayers({
            target: this.props._framebuffer,
            layers: this.layerManager.getLayers(),
            viewports: this.viewManager.getViewports(),
            onViewportActive: this.layerManager.activateViewport,
            views: this.viewManager.getViews(),
            pass: "screen",
            redrawReason: redrawReason,
            effects: this.effectManager.getEffects(),
            ...renderOptions
        });
        this.props.onAfterRender({
            gl: gl
        });
    }
    _onRenderFrame(animationProps) {
        this._getFrameStats();
        if ((this._metricsCounter++) % 60 === 0) {
            this._getMetrics();
            this.stats.reset();
            (0, $146cba582e8c799f$export$2e2bcd8739ae039).table(4, this.metrics)();
            if (this.props._onMetrics) this.props._onMetrics(this.metrics);
        }
        this._updateCanvasSize();
        this._updateCursor();
        if (this.tooltip.isVisible && this.viewManager.needsRedraw()) this.tooltip.setTooltip(null);
        this.layerManager.updateLayers();
        this._pickAndCallback();
        this.redraw();
        if (this.viewManager) this.viewManager.updateViewStates();
    }
    _onViewStateChange(params) {
        const viewState = this.props.onViewStateChange(params) || params.viewState;
        if (this.viewState) {
            this.viewState = {
                ...this.viewState,
                [params.viewId]: viewState
            };
            if (!this.props.viewState) {
                if (this.viewManager) this.viewManager.setProps({
                    viewState: this.viewState
                });
            }
        }
    }
    _onInteractionStateChange(interactionState) {
        this.cursorState.isDragging = interactionState.isDragging || false;
        this.props.onInteractionStateChange(interactionState);
    }
    _getFrameStats() {
        const { stats: stats  } = this;
        stats.get("frameRate").timeEnd();
        stats.get("frameRate").timeStart();
        const animationLoopStats = this.animationLoop.stats;
        stats.get("GPU Time").addTime(animationLoopStats.get("GPU Time").lastTiming);
        stats.get("CPU Time").addTime(animationLoopStats.get("CPU Time").lastTiming);
    }
    _getMetrics() {
        const { metrics: metrics , stats: stats  } = this;
        metrics.fps = stats.get("frameRate").getHz();
        metrics.setPropsTime = stats.get("setProps Time").time;
        metrics.updateAttributesTime = stats.get("Update Attributes").time;
        metrics.framesRedrawn = stats.get("Redraw Count").count;
        metrics.pickTime = stats.get("pickObject Time").time + stats.get("pickMultipleObjects Time").time + stats.get("pickObjects Time").time;
        metrics.pickCount = stats.get("Pick Count").count;
        metrics.gpuTime = stats.get("GPU Time").time;
        metrics.cpuTime = stats.get("CPU Time").time;
        metrics.gpuTimePerFrame = stats.get("GPU Time").getAverageTime();
        metrics.cpuTimePerFrame = stats.get("CPU Time").getAverageTime();
        const memoryStats = (0, $0a3fbec7776af5cb$export$fb95d6e12d0fb414).get("Memory Usage");
        metrics.bufferMemory = memoryStats.get("Buffer Memory").count;
        metrics.textureMemory = memoryStats.get("Texture Memory").count;
        metrics.renderbufferMemory = memoryStats.get("Renderbuffer Memory").count;
        metrics.gpuMemory = memoryStats.get("GPU Memory").count;
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($4afbf505f2c4bce1$export$2e2bcd8739ae039, "defaultProps", $4afbf505f2c4bce1$var$defaultProps);
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($4afbf505f2c4bce1$export$2e2bcd8739ae039, "VERSION", (0, $fb7f1a5ab7b23558$export$2e2bcd8739ae039).VERSION);








class $2cbd04ac4b17a1fc$export$2e2bcd8739ae039 {
    constructor(dataColumn, opts){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "opts", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "source", void 0);
        this.opts = opts;
        this.source = dataColumn;
    }
    get value() {
        return this.source.value;
    }
    getValue() {
        const buffer = this.source.getBuffer();
        const accessor = this.getAccessor();
        if (buffer) return [
            buffer,
            accessor
        ];
        const { value: value  } = this.source;
        const { size: size  } = accessor;
        let constantValue = value;
        if (value && value.length !== size) {
            constantValue = new Float32Array(size);
            const index = accessor.elementOffset || 0;
            for(let i = 0; i < size; ++i)constantValue[i] = value[index + i];
        }
        return constantValue;
    }
    getAccessor() {
        return {
            ...this.source.getAccessor(),
            ...this.opts
        };
    }
}


function $91f302df6555cc52$export$99de3c889be30ec5(glType) {
    switch(glType){
        case 5126:
            return Float32Array;
        case 5130:
            return Float64Array;
        case 5123:
        case 33635:
        case 32819:
        case 32820:
            return Uint16Array;
        case 5125:
            return Uint32Array;
        case 5121:
            return Uint8ClampedArray;
        case 5120:
            return Int8Array;
        case 5122:
            return Int16Array;
        case 5124:
            return Int32Array;
        default:
            throw new Error("Unknown GL type");
    }
}





function $6d94c441f227935a$var$getStride(accessor) {
    return accessor.stride || accessor.size * accessor.bytesPerElement;
}
function $6d94c441f227935a$var$resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
    if (shaderAttributeOptions.offset) (0, $146cba582e8c799f$export$2e2bcd8739ae039).removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
    const stride = $6d94c441f227935a$var$getStride(baseAccessor);
    const vertexOffset = shaderAttributeOptions.vertexOffset !== undefined ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
    const elementOffset = shaderAttributeOptions.elementOffset || 0;
    const offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);
    return {
        ...shaderAttributeOptions,
        offset: offset,
        stride: stride
    };
}
function $6d94c441f227935a$var$resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
    const resolvedOptions = $6d94c441f227935a$var$resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
    return {
        high: resolvedOptions,
        low: {
            ...resolvedOptions,
            offset: resolvedOptions.offset + baseAccessor.size * 4
        }
    };
}
class $6d94c441f227935a$export$2e2bcd8739ae039 {
    constructor(gl, opts, state){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "gl", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "size", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "settings", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "value", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "doublePrecision", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_buffer", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "state", void 0);
        this.gl = gl;
        this.id = opts.id || "";
        this.size = opts.size || 1;
        const logicalType = opts.logicalType || opts.type;
        const doublePrecision = logicalType === 5130;
        let { defaultValue: defaultValue  } = opts;
        defaultValue = Number.isFinite(defaultValue) ? [
            defaultValue
        ] : defaultValue || new Array(this.size).fill(0);
        let bufferType;
        if (doublePrecision) bufferType = 5126;
        else if (!logicalType && opts.isIndexed) bufferType = gl && (0, $75ff6bc03ebbcaf6$export$805ddaeeece0413e)(gl, (0, $8cba87f65ded858b$export$d6a5c11f04f75862).ELEMENT_INDEX_UINT32) ? 5125 : 5123;
        else bufferType = logicalType || 5126;
        let defaultType = (0, $91f302df6555cc52$export$99de3c889be30ec5)(logicalType || bufferType || 5126);
        this.doublePrecision = doublePrecision;
        if (doublePrecision && opts.fp64 === false) defaultType = Float32Array;
        this.value = null;
        this.settings = {
            ...opts,
            defaultType: defaultType,
            defaultValue: defaultValue,
            logicalType: logicalType,
            type: bufferType,
            size: this.size,
            bytesPerElement: defaultType.BYTES_PER_ELEMENT
        };
        this.state = {
            ...state,
            externalBuffer: null,
            bufferAccessor: this.settings,
            allocatedValue: null,
            numInstances: 0,
            bounds: null,
            constant: false
        };
        this._buffer = null;
    }
    get isConstant() {
        return this.state.constant;
    }
    get buffer() {
        if (!this._buffer) {
            const { isIndexed: isIndexed , type: type  } = this.settings;
            this._buffer = new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(this.gl, {
                id: this.id,
                target: isIndexed ? 34963 : 34962,
                accessor: {
                    type: type
                }
            });
        }
        return this._buffer;
    }
    get byteOffset() {
        const accessor = this.getAccessor();
        if (accessor.vertexOffset) return accessor.vertexOffset * $6d94c441f227935a$var$getStride(accessor);
        return 0;
    }
    get numInstances() {
        return this.state.numInstances;
    }
    set numInstances(n) {
        this.state.numInstances = n;
    }
    delete() {
        if (this._buffer) {
            this._buffer.delete();
            this._buffer = null;
        }
        (0, $e0cd51e92519f55c$export$2e2bcd8739ae039).release(this.state.allocatedValue);
    }
    getShaderAttributes(id, options) {
        if (this.doublePrecision) {
            const shaderAttributes = {};
            const isBuffer64Bit = this.value instanceof Float64Array;
            const doubleShaderAttributeDefs = $6d94c441f227935a$var$resolveDoublePrecisionShaderAttributes(this.getAccessor(), options || {});
            shaderAttributes[id] = new (0, $2cbd04ac4b17a1fc$export$2e2bcd8739ae039)(this, doubleShaderAttributeDefs.high);
            shaderAttributes["".concat(id, "64Low")] = isBuffer64Bit ? new (0, $2cbd04ac4b17a1fc$export$2e2bcd8739ae039)(this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);
            return shaderAttributes;
        }
        if (options) {
            const shaderAttributeDef = $6d94c441f227935a$var$resolveShaderAttribute(this.getAccessor(), options);
            return {
                [id]: new (0, $2cbd04ac4b17a1fc$export$2e2bcd8739ae039)(this, shaderAttributeDef)
            };
        }
        return {
            [id]: this
        };
    }
    getBuffer() {
        if (this.state.constant) return null;
        return this.state.externalBuffer || this._buffer;
    }
    getValue() {
        if (this.state.constant) return this.value;
        return [
            this.getBuffer(),
            this.getAccessor()
        ];
    }
    getAccessor() {
        return this.state.bufferAccessor;
    }
    getBounds() {
        if (this.state.bounds) return this.state.bounds;
        let result = null;
        if (this.state.constant && this.value) {
            const min = Array.from(this.value);
            result = [
                min,
                min
            ];
        } else {
            const { value: value , numInstances: numInstances , size: size  } = this;
            const len = numInstances * size;
            if (value && len && value.length >= len) {
                const min = new Array(size).fill(Infinity);
                const max = new Array(size).fill(-Infinity);
                for(let i = 0; i < len;)for(let j = 0; j < size; j++){
                    const v = value[i++];
                    if (v < min[j]) min[j] = v;
                    if (v > max[j]) max[j] = v;
                }
                result = [
                    min,
                    max
                ];
            }
        }
        this.state.bounds = result;
        return result;
    }
    setData(data) {
        const { state: state  } = this;
        let opts;
        if (ArrayBuffer.isView(data)) opts = {
            value: data
        };
        else if (data instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) opts = {
            buffer: data
        };
        else opts = data;
        const accessor = {
            ...this.settings,
            ...opts
        };
        state.bufferAccessor = accessor;
        state.bounds = null;
        if (opts.constant) {
            let value = opts.value;
            value = this._normalizeValue(value, [], 0);
            if (this.settings.normalized) value = this.normalizeConstant(value);
            const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);
            if (!hasChanged) return false;
            state.externalBuffer = null;
            state.constant = true;
            this.value = value;
        } else if (opts.buffer) {
            const buffer = opts.buffer;
            state.externalBuffer = buffer;
            state.constant = false;
            this.value = opts.value || null;
            const isBuffer64Bit = opts.value instanceof Float64Array;
            accessor.type = opts.type || buffer.accessor.type;
            accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);
            accessor.stride = $6d94c441f227935a$var$getStride(accessor);
        } else if (opts.value) {
            this._checkExternalBuffer(opts);
            let value = opts.value;
            state.externalBuffer = null;
            state.constant = false;
            this.value = value;
            accessor.bytesPerElement = value.BYTES_PER_ELEMENT;
            accessor.stride = $6d94c441f227935a$var$getStride(accessor);
            const { buffer: buffer , byteOffset: byteOffset  } = this;
            if (this.doublePrecision && value instanceof Float64Array) value = (0, $97790275b37bd567$export$550bd089be4eedcb)(value, accessor);
            const requiredBufferSize = value.byteLength + byteOffset + accessor.stride * 2;
            if (buffer.byteLength < requiredBufferSize) buffer.reallocate(requiredBufferSize);
            buffer.setAccessor(null);
            buffer.subData({
                data: value,
                offset: byteOffset
            });
            accessor.type = opts.type || buffer.accessor.type;
        }
        return true;
    }
    updateSubBuffer(opts = {}) {
        this.state.bounds = null;
        const value = this.value;
        const { startOffset: startOffset = 0 , endOffset: endOffset  } = opts;
        this.buffer.subData({
            data: this.doublePrecision && value instanceof Float64Array ? (0, $97790275b37bd567$export$550bd089be4eedcb)(value, {
                size: this.size,
                startIndex: startOffset,
                endIndex: endOffset
            }) : value.subarray(startOffset, endOffset),
            offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset
        });
    }
    allocate(numInstances, copy = false) {
        const { state: state  } = this;
        const oldValue = state.allocatedValue;
        const value = (0, $e0cd51e92519f55c$export$2e2bcd8739ae039).allocate(oldValue, numInstances + 1, {
            size: this.size,
            type: this.settings.defaultType,
            copy: copy
        });
        this.value = value;
        const { buffer: buffer , byteOffset: byteOffset  } = this;
        if (buffer.byteLength < value.byteLength + byteOffset) {
            buffer.reallocate(value.byteLength + byteOffset);
            if (copy && oldValue) buffer.subData({
                data: oldValue instanceof Float64Array ? (0, $97790275b37bd567$export$550bd089be4eedcb)(oldValue, this) : oldValue,
                offset: byteOffset
            });
        }
        state.allocatedValue = value;
        state.constant = false;
        state.externalBuffer = null;
        state.bufferAccessor = this.settings;
        return true;
    }
    _checkExternalBuffer(opts) {
        const { value: value  } = opts;
        if (!ArrayBuffer.isView(value)) throw new Error("Attribute ".concat(this.id, " value is not TypedArray"));
        const ArrayType = this.settings.defaultType;
        let illegalArrayType = false;
        if (this.doublePrecision) illegalArrayType = value.BYTES_PER_ELEMENT < 4;
        if (illegalArrayType) throw new Error("Attribute ".concat(this.id, " does not support ").concat(value.constructor.name));
        if (!(value instanceof ArrayType) && this.settings.normalized && !("normalized" in opts)) (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("Attribute ".concat(this.id, " is normalized"))();
    }
    normalizeConstant(value) {
        switch(this.settings.type){
            case 5120:
                return new Float32Array(value).map((x)=>(x + 128) / 255 * 2 - 1);
            case 5122:
                return new Float32Array(value).map((x)=>(x + 32768) / 65535 * 2 - 1);
            case 5121:
                return new Float32Array(value).map((x)=>x / 255);
            case 5123:
                return new Float32Array(value).map((x)=>x / 65535);
            default:
                return value;
        }
    }
    _normalizeValue(value, out, start) {
        const { defaultValue: defaultValue , size: size  } = this.settings;
        if (Number.isFinite(value)) {
            out[start] = value;
            return out;
        }
        if (!value) {
            out[start] = defaultValue[0];
            return out;
        }
        switch(size){
            case 4:
                out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];
            case 3:
                out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];
            case 2:
                out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];
            case 1:
                out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];
                break;
            default:
                let i = size;
                while(--i >= 0)out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];
        }
        return out;
    }
    _areValuesEqual(value1, value2) {
        if (!value1 || !value2) return false;
        const { size: size  } = this;
        for(let i = 0; i < size; i++){
            if (value1[i] !== value2[i]) return false;
        }
        return true;
    }
}



const $98a5ab1cbad9db41$var$EMPTY_ARRAY = [];
const $98a5ab1cbad9db41$var$placeholderArray = [];
function $98a5ab1cbad9db41$export$f9c2f07d6e2a6221(data, startRow = 0, endRow = Infinity) {
    let iterable = $98a5ab1cbad9db41$var$EMPTY_ARRAY;
    const objectInfo = {
        index: -1,
        data: data,
        target: []
    };
    if (!data) iterable = $98a5ab1cbad9db41$var$EMPTY_ARRAY;
    else if (typeof data[Symbol.iterator] === "function") iterable = data;
    else if (data.length > 0) {
        $98a5ab1cbad9db41$var$placeholderArray.length = data.length;
        iterable = $98a5ab1cbad9db41$var$placeholderArray;
    }
    if (startRow > 0 || Number.isFinite(endRow)) {
        iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
        objectInfo.index = startRow - 1;
    }
    return {
        iterable: iterable,
        objectInfo: objectInfo
    };
}
function $98a5ab1cbad9db41$export$edb10ab8dd75a915(data) {
    return data && data[Symbol.asyncIterator];
}
function $98a5ab1cbad9db41$export$9c57eba05c1e4d4(typedArray, options) {
    const { size: size , stride: stride , offset: offset , startIndices: startIndices , nested: nested  } = options;
    const bytesPerElement = typedArray.BYTES_PER_ELEMENT;
    const elementStride = stride ? stride / bytesPerElement : size;
    const elementOffset = offset ? offset / bytesPerElement : 0;
    const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
    return (_, { index: index , target: target  })=>{
        if (!startIndices) {
            const sourceIndex = index * elementStride + elementOffset;
            for(let j = 0; j < size; j++)target[j] = typedArray[sourceIndex + j];
            return target;
        }
        const startIndex = startIndices[index];
        const endIndex = startIndices[index + 1] || vertexCount;
        let result;
        if (nested) {
            result = new Array(endIndex - startIndex);
            for(let i = startIndex; i < endIndex; i++){
                const sourceIndex = i * elementStride + elementOffset;
                target = new Array(size);
                for(let j = 0; j < size; j++)target[j] = typedArray[sourceIndex + j];
                result[i - startIndex] = target;
            }
        } else if (elementStride === size) result = typedArray.subarray(startIndex * size + elementOffset, endIndex * size + elementOffset);
        else {
            result = new typedArray.constructor((endIndex - startIndex) * size);
            let targetIndex = 0;
            for(let i = startIndex; i < endIndex; i++){
                const sourceIndex = i * elementStride + elementOffset;
                for(let j = 0; j < size; j++)result[targetIndex++] = typedArray[sourceIndex + j];
            }
        }
        return result;
    };
}



const $53843625f668a1e2$export$ccb33e29d92c9a58 = [];
const $53843625f668a1e2$export$3789e4b2a10baa2b = [
    [
        0,
        Infinity
    ]
];
function $53843625f668a1e2$export$e16d8520af44a096(rangeList, range) {
    if (rangeList === $53843625f668a1e2$export$3789e4b2a10baa2b) return rangeList;
    if (range[0] < 0) range[0] = 0;
    if (range[0] >= range[1]) return rangeList;
    const newRangeList = [];
    const len = rangeList.length;
    let insertPosition = 0;
    for(let i = 0; i < len; i++){
        const range0 = rangeList[i];
        if (range0[1] < range[0]) {
            newRangeList.push(range0);
            insertPosition = i + 1;
        } else if (range0[0] > range[1]) newRangeList.push(range0);
        else range = [
            Math.min(range0[0], range[0]),
            Math.max(range0[1], range[1])
        ];
    }
    newRangeList.splice(insertPosition, 0, range);
    return newRangeList;
}


function $d269dda6547e463a$var$padArrayChunk(options) {
    const { source: source , target: target , start: start = 0 , size: size , getData: getData  } = options;
    const end = options.end || target.length;
    const sourceLength = source.length;
    const targetLength = end - start;
    if (sourceLength > targetLength) {
        target.set(source.subarray(0, targetLength), start);
        return;
    }
    target.set(source, start);
    if (!getData) return;
    let i = sourceLength;
    while(i < targetLength){
        const datum = getData(i, source);
        for(let j = 0; j < size; j++){
            target[start + i] = datum[j] || 0;
            i++;
        }
    }
}
function $d269dda6547e463a$export$6735fc2994e30dd0({ source: source , target: target , size: size , getData: getData , sourceStartIndices: sourceStartIndices , targetStartIndices: targetStartIndices  }) {
    if (!Array.isArray(targetStartIndices)) {
        $d269dda6547e463a$var$padArrayChunk({
            source: source,
            target: target,
            size: size,
            getData: getData
        });
        return target;
    }
    let sourceIndex = 0;
    let targetIndex = 0;
    const getChunkData = getData && ((i, chunk)=>getData(i + targetIndex, chunk));
    const n = Math.min(sourceStartIndices.length, targetStartIndices.length);
    for(let i1 = 1; i1 < n; i1++){
        const nextSourceIndex = sourceStartIndices[i1] * size;
        const nextTargetIndex = targetStartIndices[i1] * size;
        $d269dda6547e463a$var$padArrayChunk({
            source: source.subarray(sourceIndex, nextSourceIndex),
            target: target,
            start: targetIndex,
            end: nextTargetIndex,
            size: size,
            getData: getChunkData
        });
        sourceIndex = nextSourceIndex;
        targetIndex = nextTargetIndex;
    }
    if (targetIndex < target.length) $d269dda6547e463a$var$padArrayChunk({
        source: [],
        target: target,
        start: targetIndex,
        size: size,
        getData: getChunkData
    });
    return target;
}


const $53f36c75cb59dde5$var$DEFAULT_TRANSITION_SETTINGS = {
    interpolation: {
        duration: 0,
        easing: (t)=>t
    },
    spring: {
        stiffness: 0.05,
        damping: 0.5
    }
};
function $53f36c75cb59dde5$export$47e87a95cf522e8c(userSettings, layerSettings) {
    if (!userSettings) return null;
    if (Number.isFinite(userSettings)) userSettings = {
        type: "interpolation",
        duration: userSettings
    };
    const type = userSettings.type || "interpolation";
    return {
        ...$53f36c75cb59dde5$var$DEFAULT_TRANSITION_SETTINGS[type],
        ...layerSettings,
        ...userSettings,
        type: type
    };
}
function $53f36c75cb59dde5$export$f3e2a32ee07ef92d(gl, attribute) {
    const buffer = attribute.getBuffer();
    if (buffer) return [
        buffer,
        {
            divisor: 0,
            size: attribute.size,
            normalized: attribute.settings.normalized
        }
    ];
    return attribute.value;
}
function $53f36c75cb59dde5$export$4f893656e30128e9(size) {
    switch(size){
        case 1:
            return "float";
        case 2:
            return "vec2";
        case 3:
            return "vec3";
        case 4:
            return "vec4";
        default:
            throw new Error('No defined attribute type for size "'.concat(size, '"'));
    }
}
function $53f36c75cb59dde5$export$1dcce42e2b71f528(buffers) {
    buffers.push(buffers.shift());
}
function $53f36c75cb59dde5$export$bd45d69169402c18(attribute, numInstances) {
    const { doublePrecision: doublePrecision , settings: settings , value: value , size: size  } = attribute;
    const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;
    return (settings.noAlloc ? value.length : numInstances * size) * multiplier;
}
function $53f36c75cb59dde5$export$28f1d2df7aaab3dd({ buffer: buffer , numInstances: numInstances , attribute: attribute , fromLength: fromLength , fromStartIndices: fromStartIndices , getData: getData = (x)=>x  }) {
    const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;
    const size = attribute.size * precisionMultiplier;
    const byteOffset = attribute.byteOffset;
    const toStartIndices = attribute.startIndices;
    const hasStartIndices = fromStartIndices && toStartIndices;
    const toLength = $53f36c75cb59dde5$export$bd45d69169402c18(attribute, numInstances);
    const isConstant = attribute.isConstant;
    if (!hasStartIndices && fromLength >= toLength) return;
    const toData = isConstant ? attribute.value : attribute.getBuffer().getData({
        srcByteOffset: byteOffset
    });
    if (attribute.settings.normalized && !isConstant) {
        const getter = getData;
        getData = (value, chunk)=>attribute.normalizeConstant(getter(value, chunk));
    }
    const getMissingData = isConstant ? (i, chunk)=>getData(toData, chunk) : (i, chunk)=>getData(toData.subarray(i, i + size), chunk);
    const source = buffer.getData({
        length: fromLength
    });
    const data = new Float32Array(toLength);
    (0, $d269dda6547e463a$export$6735fc2994e30dd0)({
        source: source,
        target: data,
        sourceStartIndices: fromStartIndices,
        targetStartIndices: toStartIndices,
        size: size,
        getData: getMissingData
    });
    if (buffer.byteLength < data.byteLength + byteOffset) buffer.reallocate(data.byteLength + byteOffset);
    buffer.subData({
        data: data,
        offset: byteOffset
    });
}


class $b8b4c55857af23f6$export$2e2bcd8739ae039 extends (0, $6d94c441f227935a$export$2e2bcd8739ae039) {
    constructor(gl, opts){
        super(gl, opts, {
            startIndices: null,
            lastExternalBuffer: null,
            binaryValue: null,
            binaryAccessor: null,
            needsUpdate: true,
            needsRedraw: false,
            updateRanges: $53843625f668a1e2$export$3789e4b2a10baa2b
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "constant", false);
        this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : undefined);
        Object.seal(this.settings);
        Object.seal(this.state);
        this._validateAttributeUpdaters();
    }
    get startIndices() {
        return this.state.startIndices;
    }
    set startIndices(layout) {
        this.state.startIndices = layout;
    }
    needsUpdate() {
        return this.state.needsUpdate;
    }
    needsRedraw({ clearChangedFlags: clearChangedFlags = false  } = {}) {
        const needsRedraw = this.state.needsRedraw;
        this.state.needsRedraw = needsRedraw && !clearChangedFlags;
        return needsRedraw;
    }
    getUpdateTriggers() {
        const { accessor: accessor  } = this.settings;
        return [
            this.id
        ].concat(typeof accessor !== "function" && accessor || []);
    }
    supportsTransition() {
        return Boolean(this.settings.transition);
    }
    getTransitionSetting(opts) {
        if (!opts || !this.supportsTransition()) return null;
        const { accessor: accessor  } = this.settings;
        const layerSettings = this.settings.transition;
        const userSettings = Array.isArray(accessor) ? opts[accessor.find((a)=>opts[a])] : opts[accessor];
        return (0, $53f36c75cb59dde5$export$47e87a95cf522e8c)(userSettings, layerSettings);
    }
    setNeedsUpdate(reason = this.id, dataRange) {
        this.state.needsUpdate = this.state.needsUpdate || reason;
        this.setNeedsRedraw(reason);
        if (dataRange) {
            const { startRow: startRow = 0 , endRow: endRow = Infinity  } = dataRange;
            this.state.updateRanges = $53843625f668a1e2$export$e16d8520af44a096(this.state.updateRanges, [
                startRow,
                endRow
            ]);
        } else this.state.updateRanges = $53843625f668a1e2$export$3789e4b2a10baa2b;
    }
    clearNeedsUpdate() {
        this.state.needsUpdate = false;
        this.state.updateRanges = $53843625f668a1e2$export$ccb33e29d92c9a58;
    }
    setNeedsRedraw(reason = this.id) {
        this.state.needsRedraw = this.state.needsRedraw || reason;
    }
    allocate(numInstances) {
        const { state: state , settings: settings  } = this;
        if (settings.noAlloc) return false;
        if (settings.update) {
            super.allocate(numInstances, state.updateRanges !== $53843625f668a1e2$export$3789e4b2a10baa2b);
            return true;
        }
        return false;
    }
    updateBuffer({ numInstances: numInstances , data: data , props: props , context: context  }) {
        if (!this.needsUpdate()) return false;
        const { state: { updateRanges: updateRanges  } , settings: { update: update , noAlloc: noAlloc  }  } = this;
        let updated = true;
        if (update) {
            for (const [startRow, endRow] of updateRanges)update.call(context, this, {
                data: data,
                startRow: startRow,
                endRow: endRow,
                props: props,
                numInstances: numInstances
            });
            if (!this.value) ;
            else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
                this.setData({
                    value: this.value,
                    constant: this.constant
                });
                this.constant = false;
            } else for (const [startRow1, endRow1] of updateRanges){
                const startOffset = Number.isFinite(startRow1) ? this.getVertexOffset(startRow1) : 0;
                const endOffset = Number.isFinite(endRow1) ? this.getVertexOffset(endRow1) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
                super.updateSubBuffer({
                    startOffset: startOffset,
                    endOffset: endOffset
                });
            }
            this._checkAttributeArray();
        } else updated = false;
        this.clearNeedsUpdate();
        this.setNeedsRedraw();
        return updated;
    }
    setConstantValue(value) {
        if (value === undefined || typeof value === "function") return false;
        const hasChanged = this.setData({
            constant: true,
            value: value
        });
        if (hasChanged) this.setNeedsRedraw();
        this.clearNeedsUpdate();
        return true;
    }
    setExternalBuffer(buffer) {
        const { state: state  } = this;
        if (!buffer) {
            state.lastExternalBuffer = null;
            return false;
        }
        this.clearNeedsUpdate();
        if (state.lastExternalBuffer === buffer) return true;
        state.lastExternalBuffer = buffer;
        this.setNeedsRedraw();
        this.setData(buffer);
        return true;
    }
    setBinaryValue(buffer, startIndices = null) {
        const { state: state , settings: settings  } = this;
        if (!buffer) {
            state.binaryValue = null;
            state.binaryAccessor = null;
            return false;
        }
        if (settings.noAlloc) return false;
        if (state.binaryValue === buffer) {
            this.clearNeedsUpdate();
            return true;
        }
        state.binaryValue = buffer;
        this.setNeedsRedraw();
        const needsUpdate = settings.transform || startIndices !== this.startIndices;
        if (needsUpdate) {
            if (ArrayBuffer.isView(buffer)) buffer = {
                value: buffer
            };
            const binaryValue = buffer;
            (0, $828c58095cddb61a$export$2e2bcd8739ae039)(ArrayBuffer.isView(binaryValue.value), "invalid ".concat(settings.accessor));
            const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;
            state.binaryAccessor = (0, $98a5ab1cbad9db41$export$9c57eba05c1e4d4)(binaryValue.value, {
                size: binaryValue.size || this.size,
                stride: binaryValue.stride,
                offset: binaryValue.offset,
                startIndices: startIndices,
                nested: needsNormalize
            });
            return false;
        }
        this.clearNeedsUpdate();
        this.setData(buffer);
        return true;
    }
    getVertexOffset(row) {
        const { startIndices: startIndices  } = this;
        const vertexIndex = startIndices ? startIndices[row] : row;
        return vertexIndex * this.size;
    }
    getShaderAttributes() {
        const shaderAttributeDefs = this.settings.shaderAttributes || {
            [this.id]: null
        };
        const shaderAttributes = {};
        for(const shaderAttributeName in shaderAttributeDefs)Object.assign(shaderAttributes, super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));
        return shaderAttributes;
    }
    _autoUpdater(attribute, { data: data , startRow: startRow , endRow: endRow , props: props , numInstances: numInstances  }) {
        if (attribute.constant) return;
        const { settings: settings , state: state , value: value , size: size , startIndices: startIndices  } = attribute;
        const { accessor: accessor , transform: transform  } = settings;
        const accessorFunc = state.binaryAccessor || (typeof accessor === "function" ? accessor : props[accessor]);
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(typeof accessorFunc === "function", 'accessor "'.concat(accessor, '" is not a function'));
        let i = attribute.getVertexOffset(startRow);
        const { iterable: iterable , objectInfo: objectInfo  } = (0, $98a5ab1cbad9db41$export$f9c2f07d6e2a6221)(data, startRow, endRow);
        for (const object of iterable){
            objectInfo.index++;
            let objectValue = accessorFunc(object, objectInfo);
            if (transform) objectValue = transform.call(this, objectValue);
            if (startIndices) {
                const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];
                if (objectValue && Array.isArray(objectValue[0])) {
                    let startIndex = i;
                    for (const item of objectValue){
                        attribute._normalizeValue(item, value, startIndex);
                        startIndex += size;
                    }
                } else if (objectValue && objectValue.length > size) value.set(objectValue, i);
                else {
                    attribute._normalizeValue(objectValue, objectInfo.target, 0);
                    (0, $755f3c37a143f46e$export$57295b69bf9c5d15)({
                        target: value,
                        source: objectInfo.target,
                        start: i,
                        count: numVertices
                    });
                }
                i += numVertices * size;
            } else {
                attribute._normalizeValue(objectValue, value, i);
                i += size;
            }
        }
    }
    _validateAttributeUpdaters() {
        const { settings: settings  } = this;
        const hasUpdater = settings.noAlloc || typeof settings.update === "function";
        if (!hasUpdater) throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
    }
    _checkAttributeArray() {
        const { value: value  } = this;
        const limit = Math.min(4, this.size);
        if (value && value.length >= limit) {
            let valid = true;
            switch(limit){
                case 4:
                    valid = valid && Number.isFinite(value[3]);
                case 3:
                    valid = valid && Number.isFinite(value[2]);
                case 2:
                    valid = valid && Number.isFinite(value[1]);
                case 1:
                    valid = valid && Number.isFinite(value[0]);
                    break;
                default:
                    valid = false;
            }
            if (!valid) throw new Error("Illegal attribute generated for ".concat(this.id));
        }
    }
}











class $d18e9b9fa4b85e18$export$2e2bcd8739ae039 {
    constructor({ gl: gl , attribute: attribute , timeline: timeline  }){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "gl", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "type", "interpolation");
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "attributeInTransition", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "settings", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "attribute", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transition", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "currentStartIndices", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "currentLength", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transform", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "buffers", void 0);
        this.gl = gl;
        this.transition = new (0, $c302e779b9092c62$export$2e2bcd8739ae039)(timeline);
        this.attribute = attribute;
        this.attributeInTransition = new (0, $b8b4c55857af23f6$export$2e2bcd8739ae039)(gl, attribute.settings);
        this.currentStartIndices = attribute.startIndices;
        this.currentLength = 0;
        this.transform = $d18e9b9fa4b85e18$var$getTransform(gl, attribute);
        const bufferOpts = {
            byteLength: 0,
            usage: 35050
        };
        this.buffers = [
            new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(gl, bufferOpts),
            new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(gl, bufferOpts)
        ];
    }
    get inProgress() {
        return this.transition.inProgress;
    }
    start(transitionSettings, numInstances) {
        if (transitionSettings.duration <= 0) {
            this.transition.cancel();
            return;
        }
        this.settings = transitionSettings;
        const { gl: gl , buffers: buffers , attribute: attribute  } = this;
        (0, $53f36c75cb59dde5$export$1dcce42e2b71f528)(buffers);
        const padBufferOpts = {
            numInstances: numInstances,
            attribute: attribute,
            fromLength: this.currentLength,
            fromStartIndices: this.currentStartIndices,
            getData: transitionSettings.enter
        };
        for (const buffer of buffers)(0, $53f36c75cb59dde5$export$28f1d2df7aaab3dd)({
            buffer: buffer,
            ...padBufferOpts
        });
        this.currentStartIndices = attribute.startIndices;
        this.currentLength = (0, $53f36c75cb59dde5$export$bd45d69169402c18)(attribute, numInstances);
        this.attributeInTransition.setData({
            buffer: buffers[1],
            value: attribute.value
        });
        this.transition.start(transitionSettings);
        this.transform.update({
            elementCount: Math.floor(this.currentLength / attribute.size),
            sourceBuffers: {
                aFrom: buffers[0],
                aTo: (0, $53f36c75cb59dde5$export$f3e2a32ee07ef92d)(gl, attribute)
            },
            feedbackBuffers: {
                vCurrent: buffers[1]
            }
        });
    }
    update() {
        const updated = this.transition.update();
        if (updated) {
            const { duration: duration , easing: easing  } = this.settings;
            const { time: time  } = this.transition;
            let t = time / duration;
            if (easing) t = easing(t);
            this.transform.run({
                uniforms: {
                    time: t
                }
            });
        }
        return updated;
    }
    cancel() {
        this.transition.cancel();
        this.transform.delete();
        for (const buffer of this.buffers)buffer.delete();
        this.buffers.length = 0;
    }
}
const $d18e9b9fa4b85e18$var$vs = "\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n";
function $d18e9b9fa4b85e18$var$getTransform(gl, attribute) {
    const attributeType = (0, $53f36c75cb59dde5$export$4f893656e30128e9)(attribute.size);
    return new (0, $00030bb52e16e5ae$export$2e2bcd8739ae039)(gl, {
        vs: $d18e9b9fa4b85e18$var$vs,
        defines: {
            ATTRIBUTE_TYPE: attributeType
        },
        varyings: [
            "vCurrent"
        ]
    });
}







class $4f4b22efa0676c69$export$2e2bcd8739ae039 {
    constructor({ gl: gl , attribute: attribute , timeline: timeline  }){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "gl", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "type", "spring");
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "attributeInTransition", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "settings", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "attribute", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transition", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "currentStartIndices", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "currentLength", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "texture", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "framebuffer", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transform", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "buffers", void 0);
        this.gl = gl;
        this.type = "spring";
        this.transition = new (0, $c302e779b9092c62$export$2e2bcd8739ae039)(timeline);
        this.attribute = attribute;
        this.attributeInTransition = new (0, $b8b4c55857af23f6$export$2e2bcd8739ae039)(gl, {
            ...attribute.settings,
            normalized: false
        });
        this.currentStartIndices = attribute.startIndices;
        this.currentLength = 0;
        this.texture = $4f4b22efa0676c69$var$getTexture(gl);
        this.framebuffer = $4f4b22efa0676c69$var$getFramebuffer(gl, this.texture);
        this.transform = $4f4b22efa0676c69$var$getTransform(gl, attribute, this.framebuffer);
        const bufferOpts = {
            byteLength: 0,
            usage: 35050
        };
        this.buffers = [
            new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(gl, bufferOpts),
            new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(gl, bufferOpts),
            new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(gl, bufferOpts)
        ];
    }
    get inProgress() {
        return this.transition.inProgress;
    }
    start(transitionSettings, numInstances) {
        const { gl: gl , buffers: buffers , attribute: attribute  } = this;
        const padBufferOpts = {
            numInstances: numInstances,
            attribute: attribute,
            fromLength: this.currentLength,
            fromStartIndices: this.currentStartIndices,
            getData: transitionSettings.enter
        };
        for (const buffer of buffers)(0, $53f36c75cb59dde5$export$28f1d2df7aaab3dd)({
            buffer: buffer,
            ...padBufferOpts
        });
        this.settings = transitionSettings;
        this.currentStartIndices = attribute.startIndices;
        this.currentLength = (0, $53f36c75cb59dde5$export$bd45d69169402c18)(attribute, numInstances);
        this.attributeInTransition.setData({
            buffer: buffers[1],
            value: attribute.value
        });
        this.transition.start({
            ...transitionSettings,
            duration: Infinity
        });
        this.transform.update({
            elementCount: Math.floor(this.currentLength / attribute.size),
            sourceBuffers: {
                aTo: (0, $53f36c75cb59dde5$export$f3e2a32ee07ef92d)(gl, attribute)
            }
        });
    }
    update() {
        const { buffers: buffers , transform: transform , framebuffer: framebuffer , transition: transition  } = this;
        const updated = transition.update();
        if (!updated) return false;
        const settings = this.settings;
        transform.update({
            sourceBuffers: {
                aPrev: buffers[0],
                aCur: buffers[1]
            },
            feedbackBuffers: {
                vNext: buffers[2]
            }
        });
        transform.run({
            framebuffer: framebuffer,
            discard: false,
            clearRenderTarget: true,
            uniforms: {
                stiffness: settings.stiffness,
                damping: settings.damping
            },
            parameters: {
                depthTest: false,
                blend: true,
                viewport: [
                    0,
                    0,
                    1,
                    1
                ],
                blendFunc: [
                    1,
                    1
                ],
                blendEquation: [
                    32776,
                    32776
                ]
            }
        });
        (0, $53f36c75cb59dde5$export$1dcce42e2b71f528)(buffers);
        this.attributeInTransition.setData({
            buffer: buffers[1],
            value: this.attribute.value
        });
        const isTransitioning = (0, $c192e756436d1779$export$f9f2f48e7f9faaa5)(framebuffer)[0] > 0;
        if (!isTransitioning) transition.end();
        return true;
    }
    cancel() {
        this.transition.cancel();
        this.transform.delete();
        for (const buffer of this.buffers)buffer.delete();
        this.buffers.length = 0;
        this.texture.delete();
        this.framebuffer.delete();
    }
}
function $4f4b22efa0676c69$var$getTransform(gl, attribute, framebuffer) {
    const attributeType = (0, $53f36c75cb59dde5$export$4f893656e30128e9)(attribute.size);
    return new (0, $00030bb52e16e5ae$export$2e2bcd8739ae039)(gl, {
        framebuffer: framebuffer,
        vs: "\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nattribute ATTRIBUTE_TYPE aPrev;\nattribute ATTRIBUTE_TYPE aCur;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vNext;\nvarying float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n",
        fs: "\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nvarying float vIsTransitioningFlag;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0);\n}",
        defines: {
            ATTRIBUTE_TYPE: attributeType
        },
        varyings: [
            "vNext"
        ]
    });
}
function $4f4b22efa0676c69$var$getTexture(gl) {
    return new (0, $df31c887249e3faa$export$2e2bcd8739ae039)(gl, {
        data: new Uint8Array(4),
        format: 6408,
        type: 5121,
        border: 0,
        mipmaps: false,
        dataFormat: 6408,
        width: 1,
        height: 1
    });
}
function $4f4b22efa0676c69$var$getFramebuffer(gl, texture) {
    return new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(gl, {
        id: "spring-transition-is-transitioning-framebuffer",
        width: 1,
        height: 1,
        attachments: {
            [36064]: texture
        }
    });
}



const $e3df2d5e12435106$var$TRANSITION_TYPES = {
    interpolation: (0, $d18e9b9fa4b85e18$export$2e2bcd8739ae039),
    spring: (0, $4f4b22efa0676c69$export$2e2bcd8739ae039)
};
class $e3df2d5e12435106$export$2e2bcd8739ae039 {
    constructor(gl, { id: id , timeline: timeline  }){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "isSupported", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "gl", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "timeline", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transitions", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "needsRedraw", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "numInstances", void 0);
        this.id = id;
        this.gl = gl;
        this.timeline = timeline;
        this.transitions = {};
        this.needsRedraw = false;
        this.numInstances = 1;
        this.isSupported = (0, $00030bb52e16e5ae$export$2e2bcd8739ae039).isSupported(gl);
    }
    finalize() {
        for(const attributeName in this.transitions)this._removeTransition(attributeName);
    }
    update({ attributes: attributes , transitions: transitions , numInstances: numInstances  }) {
        this.numInstances = numInstances || 1;
        for(const attributeName in attributes){
            const attribute = attributes[attributeName];
            const settings = attribute.getTransitionSetting(transitions);
            if (!settings) continue;
            this._updateAttribute(attributeName, attribute, settings);
        }
        for(const attributeName1 in this.transitions){
            const attribute = attributes[attributeName1];
            if (!attribute || !attribute.getTransitionSetting(transitions)) this._removeTransition(attributeName1);
        }
    }
    hasAttribute(attributeName) {
        const transition = this.transitions[attributeName];
        return transition && transition.inProgress;
    }
    getAttributes() {
        const animatedAttributes = {};
        for(const attributeName in this.transitions){
            const transition = this.transitions[attributeName];
            if (transition.inProgress) animatedAttributes[attributeName] = transition.attributeInTransition;
        }
        return animatedAttributes;
    }
    run() {
        if (!this.isSupported || this.numInstances === 0) return false;
        for(const attributeName in this.transitions){
            const updated = this.transitions[attributeName].update();
            if (updated) this.needsRedraw = true;
        }
        const needsRedraw = this.needsRedraw;
        this.needsRedraw = false;
        return needsRedraw;
    }
    _removeTransition(attributeName) {
        this.transitions[attributeName].cancel();
        delete this.transitions[attributeName];
    }
    _updateAttribute(attributeName, attribute, settings) {
        const transition = this.transitions[attributeName];
        let isNew = !transition || transition.type !== settings.type;
        if (isNew) {
            if (!this.isSupported) {
                (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("WebGL2 not supported by this browser. Transition for ".concat(attributeName, " is disabled."))();
                return;
            }
            if (transition) this._removeTransition(attributeName);
            const TransitionType = $e3df2d5e12435106$var$TRANSITION_TYPES[settings.type];
            if (TransitionType) this.transitions[attributeName] = new TransitionType({
                attribute: attribute,
                timeline: this.timeline,
                gl: this.gl
            });
            else {
                (0, $146cba582e8c799f$export$2e2bcd8739ae039).error("unsupported transition type '".concat(settings.type, "'"))();
                isNew = false;
            }
        }
        if (isNew || attribute.needsRedraw()) {
            this.needsRedraw = true;
            this.transitions[attributeName].start(settings, this.numInstances);
        }
    }
}


const $1bed349e8c64a1f7$var$TRACE_INVALIDATE = "attributeManager.invalidate";
const $1bed349e8c64a1f7$var$TRACE_UPDATE_START = "attributeManager.updateStart";
const $1bed349e8c64a1f7$var$TRACE_UPDATE_END = "attributeManager.updateEnd";
const $1bed349e8c64a1f7$var$TRACE_ATTRIBUTE_UPDATE_START = "attribute.updateStart";
const $1bed349e8c64a1f7$var$TRACE_ATTRIBUTE_ALLOCATE = "attribute.allocate";
const $1bed349e8c64a1f7$var$TRACE_ATTRIBUTE_UPDATE_END = "attribute.updateEnd";
class $1bed349e8c64a1f7$export$2e2bcd8739ae039 {
    constructor(gl, { id: id = "attribute-manager" , stats: stats , timeline: timeline  } = {}){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "gl", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "attributes", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "updateTriggers", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "needsRedraw", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "userData", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "stats", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "attributeTransitionManager", void 0);
        this.id = id;
        this.gl = gl;
        this.attributes = {};
        this.updateTriggers = {};
        this.needsRedraw = true;
        this.userData = {};
        this.stats = stats;
        this.attributeTransitionManager = new (0, $e3df2d5e12435106$export$2e2bcd8739ae039)(gl, {
            id: "".concat(id, "-transitions"),
            timeline: timeline
        });
        Object.seal(this);
    }
    finalize() {
        for(const attributeName in this.attributes)this.attributes[attributeName].delete();
        this.attributeTransitionManager.finalize();
    }
    getNeedsRedraw(opts = {
        clearRedrawFlags: false
    }) {
        const redraw = this.needsRedraw;
        this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
        return redraw && this.id;
    }
    setNeedsRedraw() {
        this.needsRedraw = true;
    }
    add(attributes) {
        this._add(attributes);
    }
    addInstanced(attributes) {
        this._add(attributes, {
            instanced: 1
        });
    }
    remove(attributeNameArray) {
        for (const name of attributeNameArray)if (this.attributes[name] !== undefined) {
            this.attributes[name].delete();
            delete this.attributes[name];
        }
    }
    invalidate(triggerName, dataRange) {
        const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($1bed349e8c64a1f7$var$TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
    }
    invalidateAll(dataRange) {
        for(const attributeName in this.attributes)this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($1bed349e8c64a1f7$var$TRACE_INVALIDATE, this, "all");
    }
    update({ data: data , numInstances: numInstances , startIndices: startIndices = null , transitions: transitions , props: props = {} , buffers: buffers = {} , context: context = {}  }) {
        let updated = false;
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($1bed349e8c64a1f7$var$TRACE_UPDATE_START, this);
        if (this.stats) this.stats.get("Update Attributes").timeStart();
        for(const attributeName in this.attributes){
            const attribute = this.attributes[attributeName];
            const accessorName = attribute.settings.accessor;
            attribute.startIndices = startIndices;
            attribute.numInstances = numInstances;
            if (props[attributeName]) (0, $146cba582e8c799f$export$2e2bcd8739ae039).removed("props.".concat(attributeName), "data.attributes.".concat(attributeName))();
            if (attribute.setExternalBuffer(buffers[attributeName])) ;
            else if (attribute.setBinaryValue(typeof accessorName === "string" ? buffers[accessorName] : undefined, data.startIndices)) ;
            else if (typeof accessorName === "string" && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) ;
            else if (attribute.needsUpdate()) {
                updated = true;
                this._updateAttribute({
                    attribute: attribute,
                    numInstances: numInstances,
                    data: data,
                    props: props,
                    context: context
                });
            }
            this.needsRedraw = this.needsRedraw || attribute.needsRedraw();
        }
        if (updated) (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($1bed349e8c64a1f7$var$TRACE_UPDATE_END, this, numInstances);
        if (this.stats) this.stats.get("Update Attributes").timeEnd();
        this.attributeTransitionManager.update({
            attributes: this.attributes,
            numInstances: numInstances,
            transitions: transitions
        });
    }
    updateTransition() {
        const { attributeTransitionManager: attributeTransitionManager  } = this;
        const transitionUpdated = attributeTransitionManager.run();
        this.needsRedraw = this.needsRedraw || transitionUpdated;
        return transitionUpdated;
    }
    getAttributes() {
        return this.attributes;
    }
    getChangedAttributes(opts = {
        clearChangedFlags: false
    }) {
        const { attributes: attributes , attributeTransitionManager: attributeTransitionManager  } = this;
        const changedAttributes = {
            ...attributeTransitionManager.getAttributes()
        };
        for(const attributeName in attributes){
            const attribute = attributes[attributeName];
            if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) changedAttributes[attributeName] = attribute;
        }
        return changedAttributes;
    }
    getShaderAttributes(attributes, excludeAttributes = {}) {
        if (!attributes) attributes = this.getAttributes();
        const shaderAttributes = {};
        for(const attributeName in attributes)if (!excludeAttributes[attributeName]) Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());
        return shaderAttributes;
    }
    _add(attributes, extraProps = {}) {
        for(const attributeName in attributes){
            const attribute = attributes[attributeName];
            this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);
        }
        this._mapUpdateTriggersToAttributes();
    }
    _createAttribute(name, attribute, extraProps) {
        const props = {
            ...attribute,
            id: name,
            size: attribute.isIndexed && 1 || attribute.size || 1,
            divisor: extraProps.instanced ? 1 : attribute.divisor || 0
        };
        return new (0, $b8b4c55857af23f6$export$2e2bcd8739ae039)(this.gl, props);
    }
    _mapUpdateTriggersToAttributes() {
        const triggers = {};
        for(const attributeName in this.attributes){
            const attribute = this.attributes[attributeName];
            attribute.getUpdateTriggers().forEach((triggerName)=>{
                if (!triggers[triggerName]) triggers[triggerName] = [];
                triggers[triggerName].push(attributeName);
            });
        }
        this.updateTriggers = triggers;
    }
    _invalidateTrigger(triggerName, dataRange) {
        const { attributes: attributes , updateTriggers: updateTriggers  } = this;
        const invalidatedAttributes = updateTriggers[triggerName];
        if (invalidatedAttributes) invalidatedAttributes.forEach((name)=>{
            const attribute = attributes[name];
            if (attribute) attribute.setNeedsUpdate(attribute.id, dataRange);
        });
        return invalidatedAttributes;
    }
    _updateAttribute(opts) {
        const { attribute: attribute , numInstances: numInstances  } = opts;
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($1bed349e8c64a1f7$var$TRACE_ATTRIBUTE_UPDATE_START, attribute);
        if (attribute.constant) {
            attribute.setConstantValue(attribute.value);
            return;
        }
        if (attribute.allocate(numInstances)) (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($1bed349e8c64a1f7$var$TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
        const updated = attribute.updateBuffer(opts);
        if (updated) {
            this.needsRedraw = true;
            (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($1bed349e8c64a1f7$var$TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
        }
    }
}





class $d0094bf136200100$export$2e2bcd8739ae039 extends (0, $c302e779b9092c62$export$2e2bcd8739ae039) {
    get value() {
        return this._value;
    }
    _onUpdate() {
        const { time: time , settings: { fromValue: fromValue , toValue: toValue , duration: duration , easing: easing  }  } = this;
        const t = easing(time / duration);
        this._value = (0, $53a37c44451cea56$export$3a89f8d6f6bf6c9f)(fromValue, toValue, t);
    }
}



const $df5592b22cd06e80$var$EPSILON = 1e-5;
function $df5592b22cd06e80$var$updateSpringElement(prev, cur, dest, damping, stiffness) {
    const velocity = cur - prev;
    const delta = dest - cur;
    const spring = delta * stiffness;
    const damper = -velocity * damping;
    return spring + damper + velocity + cur;
}
function $df5592b22cd06e80$var$updateSpring(prev, cur, dest, damping, stiffness) {
    if (Array.isArray(dest)) {
        const next = [];
        for(let i = 0; i < dest.length; i++)next[i] = $df5592b22cd06e80$var$updateSpringElement(prev[i], cur[i], dest[i], damping, stiffness);
        return next;
    }
    return $df5592b22cd06e80$var$updateSpringElement(prev, cur, dest, damping, stiffness);
}
function $df5592b22cd06e80$var$distance(value1, value2) {
    if (Array.isArray(value1)) {
        let distanceSquare = 0;
        for(let i = 0; i < value1.length; i++){
            const d = value1[i] - value2[i];
            distanceSquare += d * d;
        }
        return Math.sqrt(distanceSquare);
    }
    return Math.abs(value1 - value2);
}
class $df5592b22cd06e80$export$2e2bcd8739ae039 extends (0, $c302e779b9092c62$export$2e2bcd8739ae039) {
    get value() {
        return this._currValue;
    }
    _onUpdate() {
        const { fromValue: fromValue , toValue: toValue , damping: damping , stiffness: stiffness  } = this.settings;
        const { _prevValue: _prevValue = fromValue , _currValue: _currValue = fromValue  } = this;
        let nextValue = $df5592b22cd06e80$var$updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
        const delta = $df5592b22cd06e80$var$distance(nextValue, toValue);
        const velocity = $df5592b22cd06e80$var$distance(nextValue, _currValue);
        if (delta < $df5592b22cd06e80$var$EPSILON && velocity < $df5592b22cd06e80$var$EPSILON) {
            nextValue = toValue;
            this.end();
        }
        this._prevValue = _currValue;
        this._currValue = nextValue;
    }
}



const $bf7908ceda7e0357$var$TRANSITION_TYPES = {
    interpolation: (0, $d0094bf136200100$export$2e2bcd8739ae039),
    spring: (0, $df5592b22cd06e80$export$2e2bcd8739ae039)
};
class $bf7908ceda7e0357$export$2e2bcd8739ae039 {
    constructor(timeline){
        this.transitions = new Map();
        this.timeline = timeline;
    }
    get active() {
        return this.transitions.size > 0;
    }
    add(key, fromValue, toValue, settings) {
        const { transitions: transitions  } = this;
        if (transitions.has(key)) {
            const transition = transitions.get(key);
            const { value: value = transition.settings.fromValue  } = transition;
            fromValue = value;
            this.remove(key);
        }
        settings = (0, $53f36c75cb59dde5$export$47e87a95cf522e8c)(settings);
        if (!settings) return;
        const TransitionType = $bf7908ceda7e0357$var$TRANSITION_TYPES[settings.type];
        if (!TransitionType) {
            (0, $146cba582e8c799f$export$2e2bcd8739ae039).error("unsupported transition type '".concat(settings.type, "'"))();
            return;
        }
        const transition = new TransitionType(this.timeline);
        transition.start({
            ...settings,
            fromValue: fromValue,
            toValue: toValue
        });
        transitions.set(key, transition);
    }
    remove(key) {
        const { transitions: transitions  } = this;
        if (transitions.has(key)) {
            transitions.get(key).cancel();
            transitions.delete(key);
        }
    }
    update() {
        const propsInTransition = {};
        for (const [key, transition] of this.transitions){
            transition.update();
            propsInTransition[key] = transition.value;
            if (!transition.inProgress) this.remove(key);
        }
        return propsInTransition;
    }
    clear() {
        for (const key of this.transitions.keys())this.remove(key);
    }
}



function $52d5f19794fbf789$export$45855e0dd982478b(props) {
    const propTypes = $52d5f19794fbf789$var$getPropTypes(props);
    for(const propName in propTypes){
        const propType = propTypes[propName];
        const { validate: validate  } = propType;
        if (validate && !validate(props[propName], propType)) throw new Error("Invalid prop ".concat(propName, ": ").concat(props[propName]));
    }
}
function $52d5f19794fbf789$export$8b12422c455acfb9(props, oldProps) {
    const propsChangedReason = $52d5f19794fbf789$export$1557ccb739c4ea87({
        newProps: props,
        oldProps: oldProps,
        propTypes: $52d5f19794fbf789$var$getPropTypes(props),
        ignoreProps: {
            data: null,
            updateTriggers: null,
            extensions: null,
            transitions: null
        }
    });
    const dataChangedReason = $52d5f19794fbf789$var$diffDataProps(props, oldProps);
    let updateTriggersChangedReason = false;
    if (!dataChangedReason) updateTriggersChangedReason = $52d5f19794fbf789$var$diffUpdateTriggers(props, oldProps);
    return {
        dataChanged: dataChangedReason,
        propsChanged: propsChangedReason,
        updateTriggersChanged: updateTriggersChangedReason,
        extensionsChanged: $52d5f19794fbf789$var$diffExtensions(props, oldProps),
        transitionsChanged: $52d5f19794fbf789$var$diffTransitions(props, oldProps)
    };
}
function $52d5f19794fbf789$var$diffTransitions(props, oldProps) {
    if (!props.transitions) return false;
    const result = {};
    const propTypes = $52d5f19794fbf789$var$getPropTypes(props);
    let changed = false;
    for(const key in props.transitions){
        const propType = propTypes[key];
        const type = propType && propType.type;
        const isTransitionable = type === "number" || type === "color" || type === "array";
        if (isTransitionable && $52d5f19794fbf789$var$comparePropValues(props[key], oldProps[key], propType)) {
            result[key] = true;
            changed = true;
        }
    }
    return changed ? result : false;
}
function $52d5f19794fbf789$export$1557ccb739c4ea87({ newProps: newProps , oldProps: oldProps , ignoreProps: ignoreProps = {} , propTypes: propTypes = {} , triggerName: triggerName = "props"  }) {
    if (oldProps === newProps) return false;
    if (typeof newProps !== "object" || newProps === null) return "".concat(triggerName, " changed shallowly");
    if (typeof oldProps !== "object" || oldProps === null) return "".concat(triggerName, " changed shallowly");
    for (const key of Object.keys(newProps))if (!(key in ignoreProps)) {
        if (!(key in oldProps)) return "".concat(triggerName, ".").concat(key, " added");
        const changed = $52d5f19794fbf789$var$comparePropValues(newProps[key], oldProps[key], propTypes[key]);
        if (changed) return "".concat(triggerName, ".").concat(key, " ").concat(changed);
    }
    for (const key1 of Object.keys(oldProps))if (!(key1 in ignoreProps)) {
        if (!(key1 in newProps)) return "".concat(triggerName, ".").concat(key1, " dropped");
        if (!Object.hasOwnProperty.call(newProps, key1)) {
            const changed = $52d5f19794fbf789$var$comparePropValues(newProps[key1], oldProps[key1], propTypes[key1]);
            if (changed) return "".concat(triggerName, ".").concat(key1, " ").concat(changed);
        }
    }
    return false;
}
function $52d5f19794fbf789$var$comparePropValues(newProp, oldProp, propType) {
    let equal = propType && propType.equal;
    if (equal && !equal(newProp, oldProp, propType)) return "changed deeply";
    if (!equal) {
        equal = newProp && oldProp && newProp.equals;
        if (equal && !equal.call(newProp, oldProp)) return "changed deeply";
    }
    if (!equal && oldProp !== newProp) return "changed shallowly";
    return null;
}
function $52d5f19794fbf789$var$diffDataProps(props, oldProps) {
    if (oldProps === null) return "oldProps is null, initial diff";
    let dataChanged = false;
    const { dataComparator: dataComparator , _dataDiff: _dataDiff  } = props;
    if (dataComparator) {
        if (!dataComparator(props.data, oldProps.data)) dataChanged = "Data comparator detected a change";
    } else if (props.data !== oldProps.data) dataChanged = "A new data container was supplied";
    if (dataChanged && _dataDiff) dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
    return dataChanged;
}
function $52d5f19794fbf789$var$diffUpdateTriggers(props, oldProps) {
    if (oldProps === null) return {
        all: true
    };
    if ("all" in props.updateTriggers) {
        const diffReason = $52d5f19794fbf789$var$diffUpdateTrigger(props, oldProps, "all");
        if (diffReason) return {
            all: true
        };
    }
    const reason = {};
    let changed = false;
    for(const triggerName in props.updateTriggers)if (triggerName !== "all") {
        const diffReason = $52d5f19794fbf789$var$diffUpdateTrigger(props, oldProps, triggerName);
        if (diffReason) {
            reason[triggerName] = true;
            changed = true;
        }
    }
    return changed ? reason : false;
}
function $52d5f19794fbf789$var$diffExtensions(props, oldProps) {
    if (oldProps === null) return true;
    const oldExtensions = oldProps.extensions;
    const { extensions: extensions  } = props;
    if (extensions === oldExtensions) return false;
    if (!oldExtensions || !extensions) return true;
    if (extensions.length !== oldExtensions.length) return true;
    for(let i = 0; i < extensions.length; i++){
        if (!extensions[i].equals(oldExtensions[i])) return true;
    }
    return false;
}
function $52d5f19794fbf789$var$diffUpdateTrigger(props, oldProps, triggerName) {
    let newTriggers = props.updateTriggers[triggerName];
    newTriggers = newTriggers === undefined || newTriggers === null ? {} : newTriggers;
    let oldTriggers = oldProps.updateTriggers[triggerName];
    oldTriggers = oldTriggers === undefined || oldTriggers === null ? {} : oldTriggers;
    const diffReason = $52d5f19794fbf789$export$1557ccb739c4ea87({
        oldProps: oldTriggers,
        newProps: newTriggers,
        triggerName: triggerName
    });
    return diffReason;
}
function $52d5f19794fbf789$var$getPropTypes(props) {
    const layer = props[0, $434611e3e90ee53e$export$47f4402f338dd1fc];
    const LayerType = layer && layer.constructor;
    return LayerType ? LayerType._propTypes : {};
}



const $d69676cf99634f17$var$ERR_NOT_OBJECT = "count(): argument not an object";
const $d69676cf99634f17$var$ERR_NOT_CONTAINER = "count(): argument not a container";
function $d69676cf99634f17$export$85b9a36db797e02b(container) {
    if (!$d69676cf99634f17$var$isObject(container)) throw new Error($d69676cf99634f17$var$ERR_NOT_OBJECT);
    if (typeof container.count === "function") return container.count();
    if (Number.isFinite(container.size)) return container.size;
    if (Number.isFinite(container.length)) return container.length;
    if ($d69676cf99634f17$var$isPlainObject(container)) return Object.keys(container).length;
    throw new Error($d69676cf99634f17$var$ERR_NOT_CONTAINER);
}
function $d69676cf99634f17$var$isPlainObject(value) {
    return value !== null && typeof value === "object" && value.constructor === Object;
}
function $d69676cf99634f17$var$isObject(value) {
    return value !== null && typeof value === "object";
}







function $b59f746ed15ee2b5$export$95c481ecbbcfbbf1(target, source) {
    if (!source) return target;
    const result = {
        ...target,
        ...source
    };
    if ("defines" in source) result.defines = {
        ...target.defines,
        ...source.defines
    };
    if ("modules" in source) {
        result.modules = (target.modules || []).concat(source.modules);
        if (source.modules.some((module)=>module.name === "project64")) {
            const index = result.modules.findIndex((module)=>module.name === "project32");
            if (index >= 0) result.modules.splice(index, 1);
        }
    }
    if ("inject" in source) {
        if (!target.inject) result.inject = source.inject;
        else {
            const mergedInjection = {
                ...target.inject
            };
            for(const key in source.inject)mergedInjection[key] = (mergedInjection[key] || "") + source.inject[key];
            result.inject = mergedInjection;
        }
    }
    return result;
}








function $a6d9c45e493bd6f1$var$lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {
    const p = viewport.projectPosition(lngLatZ);
    if (offsetMode && viewport instanceof (0, $4ac7d89cb7f1c4ad$export$2e2bcd8739ae039)) {
        const [longitude, latitude, z = 0] = lngLatZ;
        const distanceScales = viewport.getDistanceScales([
            longitude,
            latitude
        ]);
        p[2] = z * distanceScales.unitsPerMeter[2];
    }
    return p;
}
function $a6d9c45e493bd6f1$var$normalizeParameters(opts) {
    const { viewport: viewport , modelMatrix: modelMatrix , coordinateOrigin: coordinateOrigin  } = opts;
    let { coordinateSystem: coordinateSystem , fromCoordinateSystem: fromCoordinateSystem , fromCoordinateOrigin: fromCoordinateOrigin  } = opts;
    if (coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).DEFAULT) coordinateSystem = viewport.isGeospatial ? (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT : (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).CARTESIAN;
    if (fromCoordinateSystem === undefined) fromCoordinateSystem = coordinateSystem;
    if (fromCoordinateOrigin === undefined) fromCoordinateOrigin = coordinateOrigin;
    return {
        viewport: viewport,
        coordinateSystem: coordinateSystem,
        coordinateOrigin: coordinateOrigin,
        modelMatrix: modelMatrix,
        fromCoordinateSystem: fromCoordinateSystem,
        fromCoordinateOrigin: fromCoordinateOrigin
    };
}
function $a6d9c45e493bd6f1$export$13d987dcd33aecbe(position, { viewport: viewport , modelMatrix: modelMatrix , coordinateSystem: coordinateSystem , coordinateOrigin: coordinateOrigin , offsetMode: offsetMode  }) {
    let [x, y, z = 0] = position;
    if (modelMatrix) [x, y, z] = $bd1e837fe7e33410$export$5ffbd13800309d59([], [
        x,
        y,
        z,
        1.0
    ], modelMatrix);
    switch(coordinateSystem){
        case (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT:
            return $a6d9c45e493bd6f1$var$lngLatZToWorldPosition([
                x,
                y,
                z
            ], viewport, offsetMode);
        case (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT_OFFSETS:
            return $a6d9c45e493bd6f1$var$lngLatZToWorldPosition([
                x + coordinateOrigin[0],
                y + coordinateOrigin[1],
                z + (coordinateOrigin[2] || 0)
            ], viewport, offsetMode);
        case (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).METER_OFFSETS:
            return $a6d9c45e493bd6f1$var$lngLatZToWorldPosition((0, $f5ef504cb5091e21$export$86ab4399faf187a8)(coordinateOrigin, [
                x,
                y,
                z
            ]), viewport, offsetMode);
        case (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).CARTESIAN:
        default:
            return viewport.isGeospatial ? [
                x + coordinateOrigin[0],
                y + coordinateOrigin[1],
                z + coordinateOrigin[2]
            ] : viewport.projectPosition([
                x,
                y,
                z
            ]);
    }
}
function $a6d9c45e493bd6f1$export$a3c26af9c425194b(position, params) {
    const { viewport: viewport , coordinateSystem: coordinateSystem , coordinateOrigin: coordinateOrigin , modelMatrix: modelMatrix , fromCoordinateSystem: fromCoordinateSystem , fromCoordinateOrigin: fromCoordinateOrigin  } = $a6d9c45e493bd6f1$var$normalizeParameters(params);
    const { geospatialOrigin: geospatialOrigin , shaderCoordinateOrigin: shaderCoordinateOrigin , offsetMode: offsetMode  } = (0, $072d6f1b352f2883$export$20f9eb1a42fcd22d)(viewport, coordinateSystem, coordinateOrigin);
    const worldPosition = $a6d9c45e493bd6f1$export$13d987dcd33aecbe(position, {
        viewport: viewport,
        modelMatrix: modelMatrix,
        coordinateSystem: fromCoordinateSystem,
        coordinateOrigin: fromCoordinateOrigin,
        offsetMode: offsetMode
    });
    if (offsetMode) {
        const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
        $68948bc2139893c7$export$f93b5905241a7cca(worldPosition, worldPosition, positionCommonSpace);
    }
    return worldPosition;
}








const $c810f8af9d0a3d4c$var$DEFAULT_TEXTURE_PARAMETERS = {
    [10241]: 9987,
    [10240]: 9729,
    [10242]: 33071,
    [10243]: 33071
};
const $c810f8af9d0a3d4c$var$internalTextures = {};
function $c810f8af9d0a3d4c$export$37b981a8c575f415(layer, image) {
    const gl = layer.context && layer.context.gl;
    if (!gl || !image) return null;
    if (image instanceof (0, $df31c887249e3faa$export$2e2bcd8739ae039)) return image;
    else if (image.constructor && image.constructor.name !== "Object") image = {
        data: image
    };
    let specialTextureParameters = null;
    if (image.compressed) specialTextureParameters = {
        [10241]: image.data.length > 1 ? 9985 : 9729
    };
    const texture = new (0, $df31c887249e3faa$export$2e2bcd8739ae039)(gl, {
        ...image,
        parameters: {
            ...$c810f8af9d0a3d4c$var$DEFAULT_TEXTURE_PARAMETERS,
            ...specialTextureParameters,
            ...layer.props.textureParameters
        }
    });
    $c810f8af9d0a3d4c$var$internalTextures[texture.id] = true;
    return texture;
}
function $c810f8af9d0a3d4c$export$2ec81868286b17e6(texture) {
    if (!texture || !(texture instanceof (0, $df31c887249e3faa$export$2e2bcd8739ae039))) return;
    if ($c810f8af9d0a3d4c$var$internalTextures[texture.id]) {
        texture.delete();
        delete $c810f8af9d0a3d4c$var$internalTextures[texture.id];
    }
}



const $7057c19ba02f49cd$var$TYPE_DEFINITIONS = {
    boolean: {
        validate (value, propType) {
            return true;
        },
        equal (value1, value2, propType) {
            return Boolean(value1) === Boolean(value2);
        }
    },
    number: {
        validate (value, propType) {
            return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
        }
    },
    color: {
        validate (value, propType) {
            return propType.optional && !value || $7057c19ba02f49cd$var$isArray(value) && (value.length === 3 || value.length === 4);
        },
        equal (value1, value2, propType) {
            return $7057c19ba02f49cd$var$arrayEqual(value1, value2);
        }
    },
    accessor: {
        validate (value, propType) {
            const valueType = $7057c19ba02f49cd$var$getTypeOf(value);
            return valueType === "function" || valueType === $7057c19ba02f49cd$var$getTypeOf(propType.value);
        },
        equal (value1, value2, propType) {
            if (typeof value2 === "function") return true;
            return $7057c19ba02f49cd$var$arrayEqual(value1, value2);
        }
    },
    array: {
        validate (value, propType) {
            return propType.optional && !value || $7057c19ba02f49cd$var$isArray(value);
        },
        equal (value1, value2, propType) {
            return propType.compare ? $7057c19ba02f49cd$var$arrayEqual(value1, value2) : value1 === value2;
        }
    },
    object: {
        equal (value1, value2, propType) {
            return propType.compare ? (0, $70a948cba88c73a3$export$9cb4719e2e525b7a)(value1, value2) : value1 === value2;
        }
    },
    function: {
        validate (value, propType) {
            return propType.optional && !value || typeof value === "function";
        },
        equal (value1, value2, propType) {
            return !propType.compare || value1 === value2;
        }
    },
    data: {
        transform: (value, propType, component)=>{
            const { dataTransform: dataTransform  } = component.props;
            return dataTransform && value ? dataTransform(value) : value;
        }
    },
    image: {
        transform: (value, propType, component)=>{
            return (0, $c810f8af9d0a3d4c$export$37b981a8c575f415)(component, value);
        },
        release: (value)=>{
            (0, $c810f8af9d0a3d4c$export$2ec81868286b17e6)(value);
        }
    }
};
function $7057c19ba02f49cd$var$arrayEqual(array1, array2) {
    if (array1 === array2) return true;
    if (!$7057c19ba02f49cd$var$isArray(array1) || !$7057c19ba02f49cd$var$isArray(array2)) return false;
    const len = array1.length;
    if (len !== array2.length) return false;
    for(let i = 0; i < len; i++){
        if (array1[i] !== array2[i]) return false;
    }
    return true;
}
function $7057c19ba02f49cd$export$6335b16489944934(propDefs) {
    const propTypes = {};
    const defaultProps = {};
    const deprecatedProps = {};
    for (const [propName, propDef] of Object.entries(propDefs)){
        const deprecated = propDef === null || propDef === void 0 ? void 0 : propDef.deprecatedFor;
        if (deprecated) deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [
            deprecated
        ];
        else {
            const propType = $7057c19ba02f49cd$var$parsePropType(propName, propDef);
            propTypes[propName] = propType;
            defaultProps[propName] = propType.value;
        }
    }
    return {
        propTypes: propTypes,
        defaultProps: defaultProps,
        deprecatedProps: deprecatedProps
    };
}
function $7057c19ba02f49cd$var$parsePropType(name, propDef) {
    switch($7057c19ba02f49cd$var$getTypeOf(propDef)){
        case "object":
            return $7057c19ba02f49cd$var$normalizePropDefinition(name, propDef);
        case "array":
            return $7057c19ba02f49cd$var$normalizePropDefinition(name, {
                type: "array",
                value: propDef,
                compare: false
            });
        case "boolean":
            return $7057c19ba02f49cd$var$normalizePropDefinition(name, {
                type: "boolean",
                value: propDef
            });
        case "number":
            return $7057c19ba02f49cd$var$normalizePropDefinition(name, {
                type: "number",
                value: propDef
            });
        case "function":
            return $7057c19ba02f49cd$var$normalizePropDefinition(name, {
                type: "function",
                value: propDef,
                compare: true
            });
        default:
            return {
                name: name,
                type: "unknown",
                value: propDef
            };
    }
}
function $7057c19ba02f49cd$var$normalizePropDefinition(name, propDef) {
    if (!("type" in propDef)) {
        if (!("value" in propDef)) return {
            name: name,
            type: "object",
            value: propDef
        };
        return {
            name: name,
            type: $7057c19ba02f49cd$var$getTypeOf(propDef.value),
            ...propDef
        };
    }
    return {
        name: name,
        ...$7057c19ba02f49cd$var$TYPE_DEFINITIONS[propDef.type],
        ...propDef
    };
}
function $7057c19ba02f49cd$var$isArray(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value);
}
function $7057c19ba02f49cd$var$getTypeOf(value) {
    if ($7057c19ba02f49cd$var$isArray(value)) return "array";
    if (value === null) return "null";
    return typeof value;
}



function $0d048365c5e17514$export$c94ea207b45fef3a(component, propObjects) {
    const propsPrototype = $0d048365c5e17514$var$getPropsPrototype(component.constructor);
    const propsInstance = Object.create(propsPrototype);
    propsInstance[0, $434611e3e90ee53e$export$47f4402f338dd1fc] = component;
    propsInstance[0, $434611e3e90ee53e$export$c313d789070da88c] = {};
    propsInstance[0, $434611e3e90ee53e$export$40aefa3472633071] = {};
    for(let i = 0; i < propObjects.length; ++i){
        const props = propObjects[i];
        for(const key in props)propsInstance[key] = props[key];
    }
    Object.freeze(propsInstance);
    return propsInstance;
}
function $0d048365c5e17514$var$getPropsPrototype(componentClass) {
    const defaultProps = $0d048365c5e17514$var$getOwnProperty(componentClass, "_mergedDefaultProps");
    if (!defaultProps) {
        $0d048365c5e17514$var$createPropsPrototypeAndTypes(componentClass);
        return componentClass._mergedDefaultProps;
    }
    return defaultProps;
}
function $0d048365c5e17514$var$createPropsPrototypeAndTypes(componentClass) {
    const parent = componentClass.prototype;
    if (!parent) return;
    const parentClass = Object.getPrototypeOf(componentClass);
    const parentDefaultProps = $0d048365c5e17514$var$getPropsPrototype(parentClass);
    const componentDefaultProps = $0d048365c5e17514$var$getOwnProperty(componentClass, "defaultProps") || {};
    const componentPropDefs = (0, $7057c19ba02f49cd$export$6335b16489944934)(componentDefaultProps);
    const defaultProps = $0d048365c5e17514$var$createPropsPrototype(componentPropDefs.defaultProps, parentDefaultProps, componentClass);
    const propTypes = {
        ...parentClass._propTypes,
        ...componentPropDefs.propTypes
    };
    $0d048365c5e17514$var$addAsyncPropsToPropPrototype(defaultProps, propTypes);
    const deprecatedProps = {
        ...parentClass._deprecatedProps,
        ...componentPropDefs.deprecatedProps
    };
    $0d048365c5e17514$var$addDeprecatedPropsToPropPrototype(defaultProps, deprecatedProps);
    componentClass._mergedDefaultProps = defaultProps;
    componentClass._propTypes = propTypes;
    componentClass._deprecatedProps = deprecatedProps;
}
function $0d048365c5e17514$var$createPropsPrototype(props, parentProps, componentClass) {
    const defaultProps = Object.create(null);
    Object.assign(defaultProps, parentProps, props);
    const id = $0d048365c5e17514$var$getComponentName(componentClass);
    delete props.id;
    Object.defineProperties(defaultProps, {
        id: {
            writable: true,
            value: id
        }
    });
    return defaultProps;
}
function $0d048365c5e17514$var$addDeprecatedPropsToPropPrototype(defaultProps, deprecatedProps) {
    for(const propName in deprecatedProps)Object.defineProperty(defaultProps, propName, {
        enumerable: false,
        set (newValue) {
            const nameStr = "".concat(this.id, ": ").concat(propName);
            for (const newPropName of deprecatedProps[propName])if (!$0d048365c5e17514$var$hasOwnProperty(this, newPropName)) this[newPropName] = newValue;
            (0, $146cba582e8c799f$export$2e2bcd8739ae039).deprecated(nameStr, deprecatedProps[propName].join("/"))();
        }
    });
}
function $0d048365c5e17514$var$addAsyncPropsToPropPrototype(defaultProps, propTypes) {
    const defaultValues = {};
    const descriptors = {};
    for(const propName in propTypes){
        const propType = propTypes[propName];
        const { name: name , value: value  } = propType;
        if (propType.async) {
            defaultValues[name] = value;
            descriptors[name] = $0d048365c5e17514$var$getDescriptorForAsyncProp(name);
        }
    }
    defaultProps[0, $434611e3e90ee53e$export$23f7c42255df7b05] = defaultValues;
    defaultProps[0, $434611e3e90ee53e$export$c313d789070da88c] = {};
    Object.defineProperties(defaultProps, descriptors);
}
function $0d048365c5e17514$var$getDescriptorForAsyncProp(name) {
    return {
        enumerable: true,
        set (newValue) {
            if (typeof newValue === "string" || newValue instanceof Promise || (0, $98a5ab1cbad9db41$export$edb10ab8dd75a915)(newValue)) this[0, $434611e3e90ee53e$export$c313d789070da88c][name] = newValue;
            else this[0, $434611e3e90ee53e$export$40aefa3472633071][name] = newValue;
        },
        get () {
            if (this[0, $434611e3e90ee53e$export$40aefa3472633071]) {
                if (name in this[0, $434611e3e90ee53e$export$40aefa3472633071]) {
                    const value = this[0, $434611e3e90ee53e$export$40aefa3472633071][name];
                    return value || this[0, $434611e3e90ee53e$export$23f7c42255df7b05][name];
                }
                if (name in this[0, $434611e3e90ee53e$export$c313d789070da88c]) {
                    const state = this[0, $434611e3e90ee53e$export$47f4402f338dd1fc] && this[0, $434611e3e90ee53e$export$47f4402f338dd1fc].internalState;
                    if (state && state.hasAsyncProp(name)) return state.getAsyncProp(name) || this[0, $434611e3e90ee53e$export$23f7c42255df7b05][name];
                }
            }
            return this[0, $434611e3e90ee53e$export$23f7c42255df7b05][name];
        }
    };
}
function $0d048365c5e17514$var$hasOwnProperty(object, prop) {
    return Object.prototype.hasOwnProperty.call(object, prop);
}
function $0d048365c5e17514$var$getOwnProperty(object, prop) {
    return $0d048365c5e17514$var$hasOwnProperty(object, prop) && object[prop];
}
function $0d048365c5e17514$var$getComponentName(componentClass) {
    const componentName = $0d048365c5e17514$var$getOwnProperty(componentClass, "layerName") || $0d048365c5e17514$var$getOwnProperty(componentClass, "componentName");
    if (!componentName) (0, $146cba582e8c799f$export$2e2bcd8739ae039).once(0, "".concat(componentClass.name, ".componentName not specified"))();
    return componentName || componentClass.name;
}


let $d492c99f5f269d3a$var$counter = 0;
class $d492c99f5f269d3a$export$2e2bcd8739ae039 {
    constructor(...propObjects){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "count", void 0);
        this.props = (0, $0d048365c5e17514$export$c94ea207b45fef3a)(this, propObjects);
        this.id = this.props.id;
        this.count = $d492c99f5f269d3a$var$counter++;
    }
    clone(newProps) {
        const { props: props  } = this;
        const asyncProps = {};
        for(const key in props[0, $434611e3e90ee53e$export$23f7c42255df7b05]){
            if (key in props[0, $434611e3e90ee53e$export$40aefa3472633071]) asyncProps[key] = props[0, $434611e3e90ee53e$export$40aefa3472633071][key];
            else if (key in props[0, $434611e3e90ee53e$export$c313d789070da88c]) asyncProps[key] = props[0, $434611e3e90ee53e$export$c313d789070da88c][key];
        }
        return new this.constructor({
            ...props,
            ...asyncProps,
            ...newProps
        });
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($d492c99f5f269d3a$export$2e2bcd8739ae039, "componentName", "Component");
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($d492c99f5f269d3a$export$2e2bcd8739ae039, "defaultProps", {});






const $65fd92247c959502$var$EMPTY_PROPS = Object.freeze({});
class $65fd92247c959502$export$2e2bcd8739ae039 {
    constructor(component){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "component", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "onAsyncPropUpdated", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "asyncProps", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "oldProps", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "oldAsyncProps", void 0);
        this.component = component;
        this.asyncProps = {};
        this.onAsyncPropUpdated = ()=>{};
        this.oldProps = null;
        this.oldAsyncProps = null;
    }
    finalize() {
        for(const propName in this.asyncProps){
            const asyncProp = this.asyncProps[propName];
            if (asyncProp && asyncProp.type && asyncProp.type.release) asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);
        }
    }
    getOldProps() {
        return this.oldAsyncProps || this.oldProps || $65fd92247c959502$var$EMPTY_PROPS;
    }
    resetOldProps() {
        this.oldAsyncProps = null;
        this.oldProps = this.component.props;
    }
    hasAsyncProp(propName) {
        return propName in this.asyncProps;
    }
    getAsyncProp(propName) {
        const asyncProp = this.asyncProps[propName];
        return asyncProp && asyncProp.resolvedValue;
    }
    isAsyncPropLoading(propName) {
        if (propName) {
            const asyncProp = this.asyncProps[propName];
            return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
        }
        for(const key in this.asyncProps){
            if (this.isAsyncPropLoading(key)) return true;
        }
        return false;
    }
    reloadAsyncProp(propName, value) {
        this._watchPromise(propName, Promise.resolve(value));
    }
    setAsyncProps(props) {
        const resolvedValues = props[0, $434611e3e90ee53e$export$40aefa3472633071] || {};
        const originalValues = props[0, $434611e3e90ee53e$export$c313d789070da88c] || props;
        const defaultValues = props[0, $434611e3e90ee53e$export$23f7c42255df7b05] || {};
        for(const propName in resolvedValues){
            const value = resolvedValues[propName];
            this._createAsyncPropData(propName, defaultValues[propName]);
            this._updateAsyncProp(propName, value);
            resolvedValues[propName] = this.getAsyncProp(propName);
        }
        for(const propName1 in originalValues){
            const value = originalValues[propName1];
            this._createAsyncPropData(propName1, defaultValues[propName1]);
            this._updateAsyncProp(propName1, value);
        }
    }
    _fetch(propName, url) {
        return null;
    }
    _onResolve(propName, value) {}
    _onError(propName, error) {}
    _updateAsyncProp(propName, value) {
        if (!this._didAsyncInputValueChange(propName, value)) return;
        if (typeof value === "string") value = this._fetch(propName, value);
        if (value instanceof Promise) {
            this._watchPromise(propName, value);
            return;
        }
        if ((0, $98a5ab1cbad9db41$export$edb10ab8dd75a915)(value)) {
            this._resolveAsyncIterable(propName, value);
            return;
        }
        this._setPropValue(propName, value);
    }
    _freezeAsyncOldProps() {
        if (!this.oldAsyncProps && this.oldProps) {
            this.oldAsyncProps = Object.create(this.oldProps);
            for(const propName in this.asyncProps)Object.defineProperty(this.oldAsyncProps, propName, {
                enumerable: true,
                value: this.oldProps[propName]
            });
        }
    }
    _didAsyncInputValueChange(propName, value) {
        const asyncProp = this.asyncProps[propName];
        if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) return false;
        asyncProp.lastValue = value;
        return true;
    }
    _setPropValue(propName, value) {
        this._freezeAsyncOldProps();
        const asyncProp = this.asyncProps[propName];
        if (asyncProp) {
            value = this._postProcessValue(asyncProp, value);
            asyncProp.resolvedValue = value;
            asyncProp.pendingLoadCount++;
            asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
        }
    }
    _setAsyncPropValue(propName, value, loadCount) {
        const asyncProp = this.asyncProps[propName];
        if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== undefined) {
            this._freezeAsyncOldProps();
            asyncProp.resolvedValue = value;
            asyncProp.resolvedLoadCount = loadCount;
            this.onAsyncPropUpdated(propName, value);
        }
    }
    _watchPromise(propName, promise) {
        const asyncProp = this.asyncProps[propName];
        if (asyncProp) {
            asyncProp.pendingLoadCount++;
            const loadCount = asyncProp.pendingLoadCount;
            promise.then((data)=>{
                data = this._postProcessValue(asyncProp, data);
                this._setAsyncPropValue(propName, data, loadCount);
                this._onResolve(propName, data);
            }).catch((error)=>{
                this._onError(propName, error);
            });
        }
    }
    async _resolveAsyncIterable(propName, iterable) {
        if (propName !== "data") {
            this._setPropValue(propName, iterable);
            return;
        }
        const asyncProp = this.asyncProps[propName];
        if (!asyncProp) return;
        asyncProp.pendingLoadCount++;
        const loadCount = asyncProp.pendingLoadCount;
        let data = [];
        let count = 0;
        for await (const chunk of iterable){
            const { dataTransform: dataTransform  } = this.component.props;
            if (dataTransform) data = dataTransform(chunk, data);
            else data = data.concat(chunk);
            Object.defineProperty(data, "__diff", {
                enumerable: false,
                value: [
                    {
                        startRow: count,
                        endRow: data.length
                    }
                ]
            });
            count = data.length;
            this._setAsyncPropValue(propName, data, loadCount);
        }
        this._onResolve(propName, data);
    }
    _postProcessValue(asyncProp, value) {
        const propType = asyncProp.type;
        if (propType) {
            if (propType.release) propType.release(asyncProp.resolvedValue, propType, this.component);
            if (propType.transform) return propType.transform(value, propType, this.component);
        }
        return value;
    }
    _createAsyncPropData(propName, defaultValue) {
        const asyncProp = this.asyncProps[propName];
        if (!asyncProp) {
            const propTypes = this.component && this.component.constructor._propTypes;
            this.asyncProps[propName] = {
                type: propTypes && propTypes[propName],
                lastValue: null,
                resolvedValue: defaultValue,
                pendingLoadCount: 0,
                resolvedLoadCount: 0
            };
        }
    }
}


class $3a7d9a91af406387$export$2e2bcd8739ae039 extends (0, $65fd92247c959502$export$2e2bcd8739ae039) {
    constructor({ attributeManager: attributeManager , layer: layer  }){
        super(layer);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "attributeManager", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "needsRedraw", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "needsUpdate", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "subLayers", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "usesPickingColorCache", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "changeFlags", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewport", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "uniformTransitions", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "propsInTransition", void 0);
        this.attributeManager = attributeManager;
        this.needsRedraw = true;
        this.needsUpdate = true;
        this.subLayers = null;
        this.usesPickingColorCache = false;
    }
    get layer() {
        return this.component;
    }
    set layer(layer) {
        this.component = layer;
    }
    _fetch(propName, url) {
        const fetch = this.component.props.fetch;
        if (fetch) return fetch(url, {
            propName: propName,
            layer: this.layer
        });
        return super._fetch(propName, url);
    }
    _onResolve(propName, value) {
        const onDataLoad = this.component.props.onDataLoad;
        if (propName === "data" && onDataLoad) onDataLoad(value, {
            propName: propName,
            layer: this.layer
        });
    }
    _onError(propName, error) {
        this.layer.raiseError(error, "loading ".concat(propName, " of ").concat(this.layer));
    }
}




const $d2bffe6b8ece4bb2$var$TRACE_CHANGE_FLAG = "layer.changeFlag";
const $d2bffe6b8ece4bb2$var$TRACE_INITIALIZE = "layer.initialize";
const $d2bffe6b8ece4bb2$var$TRACE_UPDATE = "layer.update";
const $d2bffe6b8ece4bb2$var$TRACE_FINALIZE = "layer.finalize";
const $d2bffe6b8ece4bb2$var$TRACE_MATCHED = "layer.matched";
const $d2bffe6b8ece4bb2$var$MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;
const $d2bffe6b8ece4bb2$var$EMPTY_ARRAY = Object.freeze([]);
const $d2bffe6b8ece4bb2$var$areViewportsEqual = (0, $1ccdae01919b6bce$export$2e2bcd8739ae039)(({ oldViewport: oldViewport , viewport: viewport  })=>{
    return oldViewport.equals(viewport);
});
let $d2bffe6b8ece4bb2$var$pickingColorCache = new Uint8ClampedArray(0);
const $d2bffe6b8ece4bb2$var$defaultProps = {
    data: {
        type: "data",
        value: $d2bffe6b8ece4bb2$var$EMPTY_ARRAY,
        async: true
    },
    dataComparator: {
        type: "function",
        value: null,
        compare: false,
        optional: true
    },
    _dataDiff: {
        type: "function",
        value: (data)=>data && data.__diff,
        compare: false,
        optional: true
    },
    dataTransform: {
        type: "function",
        value: null,
        compare: false,
        optional: true
    },
    onDataLoad: {
        type: "function",
        value: null,
        compare: false,
        optional: true
    },
    onError: {
        type: "function",
        value: null,
        compare: false,
        optional: true
    },
    fetch: {
        type: "function",
        value: (url, { propName: propName , layer: layer , loaders: loaders , loadOptions: loadOptions , signal: signal  })=>{
            const { resourceManager: resourceManager  } = layer.context;
            loadOptions = loadOptions || layer.getLoadOptions();
            loaders = loaders || layer.props.loaders;
            if (signal) {
                var _loadOptions;
                loadOptions = {
                    ...loadOptions,
                    fetch: {
                        ...(_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.fetch,
                        signal: signal
                    }
                };
            }
            let inResourceManager = resourceManager.contains(url);
            if (!inResourceManager && !loadOptions) {
                resourceManager.add({
                    resourceId: url,
                    data: (0, $10b58f50fbeb8045$export$11e63f7b0f3d9900)(url, loaders),
                    persistent: false
                });
                inResourceManager = true;
            }
            if (inResourceManager) return resourceManager.subscribe({
                resourceId: url,
                onChange: (data)=>{
                    var _layer$internalState;
                    return (_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.reloadAsyncProp(propName, data);
                },
                consumerId: layer.id,
                requestId: propName
            });
            return (0, $10b58f50fbeb8045$export$11e63f7b0f3d9900)(url, loaders, loadOptions);
        },
        compare: false
    },
    updateTriggers: {},
    visible: true,
    pickable: false,
    opacity: {
        type: "number",
        min: 0,
        max: 1,
        value: 1
    },
    operation: (0, $b42a5b9aa3b1a41f$export$b56168d831461ce2).DRAW,
    onHover: {
        type: "function",
        value: null,
        compare: false,
        optional: true
    },
    onClick: {
        type: "function",
        value: null,
        compare: false,
        optional: true
    },
    onDragStart: {
        type: "function",
        value: null,
        compare: false,
        optional: true
    },
    onDrag: {
        type: "function",
        value: null,
        compare: false,
        optional: true
    },
    onDragEnd: {
        type: "function",
        value: null,
        compare: false,
        optional: true
    },
    coordinateSystem: (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).DEFAULT,
    coordinateOrigin: {
        type: "array",
        value: [
            0,
            0,
            0
        ],
        compare: true
    },
    modelMatrix: {
        type: "array",
        value: null,
        compare: true,
        optional: true
    },
    wrapLongitude: false,
    positionFormat: "XYZ",
    colorFormat: "RGBA",
    parameters: {
        type: "object",
        value: {},
        optional: true,
        compare: true
    },
    transitions: null,
    extensions: [],
    loaders: {
        type: "array",
        value: [],
        optional: true,
        compare: true
    },
    getPolygonOffset: {
        type: "function",
        value: ({ layerIndex: layerIndex  })=>[
                0,
                -layerIndex * 100
            ],
        compare: false
    },
    highlightedObjectIndex: null,
    autoHighlight: false,
    highlightColor: {
        type: "accessor",
        value: [
            0,
            0,
            128,
            128
        ]
    }
};
class $d2bffe6b8ece4bb2$export$2e2bcd8739ae039 extends (0, $d492c99f5f269d3a$export$2e2bcd8739ae039) {
    constructor(...args){
        super(...args);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "internalState", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "lifecycle", (0, $434611e3e90ee53e$export$2cb9787dd463cbf4).NO_STATE);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "context", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "state", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "parent", null);
    }
    get root() {
        let layer = this;
        while(layer.parent)layer = layer.parent;
        return layer;
    }
    toString() {
        const className = this.constructor.layerName || this.constructor.name;
        return "".concat(className, "({id: '").concat(this.props.id, "'})");
    }
    project(xyz) {
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(this.internalState);
        const viewport = this.internalState.viewport || this.context.viewport;
        const worldPosition = (0, $a6d9c45e493bd6f1$export$13d987dcd33aecbe)(xyz, {
            viewport: viewport,
            modelMatrix: this.props.modelMatrix,
            coordinateOrigin: this.props.coordinateOrigin,
            coordinateSystem: this.props.coordinateSystem
        });
        const [x, y, z] = (0, $f5ef504cb5091e21$export$46d0dd92e8f9a0db)(worldPosition, viewport.pixelProjectionMatrix);
        return xyz.length === 2 ? [
            x,
            y
        ] : [
            x,
            y,
            z
        ];
    }
    unproject(xy) {
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(this.internalState);
        const viewport = this.internalState.viewport || this.context.viewport;
        return viewport.unproject(xy);
    }
    projectPosition(xyz, params) {
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(this.internalState);
        const viewport = this.internalState.viewport || this.context.viewport;
        return (0, $a6d9c45e493bd6f1$export$a3c26af9c425194b)(xyz, {
            viewport: viewport,
            modelMatrix: this.props.modelMatrix,
            coordinateOrigin: this.props.coordinateOrigin,
            coordinateSystem: this.props.coordinateSystem,
            ...params
        });
    }
    get isComposite() {
        return false;
    }
    setState(partialState) {
        this.setChangeFlags({
            stateChanged: true
        });
        Object.assign(this.state, partialState);
        this.setNeedsRedraw();
    }
    setNeedsRedraw() {
        if (this.internalState) this.internalState.needsRedraw = true;
    }
    setNeedsUpdate() {
        if (this.internalState) {
            this.context.layerManager.setNeedsUpdate(String(this));
            this.internalState.needsUpdate = true;
        }
    }
    get isLoaded() {
        return this.internalState ? !this.internalState.isAsyncPropLoading() : false;
    }
    get wrapLongitude() {
        return this.props.wrapLongitude;
    }
    isPickable() {
        return this.props.pickable && this.props.visible;
    }
    getModels() {
        return this.state && (this.state.models || this.state.model && [
            this.state.model
        ]) || [];
    }
    setModuleParameters(moduleParameters) {
        for (const model of this.getModels())model.updateModuleSettings(moduleParameters);
    }
    getAttributeManager() {
        return this.internalState && this.internalState.attributeManager;
    }
    getCurrentLayer() {
        return this.internalState && this.internalState.layer;
    }
    getLoadOptions() {
        return this.props.loadOptions;
    }
    use64bitPositions() {
        const { coordinateSystem: coordinateSystem  } = this.props;
        return coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).DEFAULT || coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT || coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).CARTESIAN;
    }
    onHover(info, pickingEvent) {
        if (this.props.onHover) return this.props.onHover(info, pickingEvent) || false;
        return false;
    }
    onClick(info, pickingEvent) {
        if (this.props.onClick) return this.props.onClick(info, pickingEvent) || false;
        return false;
    }
    nullPickingColor() {
        return [
            0,
            0,
            0
        ];
    }
    encodePickingColor(i, target = []) {
        target[0] = i + 1 & 255;
        target[1] = i + 1 >> 8 & 255;
        target[2] = i + 1 >> 8 >> 8 & 255;
        return target;
    }
    decodePickingColor(color) {
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(color instanceof Uint8Array);
        const [i1, i2, i3] = color;
        const index = i1 + i2 * 256 + i3 * 65536 - 1;
        return index;
    }
    getNumInstances() {
        if (Number.isFinite(this.props.numInstances)) return this.props.numInstances;
        if (this.state && this.state.numInstances !== undefined) return this.state.numInstances;
        return (0, $d69676cf99634f17$export$85b9a36db797e02b)(this.props.data);
    }
    getStartIndices() {
        if (this.props.startIndices) return this.props.startIndices;
        if (this.state && this.state.startIndices) return this.state.startIndices;
        return null;
    }
    getBounds() {
        var _ref;
        const attributeManager = this.getAttributeManager();
        if (!attributeManager) return null;
        const { positions: positions , instancePositions: instancePositions  } = attributeManager.attributes;
        return (_ref = positions || instancePositions) === null || _ref === void 0 ? void 0 : _ref.getBounds();
    }
    getShaders(shaders) {
        for (const extension of this.props.extensions)shaders = (0, $b59f746ed15ee2b5$export$95c481ecbbcfbbf1)(shaders, extension.getShaders.call(this, extension));
        return shaders;
    }
    shouldUpdateState(params) {
        return params.changeFlags.propsOrDataChanged;
    }
    updateState(params) {
        const attributeManager = this.getAttributeManager();
        const { dataChanged: dataChanged  } = params.changeFlags;
        if (dataChanged && attributeManager) {
            if (Array.isArray(dataChanged)) for (const dataRange of dataChanged)attributeManager.invalidateAll(dataRange);
            else attributeManager.invalidateAll();
        }
        const { props: props , oldProps: oldProps  } = params;
        const neededPickingBuffer = Number.isInteger(oldProps.highlightedObjectIndex) || oldProps.pickable;
        const needPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable;
        if (neededPickingBuffer !== needPickingBuffer && attributeManager) {
            const { pickingColors: pickingColors , instancePickingColors: instancePickingColors  } = attributeManager.attributes;
            const pickingColorsAttribute = pickingColors || instancePickingColors;
            if (pickingColorsAttribute) {
                if (needPickingBuffer && pickingColorsAttribute.constant) {
                    pickingColorsAttribute.constant = false;
                    attributeManager.invalidate(pickingColorsAttribute.id);
                }
                if (!pickingColorsAttribute.value && !needPickingBuffer) {
                    pickingColorsAttribute.constant = true;
                    pickingColorsAttribute.value = [
                        0,
                        0,
                        0
                    ];
                }
            }
        }
    }
    finalizeState(context) {
        for (const model of this.getModels())model.delete();
        const attributeManager = this.getAttributeManager();
        if (attributeManager) attributeManager.finalize();
        if (this.context) this.context.resourceManager.unsubscribe({
            consumerId: this.id
        });
        if (this.internalState) {
            this.internalState.uniformTransitions.clear();
            this.internalState.finalize();
        }
    }
    draw(opts) {
        for (const model of this.getModels())model.draw(opts);
    }
    getPickingInfo({ info: info , mode: mode , sourceLayer: sourceLayer  }) {
        const { index: index  } = info;
        if (index >= 0) {
            if (Array.isArray(this.props.data)) info.object = this.props.data[index];
        }
        return info;
    }
    raiseError(error, message) {
        var _this$props$onError, _this$props;
        if (message) error.message = "".concat(message, ": ").concat(error.message);
        if (!((_this$props$onError = (_this$props = this.props).onError) !== null && _this$props$onError !== void 0 && _this$props$onError.call(_this$props, error))) {
            var _this$context, _this$context$onError;
            (_this$context = this.context) === null || _this$context === void 0 || (_this$context$onError = _this$context.onError) === null || _this$context$onError === void 0 || _this$context$onError.call(_this$context, error, this);
        }
    }
    getNeedsRedraw(opts = {
        clearRedrawFlags: false
    }) {
        return this._getNeedsRedraw(opts);
    }
    needsUpdate() {
        if (!this.internalState) return false;
        return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
    }
    hasUniformTransition() {
        var _this$internalState;
        return ((_this$internalState = this.internalState) === null || _this$internalState === void 0 ? void 0 : _this$internalState.uniformTransitions.active) || false;
    }
    activateViewport(viewport) {
        if (!this.internalState) return;
        const oldViewport = this.internalState.viewport;
        this.internalState.viewport = viewport;
        if (!oldViewport || !$d2bffe6b8ece4bb2$var$areViewportsEqual({
            oldViewport: oldViewport,
            viewport: viewport
        })) {
            this.setChangeFlags({
                viewportChanged: true
            });
            if (this.isComposite) {
                if (this.needsUpdate()) this.setNeedsUpdate();
            } else this._update();
        }
    }
    invalidateAttribute(name = "all") {
        const attributeManager = this.getAttributeManager();
        if (!attributeManager) return;
        if (name === "all") attributeManager.invalidateAll();
        else attributeManager.invalidate(name);
    }
    updateAttributes(changedAttributes) {
        for (const model of this.getModels())this._setModelAttributes(model, changedAttributes);
    }
    _updateAttributes() {
        const attributeManager = this.getAttributeManager();
        if (!attributeManager) return;
        const props = this.props;
        const numInstances = this.getNumInstances();
        const startIndices = this.getStartIndices();
        attributeManager.update({
            data: props.data,
            numInstances: numInstances,
            startIndices: startIndices,
            props: props,
            transitions: props.transitions,
            buffers: props.data.attributes,
            context: this
        });
        const changedAttributes = attributeManager.getChangedAttributes({
            clearChangedFlags: true
        });
        this.updateAttributes(changedAttributes);
    }
    _updateAttributeTransition() {
        const attributeManager = this.getAttributeManager();
        if (attributeManager) attributeManager.updateTransition();
    }
    _updateUniformTransition() {
        const { uniformTransitions: uniformTransitions  } = this.internalState;
        if (uniformTransitions.active) {
            const propsInTransition = uniformTransitions.update();
            const props = Object.create(this.props);
            for(const key in propsInTransition)Object.defineProperty(props, key, {
                value: propsInTransition[key]
            });
            return props;
        }
        return this.props;
    }
    calculateInstancePickingColors(attribute, { numInstances: numInstances  }) {
        if (attribute.constant) return;
        const cacheSize = Math.floor($d2bffe6b8ece4bb2$var$pickingColorCache.length / 3);
        this.internalState.usesPickingColorCache = true;
        if (cacheSize < numInstances) {
            if (numInstances > $d2bffe6b8ece4bb2$var$MAX_PICKING_COLOR_CACHE_SIZE) (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")();
            $d2bffe6b8ece4bb2$var$pickingColorCache = (0, $e0cd51e92519f55c$export$2e2bcd8739ae039).allocate($d2bffe6b8ece4bb2$var$pickingColorCache, numInstances, {
                size: 3,
                copy: true,
                maxCount: Math.max(numInstances, $d2bffe6b8ece4bb2$var$MAX_PICKING_COLOR_CACHE_SIZE)
            });
            const newCacheSize = Math.floor($d2bffe6b8ece4bb2$var$pickingColorCache.length / 3);
            const pickingColor = [];
            for(let i = cacheSize; i < newCacheSize; i++){
                this.encodePickingColor(i, pickingColor);
                $d2bffe6b8ece4bb2$var$pickingColorCache[i * 3 + 0] = pickingColor[0];
                $d2bffe6b8ece4bb2$var$pickingColorCache[i * 3 + 1] = pickingColor[1];
                $d2bffe6b8ece4bb2$var$pickingColorCache[i * 3 + 2] = pickingColor[2];
            }
        }
        attribute.value = $d2bffe6b8ece4bb2$var$pickingColorCache.subarray(0, numInstances * 3);
    }
    _setModelAttributes(model, changedAttributes) {
        const attributeManager = this.getAttributeManager();
        const excludeAttributes = model.userData.excludeAttributes || {};
        const shaderAttributes = attributeManager.getShaderAttributes(changedAttributes, excludeAttributes);
        model.setAttributes(shaderAttributes);
    }
    disablePickingIndex(objectIndex) {
        this._disablePickingIndex(objectIndex);
    }
    _disablePickingIndex(objectIndex) {
        const { pickingColors: pickingColors , instancePickingColors: instancePickingColors  } = this.getAttributeManager().attributes;
        const colors = pickingColors || instancePickingColors;
        if (!colors) return;
        const start = colors.getVertexOffset(objectIndex);
        const end = colors.getVertexOffset(objectIndex + 1);
        colors.buffer.subData({
            data: new Uint8Array(end - start),
            offset: start
        });
    }
    restorePickingColors() {
        const { pickingColors: pickingColors , instancePickingColors: instancePickingColors  } = this.getAttributeManager().attributes;
        const colors = pickingColors || instancePickingColors;
        if (!colors) return;
        if (this.internalState.usesPickingColorCache && colors.value.buffer !== $d2bffe6b8ece4bb2$var$pickingColorCache.buffer) colors.value = $d2bffe6b8ece4bb2$var$pickingColorCache.subarray(0, colors.value.length);
        colors.updateSubBuffer({
            startOffset: 0
        });
    }
    _initialize() {
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(!this.internalState);
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(Number.isFinite(this.props.coordinateSystem));
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($d2bffe6b8ece4bb2$var$TRACE_INITIALIZE, this);
        const attributeManager = this._getAttributeManager();
        if (attributeManager) attributeManager.addInstanced({
            instancePickingColors: {
                type: 5121,
                size: 3,
                noAlloc: true,
                update: this.calculateInstancePickingColors
            }
        });
        this.internalState = new (0, $3a7d9a91af406387$export$2e2bcd8739ae039)({
            attributeManager: attributeManager,
            layer: this
        });
        this._clearChangeFlags();
        this.state = {};
        Object.defineProperty(this.state, "attributeManager", {
            get: ()=>{
                (0, $146cba582e8c799f$export$2e2bcd8739ae039).deprecated("layer.state.attributeManager", "layer.getAttributeManager()")();
                return attributeManager;
            }
        });
        this.internalState.layer = this;
        this.internalState.uniformTransitions = new (0, $bf7908ceda7e0357$export$2e2bcd8739ae039)(this.context.timeline);
        this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
        this.internalState.setAsyncProps(this.props);
        this.initializeState(this.context);
        for (const extension of this.props.extensions)extension.initializeState.call(this, this.context, extension);
        this.setChangeFlags({
            dataChanged: "init",
            propsChanged: "init",
            viewportChanged: true,
            extensionsChanged: true
        });
        this._update();
    }
    _transferState(oldLayer) {
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($d2bffe6b8ece4bb2$var$TRACE_MATCHED, this, this === oldLayer);
        const { state: state , internalState: internalState  } = oldLayer;
        if (this === oldLayer) return;
        this.internalState = internalState;
        this.internalState.layer = this;
        this.state = state;
        this.internalState.setAsyncProps(this.props);
        this._diffProps(this.props, this.internalState.getOldProps());
    }
    _update() {
        const stateNeedsUpdate = this.needsUpdate();
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($d2bffe6b8ece4bb2$var$TRACE_UPDATE, this, stateNeedsUpdate);
        if (!stateNeedsUpdate) return;
        const currentProps = this.props;
        const context = this.context;
        const internalState = this.internalState;
        const currentViewport = context.viewport;
        const propsInTransition = this._updateUniformTransition();
        internalState.propsInTransition = propsInTransition;
        context.viewport = internalState.viewport || currentViewport;
        this.props = propsInTransition;
        try {
            const updateParams = this._getUpdateParams();
            const oldModels = this.getModels();
            if (context.gl) this.updateState(updateParams);
            else try {
                this.updateState(updateParams);
            } catch (error) {}
            for (const extension of this.props.extensions)extension.updateState.call(this, updateParams, extension);
            const modelChanged = this.getModels()[0] !== oldModels[0];
            this._postUpdate(updateParams, modelChanged);
        } finally{
            context.viewport = currentViewport;
            this.props = currentProps;
            this._clearChangeFlags();
            internalState.needsUpdate = false;
            internalState.resetOldProps();
        }
    }
    _finalize() {
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($d2bffe6b8ece4bb2$var$TRACE_FINALIZE, this);
        this.finalizeState(this.context);
        for (const extension of this.props.extensions)extension.finalizeState.call(this, extension);
    }
    _drawLayer({ moduleParameters: moduleParameters = null , uniforms: uniforms = {} , parameters: parameters = {}  }) {
        this._updateAttributeTransition();
        const currentProps = this.props;
        const context = this.context;
        this.props = this.internalState.propsInTransition || currentProps;
        const opacity = this.props.opacity;
        uniforms.opacity = Math.pow(opacity, 1 / 2.2);
        try {
            if (moduleParameters) this.setModuleParameters(moduleParameters);
            const { getPolygonOffset: getPolygonOffset  } = this.props;
            const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [
                0,
                0
            ];
            (0, $54220aa8b6471f1a$export$60752c4a8a24d484)(context.gl, {
                polygonOffset: offsets
            });
            (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(context.gl, parameters, ()=>{
                const opts = {
                    moduleParameters: moduleParameters,
                    uniforms: uniforms,
                    parameters: parameters,
                    context: context
                };
                for (const extension of this.props.extensions)extension.draw.call(this, opts, extension);
                this.draw(opts);
            });
        } finally{
            this.props = currentProps;
        }
    }
    getChangeFlags() {
        var _this$internalState2;
        return (_this$internalState2 = this.internalState) === null || _this$internalState2 === void 0 ? void 0 : _this$internalState2.changeFlags;
    }
    setChangeFlags(flags) {
        if (!this.internalState) return;
        const { changeFlags: changeFlags  } = this.internalState;
        for(const key in flags)if (flags[key]) {
            let flagChanged = false;
            switch(key){
                case "dataChanged":
                    const dataChangedReason = flags[key];
                    const prevDataChangedReason = changeFlags[key];
                    if (dataChangedReason && Array.isArray(prevDataChangedReason)) {
                        changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;
                        flagChanged = true;
                    }
                default:
                    if (!changeFlags[key]) {
                        changeFlags[key] = flags[key];
                        flagChanged = true;
                    }
            }
            if (flagChanged) (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($d2bffe6b8ece4bb2$var$TRACE_CHANGE_FLAG, this, key, flags);
        }
        const propsOrDataChanged = Boolean(changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged);
        changeFlags.propsOrDataChanged = propsOrDataChanged;
        changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;
    }
    _clearChangeFlags() {
        this.internalState.changeFlags = {
            dataChanged: false,
            propsChanged: false,
            updateTriggersChanged: false,
            viewportChanged: false,
            stateChanged: false,
            extensionsChanged: false,
            propsOrDataChanged: false,
            somethingChanged: false
        };
    }
    _diffProps(newProps, oldProps) {
        const changeFlags = (0, $52d5f19794fbf789$export$8b12422c455acfb9)(newProps, oldProps);
        if (changeFlags.updateTriggersChanged) {
            for(const key in changeFlags.updateTriggersChanged)if (changeFlags.updateTriggersChanged[key]) this.invalidateAttribute(key);
        }
        if (changeFlags.transitionsChanged) for(const key in changeFlags.transitionsChanged){
            var _newProps$transitions;
            this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], (_newProps$transitions = newProps.transitions) === null || _newProps$transitions === void 0 ? void 0 : _newProps$transitions[key]);
        }
        return this.setChangeFlags(changeFlags);
    }
    validateProps() {
        (0, $52d5f19794fbf789$export$45855e0dd982478b)(this.props);
    }
    updateAutoHighlight(info) {
        if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) this._updateAutoHighlight(info);
    }
    _updateAutoHighlight(info) {
        const pickingModuleParameters = {
            pickingSelectedColor: info.picked ? info.color : null
        };
        const { highlightColor: highlightColor  } = this.props;
        if (info.picked && typeof highlightColor === "function") pickingModuleParameters.pickingHighlightColor = highlightColor(info);
        this.setModuleParameters(pickingModuleParameters);
        this.setNeedsRedraw();
    }
    _getAttributeManager() {
        const context = this.context;
        return new (0, $1bed349e8c64a1f7$export$2e2bcd8739ae039)(context.gl, {
            id: this.props.id,
            stats: context.stats,
            timeline: context.timeline
        });
    }
    _postUpdate(updateParams, forceUpdate) {
        const { props: props , oldProps: oldProps  } = updateParams;
        this.setNeedsRedraw();
        this._updateAttributes();
        const { model: model  } = this.state;
        model === null || model === void 0 || model.setInstanceCount(this.getNumInstances());
        const { autoHighlight: autoHighlight , highlightedObjectIndex: highlightedObjectIndex , highlightColor: highlightColor  } = props;
        if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
            const parameters = {};
            if (!autoHighlight) parameters.pickingSelectedColor = null;
            if (Array.isArray(highlightColor)) parameters.pickingHighlightColor = highlightColor;
            if (Number.isInteger(highlightedObjectIndex)) parameters.pickingSelectedColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
            this.setModuleParameters(parameters);
        }
    }
    _getUpdateParams() {
        return {
            props: this.props,
            oldProps: this.internalState.getOldProps(),
            context: this.context,
            changeFlags: this.internalState.changeFlags
        };
    }
    _getNeedsRedraw(opts) {
        if (!this.internalState) return false;
        let redraw = false;
        redraw = redraw || this.internalState.needsRedraw && this.id;
        this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
        const attributeManager = this.getAttributeManager();
        const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;
        redraw = redraw || attributeManagerNeedsRedraw;
        return redraw;
    }
    _onAsyncPropUpdated() {
        this._diffProps(this.props, this.internalState.getOldProps());
        this.setNeedsUpdate();
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($d2bffe6b8ece4bb2$export$2e2bcd8739ae039, "defaultProps", $d2bffe6b8ece4bb2$var$defaultProps);
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($d2bffe6b8ece4bb2$export$2e2bcd8739ae039, "layerName", "Layer");






var $c55ed784d5da8e09$export$2e2bcd8739ae039 = "#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n\n  // Multiply out radius and clamp to limits\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\n    radiusMinPixels, radiusMaxPixels\n  );\n  \n  // Multiply out line width and clamp to limits\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n\n  // outer radius needs to offset by half stroke width\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n\n  // Expand geometry to accomodate edge smoothing\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\n\n  // position on the containing square in [-1, 1] space\n  unitPosition = edgePadding * positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n  }\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  // Apply opacity to instance color, or return instance picking color\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n";


var $3a29ace6ffd96684$export$2e2bcd8739ae039 = "#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\nuniform bool antialiasing;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = antialiasing ? \n    smoothedge(distToCenter, outerRadiusPixels) : \n    step(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = antialiasing ? \n      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\n      step(innerUnitRadius * outerRadiusPixels, distToCenter);\n\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";


const $1eba0b0ef795af2a$var$DEFAULT_COLOR = [
    0,
    0,
    0,
    255
];
const $1eba0b0ef795af2a$var$defaultProps = {
    radiusUnits: "meters",
    radiusScale: {
        type: "number",
        min: 0,
        value: 1
    },
    radiusMinPixels: {
        type: "number",
        min: 0,
        value: 0
    },
    radiusMaxPixels: {
        type: "number",
        min: 0,
        value: Number.MAX_SAFE_INTEGER
    },
    lineWidthUnits: "meters",
    lineWidthScale: {
        type: "number",
        min: 0,
        value: 1
    },
    lineWidthMinPixels: {
        type: "number",
        min: 0,
        value: 0
    },
    lineWidthMaxPixels: {
        type: "number",
        min: 0,
        value: Number.MAX_SAFE_INTEGER
    },
    stroked: false,
    filled: true,
    billboard: false,
    antialiasing: true,
    getPosition: {
        type: "accessor",
        value: (x)=>x.position
    },
    getRadius: {
        type: "accessor",
        value: 1
    },
    getFillColor: {
        type: "accessor",
        value: $1eba0b0ef795af2a$var$DEFAULT_COLOR
    },
    getLineColor: {
        type: "accessor",
        value: $1eba0b0ef795af2a$var$DEFAULT_COLOR
    },
    getLineWidth: {
        type: "accessor",
        value: 1
    },
    strokeWidth: {
        deprecatedFor: "getLineWidth"
    },
    outline: {
        deprecatedFor: "stroked"
    },
    getColor: {
        deprecatedFor: [
            "getFillColor",
            "getLineColor"
        ]
    }
};
class $1eba0b0ef795af2a$export$2e2bcd8739ae039 extends (0, $d2bffe6b8ece4bb2$export$2e2bcd8739ae039) {
    getShaders() {
        return super.getShaders({
            vs: $c55ed784d5da8e09$export$2e2bcd8739ae039,
            fs: $3a29ace6ffd96684$export$2e2bcd8739ae039,
            modules: [
                (0, $fbfc65ad8db06720$export$2e2bcd8739ae039),
                (0, $1c9ba1aa9caca970$export$2e2bcd8739ae039)
            ]
        });
    }
    initializeState() {
        this.getAttributeManager().addInstanced({
            instancePositions: {
                size: 3,
                type: 5130,
                fp64: this.use64bitPositions(),
                transition: true,
                accessor: "getPosition"
            },
            instanceRadius: {
                size: 1,
                transition: true,
                accessor: "getRadius",
                defaultValue: 1
            },
            instanceFillColors: {
                size: this.props.colorFormat.length,
                transition: true,
                normalized: true,
                type: 5121,
                accessor: "getFillColor",
                defaultValue: [
                    0,
                    0,
                    0,
                    255
                ]
            },
            instanceLineColors: {
                size: this.props.colorFormat.length,
                transition: true,
                normalized: true,
                type: 5121,
                accessor: "getLineColor",
                defaultValue: [
                    0,
                    0,
                    0,
                    255
                ]
            },
            instanceLineWidths: {
                size: 1,
                transition: true,
                accessor: "getLineWidth",
                defaultValue: 1
            }
        });
    }
    updateState(params) {
        super.updateState(params);
        if (params.changeFlags.extensionsChanged) {
            var _this$state$model;
            const { gl: gl  } = this.context;
            (_this$state$model = this.state.model) === null || _this$state$model === void 0 || _this$state$model.delete();
            this.state.model = this._getModel(gl);
            this.getAttributeManager().invalidateAll();
        }
    }
    draw({ uniforms: uniforms  }) {
        const { radiusUnits: radiusUnits , radiusScale: radiusScale , radiusMinPixels: radiusMinPixels , radiusMaxPixels: radiusMaxPixels , stroked: stroked , filled: filled , billboard: billboard , antialiasing: antialiasing , lineWidthUnits: lineWidthUnits , lineWidthScale: lineWidthScale , lineWidthMinPixels: lineWidthMinPixels , lineWidthMaxPixels: lineWidthMaxPixels  } = this.props;
        this.state.model.setUniforms(uniforms).setUniforms({
            stroked: stroked ? 1 : 0,
            filled: filled,
            billboard: billboard,
            antialiasing: antialiasing,
            radiusUnits: (0, $b42a5b9aa3b1a41f$export$97361b7a0c542045)[radiusUnits],
            radiusScale: radiusScale,
            radiusMinPixels: radiusMinPixels,
            radiusMaxPixels: radiusMaxPixels,
            lineWidthUnits: (0, $b42a5b9aa3b1a41f$export$97361b7a0c542045)[lineWidthUnits],
            lineWidthScale: lineWidthScale,
            lineWidthMinPixels: lineWidthMinPixels,
            lineWidthMaxPixels: lineWidthMaxPixels
        }).draw();
    }
    _getModel(gl) {
        const positions = [
            -1,
            -1,
            0,
            1,
            -1,
            0,
            1,
            1,
            0,
            -1,
            1,
            0
        ];
        return new (0, $d4b5fa431316d551$export$2e2bcd8739ae039)(gl, {
            ...this.getShaders(),
            id: this.props.id,
            geometry: new (0, $71650ad4c5341938$export$2e2bcd8739ae039)({
                drawMode: 6,
                vertexCount: 4,
                attributes: {
                    positions: {
                        size: 3,
                        value: new Float32Array(positions)
                    }
                }
            }),
            isInstanced: true
        });
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($1eba0b0ef795af2a$export$2e2bcd8739ae039, "defaultProps", $1eba0b0ef795af2a$var$defaultProps);
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($1eba0b0ef795af2a$export$2e2bcd8739ae039, "layerName", "ScatterplotLayer");



const $c004c9ae6f1631a3$var$INITIAL_VIEW_STATE = {
    latitude: 37.8,
    longitude: -122.45,
    zoom: 15
};
const $c004c9ae6f1631a3$var$deckgl = new (0, $4afbf505f2c4bce1$export$2e2bcd8739ae039)({
    initialViewState: $c004c9ae6f1631a3$var$INITIAL_VIEW_STATE,
    controller: true,
    layers: [
        new (0, $1eba0b0ef795af2a$export$2e2bcd8739ae039)({
            data: [
                {
                    position: [
                        -122.45,
                        37.8
                    ],
                    color: [
                        255,
                        0,
                        0
                    ],
                    radius: 100
                }
            ],
            getColor: (d)=>d.color,
            getRadius: (d)=>d.radius
        })
    ]
});


//# sourceMappingURL=pgl_module.js.map
